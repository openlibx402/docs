{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"OpenLibx402: Autonomous Payments for AI Agents","text":"<p>Enable AI agents and web APIs to autonomously pay for services using HTTP 402 \"Payment Required\" and Solana blockchain</p> <p> </p>"},{"location":"#what-is-openlibx402","title":"What is OpenLibx402?","text":"<p>OpenLibx402 is a library ecosystem that implements the X402 protocol - an open standard for enabling AI agents to autonomously pay for API access, data, and digital services using the HTTP 402 \"Payment Required\" status code and blockchain micropayments.</p>"},{"location":"#key-features","title":"Key Features","text":"<p>\u2728 One-Line Integration - Add payments to APIs with a single decorator \ud83e\udd16 AI-Native - Built specifically for autonomous agent workflows \u26a1 Instant Settlement - Payments settle in ~200ms on Solana \ud83d\udcb0 Micropayments - Support payments as low as $0.001 \ud83d\udd10 No Accounts - No API keys, subscriptions, or manual billing \ud83c\udf10 Chain-Agnostic Design - Solana first, architected for multi-chain \ud83d\udee0\ufe0f Framework Integrations - FastAPI, LangChain, LangGraph, and more</p>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#server-fastapi","title":"Server (FastAPI)","text":"<pre><code>from fastapi import FastAPI\nfrom openlibx402_fastapi import payment_required\n\napp = FastAPI()\n\n@app.get(\"/premium-data\")\n@payment_required(\n    amount=\"0.10\",\n    payment_address=\"YOUR_WALLET_ADDRESS\",\n    token_mint=\"USDC_MINT_ADDRESS\"\n)\nasync def get_premium_data():\n    return {\"data\": \"Premium content\"}\n</code></pre>"},{"location":"#client-auto-payment","title":"Client (Auto-Payment)","text":"<pre><code>from openlibx402_client import X402AutoClient\nfrom solders.keypair import Keypair\n\nclient = X402AutoClient(wallet_keypair=keypair)\n\n# Automatically handles 402 and pays\nresponse = await client.fetch(\"https://api.example.com/premium-data\")\ndata = response.json()\n</code></pre>"},{"location":"#langchain-agent","title":"LangChain Agent","text":"<pre><code>from openlibx402_langchain import create_x402_agent\nfrom langchain.chat_models import ChatOpenAI\n\nagent = create_x402_agent(\n    wallet_keypair=keypair,\n    llm=ChatOpenAI(),\n    max_payment=\"5.0\"\n)\n\nresponse = agent.run(\"Get premium market data from the API\")\n</code></pre>"},{"location":"#how-it-works","title":"How It Works","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  AI Agent   \u2502  \u25001\u2500\u2192   \u2502  API Server  \u2502         \u2502 Blockchain \u2502\n\u2502   (Client)  \u2502         \u2502   (Server)   \u2502         \u2502  (Solana)  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502                        \u2502                        \u2502\n       \u2502  GET /data             \u2502                        \u2502\n       \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2192\u2502                        \u2502\n       \u2502                        \u2502                        \u2502\n       \u2502  402 Payment Required  \u2502                        \u2502\n       \u2502  + Payment Details     \u2502                        \u2502\n       \u2502\u2190\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524                        \u2502\n       \u2502                        \u2502                        \u2502\n       \u2502  Create &amp; Broadcast    \u2502                        \u2502\n       \u2502  Payment Transaction   \u2502                        \u2502\n       \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2192\u2502\n       \u2502                        \u2502                        \u2502\n       \u2502                        \u2502   Verify Transaction   \u2502\n       \u2502                        \u2502\u2190\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n       \u2502                        \u2502                        \u2502\n       \u2502  GET /data             \u2502                        \u2502\n       \u2502  + Payment Auth Header \u2502                        \u2502\n       \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2192\u2502                        \u2502\n       \u2502                        \u2502                        \u2502\n       \u2502  200 OK + Data         \u2502                        \u2502\n       \u2502\u2190\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524                        \u2502\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<p>\ud83d\udcda Technical Specification - Complete architecture and design \ud83d\udcd6 Quick Reference - Common patterns and examples \ud83d\udcdd Project Summary - Overview and next steps</p>"},{"location":"#packages","title":"Packages","text":""},{"location":"#core","title":"Core","text":"<ul> <li><code>openlibx402-core</code> - Core protocol implementation</li> <li><code>@openlibx402/core</code> - TypeScript equivalent</li> </ul>"},{"location":"#server-frameworks","title":"Server Frameworks","text":"<ul> <li><code>openlibx402-fastapi</code> - FastAPI middleware (Python)</li> <li><code>@openlibx402/express</code> - Express.js middleware (TypeScript)</li> <li><code>@openlibx402/nextjs</code> - Next.js API routes (TypeScript)</li> <li><code>@openlibx402/hono</code> - Hono middleware (TypeScript)</li> </ul>"},{"location":"#client-libraries","title":"Client Libraries","text":"<ul> <li><code>openlibx402-client</code> - HTTP client with payment support (Python)</li> <li><code>@openlibx402/client</code> - TypeScript client</li> </ul>"},{"location":"#ai-agent-integrations","title":"AI Agent Integrations","text":"<ul> <li><code>openlibx402-langchain</code> - LangChain Tool &amp; Middleware (Python)</li> <li><code>openlibx402-langgraph</code> - LangGraph nodes (Python)</li> <li><code>@openlibx402/langchain</code> - TypeScript LangChain integration</li> <li><code>@openlibx402/langgraph</code> - TypeScript LangGraph integration</li> </ul>"},{"location":"#use-cases","title":"Use Cases","text":""},{"location":"#for-api-providers","title":"For API Providers","text":"<ul> <li>\ud83d\udcb5 Monetize APIs with pay-per-use pricing</li> <li>\ud83d\udeab Eliminate API key management</li> <li>\u26a1 Instant payment settlement</li> <li>\ud83d\udee1\ufe0f No chargebacks or fraud risk</li> </ul>"},{"location":"#for-ai-agents","title":"For AI Agents","text":"<ul> <li>\ud83d\udd13 Access premium data without human intervention</li> <li>\ud83d\udcb0 Pay exactly for what you use</li> <li>\ud83c\udf0d No geographic restrictions</li> <li>\ud83e\udd16 Fully autonomous operation</li> </ul>"},{"location":"#real-world-examples","title":"Real-World Examples","text":"<ul> <li>\ud83d\udcca Research agent paying per financial data point</li> <li>\ud83c\udfaf Trading bot accessing real-time market data</li> <li>\ud83d\udcf0 Content aggregator paying per article</li> <li>\ud83d\uddbc\ufe0f Image generation API charging per image</li> <li>\u2601\ufe0f GPU compute charged per minute</li> </ul>"},{"location":"#architecture","title":"Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Application Layer                    \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510             \u2502\n\u2502  \u2502 FastAPI  \u2502  \u2502LangChain \u2502  \u2502LangGraph \u2502             \u2502\n\u2502  \u2502 Middleware\u2502  \u2502   Tool   \u2502  \u2502  Nodes   \u2502             \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u2502             \u2502             \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502              openlibx402-core / @openlibx402/core              \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502   Payment    \u2502  \u2502    Solana    \u2502  \u2502     Error     \u2502  \u2502\n\u2502  \u2502    Models    \u2502  \u2502  Processor   \u2502  \u2502   Handling    \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                            \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                   Blockchain Layer                       \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510              \u2502\n\u2502  \u2502  Solana  \u2502  \u2502 Ethereum \u2502  \u2502   Base   \u2502  (Future)    \u2502\n\u2502  \u2502  Devnet  \u2502  \u2502 Mainnet  \u2502  \u2502    L2    \u2502              \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"#development-status","title":"Development Status","text":""},{"location":"#phase-1-python","title":"\u2705 Phase 1: Python","text":"<ul> <li>\u2705 Technical specification complete</li> <li>\u2705 Core package (Python)</li> <li>\u2705 FastAPI integration</li> <li>\u2705 Client library</li> <li>\u2705 LangChain integration</li> <li>\u2705 LangGraph integration</li> <li>\u2705 Example implementations</li> </ul>"},{"location":"#phase-2-typescript","title":"\ud83c\udfd7\ufe0f Phase 2: TypeScript","text":"<ul> <li>\u2705 Core package (TypeScript)</li> <li>\u2705 Express.js middleware</li> <li>\u2705 Client library (TS)</li> <li>\u2705 LangChain.js integration</li> <li>\u2705 LangGraph.js integration</li> <li>\ud83c\udfd7\ufe0f Next.js integration</li> </ul>"},{"location":"#phase-3-ecosystem","title":"\ud83d\udd32 Phase 3: Ecosystem","text":"<ul> <li>[ ] Flask middleware</li> <li>[ ] Django middleware</li> <li>[ ] Hono middleware</li> <li>[ ] Additional agent frameworks</li> <li>[ ] CLI tools</li> </ul>"},{"location":"#phase-4-advanced","title":"\ud83d\udd32 Phase 4: Advanced","text":"<ul> <li>[ ] Multi-chain support (Ethereum, Base)</li> <li>[ ] Payment batching</li> <li>[ ] Admin dashboard</li> <li>[ ] Analytics &amp; monitoring</li> <li>[ ] Browser extension</li> </ul>"},{"location":"#installation-when-available","title":"Installation (When Available)","text":""},{"location":"#python","title":"Python","text":"<pre><code>pip install openlibx402-core openlibx402-fastapi openlibx402-client\npip install openlibx402-langchain openlibx402-langgraph\n</code></pre>"},{"location":"#typescript","title":"TypeScript","text":"<pre><code>npm install @openlibx402/core @openlibx402/express @openlibx402/client\nnpm install @openlibx402/langchain @openlibx402/langgraph\n</code></pre>"},{"location":"#examples","title":"Examples","text":""},{"location":"#fastapi-server","title":"FastAPI Server","text":"<pre><code>from fastapi import FastAPI\nfrom openlibx402_fastapi import X402Config, init_x402, payment_required\n\n# Initialize X402\nconfig = X402Config(\n    payment_address=\"YOUR_WALLET\",\n    token_mint=\"USDC_MINT\",\n    network=\"solana-devnet\"\n)\ninit_x402(config)\n\napp = FastAPI()\n\n@app.get(\"/basic-data\")\nasync def get_basic_data():\n    return {\"data\": \"Free content\"}\n\n@app.get(\"/premium-data\")\n@payment_required(amount=\"0.10\", description=\"Premium market data\")\nasync def get_premium_data():\n    return {\"data\": \"Premium content\", \"price\": 100.50}\n</code></pre>"},{"location":"#langchain-agent_1","title":"LangChain Agent","text":"<pre><code>from langchain.chat_models import ChatOpenAI\nfrom openlibx402_langchain import create_x402_agent\nfrom solders.keypair import Keypair\n\n# Load wallet\nkeypair = Keypair()\n\n# Create agent with X402 support\nagent = create_x402_agent(\n    wallet_keypair=keypair,\n    llm=ChatOpenAI(),\n    max_payment=\"5.0\"\n)\n\n# Agent can now autonomously pay for API access\nresponse = agent.run(\n    \"Get the latest market data from https://api.example.com/premium-data \"\n    \"and summarize the key trends\"\n)\n</code></pre>"},{"location":"#langgraph-workflow","title":"LangGraph Workflow","text":"<pre><code>from typing import TypedDict\nfrom langgraph.graph import StateGraph, END\nfrom openlibx402_langgraph import payment_node, check_payment_required\nfrom solders.keypair import Keypair\n\nclass AgentState(TypedDict):\n    api_url: str\n    api_response: str\n    payment_required: bool\n    payment_completed: bool\n    wallet_keypair: Keypair\n\nworkflow = StateGraph(AgentState)\n\nworkflow.add_node(\"fetch\", fetch_api_node)\nworkflow.add_node(\"pay\", payment_node)  # From openlibx402-langgraph\nworkflow.add_node(\"process\", process_node)\n\nworkflow.set_entry_point(\"fetch\")\n\nworkflow.add_conditional_edges(\n    \"fetch\",\n    check_payment_required,\n    {\n        \"payment_required\": \"pay\",\n        \"success\": \"process\",\n        \"error\": END\n    }\n)\n\nworkflow.add_edge(\"pay\", \"fetch\")\nworkflow.add_edge(\"process\", END)\n\napp = workflow.compile()\n</code></pre>"},{"location":"#configuration","title":"Configuration","text":""},{"location":"#environment-variables","title":"Environment Variables","text":"<pre><code>X402_PAYMENT_ADDRESS=YourSolanaWalletAddress\nX402_TOKEN_MINT=USDC_MINT_ADDRESS\nX402_NETWORK=solana-devnet\nX402_RPC_URL=https://api.devnet.solana.com\n</code></pre>"},{"location":"#code-configuration","title":"Code Configuration","text":"<pre><code>from openlibx402_fastapi import X402Config\n\nconfig = X402Config(\n    payment_address=\"YOUR_WALLET\",\n    token_mint=\"USDC_MINT\",\n    network=\"solana-devnet\",\n    rpc_url=\"https://api.devnet.solana.com\",\n    payment_timeout=300,  # 5 minutes\n    auto_verify=True\n)\n</code></pre>"},{"location":"#security","title":"Security","text":"<p>\ud83d\udd10 Key Security Features: - Private keys never leave client - On-chain transaction verification - Nonce-based replay protection - Payment expiration timestamps - Maximum payment limits - HTTPS required for production</p> <p>\u26a0\ufe0f Security Best Practices: - Never log private keys - Use environment variables for secrets - Validate all payment fields - Set reasonable payment timeouts - Implement rate limiting - Use hardware wallets in production</p>"},{"location":"#testing","title":"Testing","text":""},{"location":"#mock-payment-processor","title":"Mock Payment Processor","text":"<pre><code>from openlibx402_core.testing import MockSolanaPaymentProcessor\n\nprocessor = MockSolanaPaymentProcessor()\nprocessor.balance = 100.0\n\n# Use in tests without real blockchain\nclient = X402AutoClient(wallet_keypair=test_keypair)\nclient.client.processor = processor\n</code></pre>"},{"location":"#test-server","title":"Test Server","text":"<pre><code>from openlibx402_core.testing import TestServer\n\nserver = TestServer(\n    payment_address=\"test_address\",\n    token_mint=\"test_usdc\"\n)\nserver.start(port=8402)\n\n# Test against mock server\n# ...\n</code></pre>"},{"location":"#contributing","title":"Contributing","text":"<p>We welcome contributions! Here's how you can help:</p> <ol> <li>\ud83d\udc1b Report bugs via GitHub Issues</li> <li>\ud83d\udca1 Suggest features or improvements</li> <li>\ud83d\udcdd Improve documentation</li> <li>\ud83d\udd27 Submit pull requests</li> <li>\u2b50 Star the repository</li> </ol>"},{"location":"#development-setup","title":"Development Setup","text":"<pre><code># Clone repository\ngit clone https://github.com/openlibx402/openlibx402.git\ncd openlibx402\n\n# Install development dependencies\npip install -e \"packages/python/openlibx402-core[dev]\"\n\n# Run tests\npytest\n\n# Format code\nblack packages/python/\n</code></pre>"},{"location":"#roadmap","title":"Roadmap","text":""},{"location":"#q4-2025","title":"Q4 2025","text":"<ul> <li>\u2705 Technical specification</li> <li>\u2705 Core libraries (Python &amp; TypeScript)</li> <li>\u2705 FastAPI integration</li> <li>\u2705 LangChain/LangGraph integrations</li> <li>\u2705 Express.js, Next.js integrations</li> <li>\u2705 Documentation site</li> <li>\ud83d\udd32 Additional framework support</li> <li>\ud83d\udd32 CLI tools</li> </ul>"},{"location":"#2026","title":"2026","text":"<ul> <li>\ud83d\udd32 Multi-chain support (Ethereum, Base)</li> <li>\ud83d\udd32 Admin dashboard</li> <li>\ud83d\udd32 Analytics &amp; monitoring</li> <li>\ud83d\udd32 Production deployments</li> <li>\ud83d\udd32 Browser extension</li> <li>\ud83d\udd32 Wallet UI components</li> <li>\ud83d\udd32 Zapier/Make.com integrations</li> <li>\ud83d\udd32 Enterprise features</li> </ul>"},{"location":"#faq","title":"FAQ","text":"<p>Q: Why Solana first? A: Solana offers ~200ms transaction finality and &lt;$0.0001 fees, making it ideal for micropayments.</p> <p>Q: Will this support other blockchains? A: Yes! The architecture is designed to be chain-agnostic. Ethereum and Base L2 support is planned.</p> <p>Q: Do I need crypto knowledge to use this? A: Minimal. The libraries handle blockchain complexity. You just need a wallet and some tokens.</p> <p>Q: Is this production-ready? A: Not yet. We're currently in development. Follow progress on GitHub.</p> <p>Q: How much do transactions cost? A: On Solana devnet/mainnet, transaction fees are &lt;$0.0001. Payment amounts are configurable.</p> <p>Q: Can agents really operate autonomously? A: Yes! Once configured with a wallet, agents can discover, pay for, and use APIs without human intervention.</p>"},{"location":"#resources","title":"Resources","text":"<ul> <li>\ud83d\udcc4 X402 Whitepaper</li> <li>\ud83c\udf10 X402 Protocol Website</li> <li>\ud83d\udcda Solana Documentation</li> <li>\ud83d\udd17 SPL Token Program</li> <li>\ud83e\udd9c LangChain Docs</li> <li>\ud83d\udd78\ufe0f LangGraph Docs</li> </ul>"},{"location":"#community","title":"Community","text":"<ul> <li>\ud83d\udcac Discord - Coming soon</li> <li>\ud83d\udc26 Twitter - @openlibx402</li> <li>\ud83d\udce7 Email - x402@openlib.xyz</li> </ul>"},{"location":"#license","title":"License","text":"<p>OpenLibx402 is released under the MIT License.</p>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<ul> <li>Built on the X402 protocol by Coinbase</li> <li>Powered by Solana blockchain</li> <li>Integrates with LangChain and LangGraph</li> </ul> <p>Built with \u2764\ufe0f for the autonomous AI economy</p> <p>Documentation | Examples | Contribute</p>"},{"location":"openlibx402-technical-spec/","title":"OpenLibx402 Technical Specification","text":""},{"location":"openlibx402-technical-spec/#project-overview","title":"Project Overview","text":"<p>OpenLibx402 is a library ecosystem that implements the X402 protocol for enabling autonomous, frictionless payments in AI agents and web APIs. The protocol leverages HTTP 402 \"Payment Required\" status code and Solana blockchain for instant, low-cost transactions.</p>"},{"location":"openlibx402-technical-spec/#core-principles","title":"Core Principles","text":"<ol> <li>Machine-Native Payments: Enable AI agents to autonomously pay for API access without human intervention</li> <li>Pay-Per-Use: Support micropayments with near-zero transaction costs</li> <li>Developer-Friendly: Simple integration with one-line middleware</li> <li>Blockchain-Agnostic Design: Start with Solana, architect for future chain support</li> <li>Dual API Approach: Support both explicit and implicit payment handling</li> </ol>"},{"location":"openlibx402-technical-spec/#project-structure","title":"Project Structure","text":"<pre><code>openlibx402/\n\u251c\u2500\u2500 packages/\n\u2502   \u251c\u2500\u2500 core/                      # Core protocol implementation\n\u2502   \u2502   \u251c\u2500\u2500 python/\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 openlibx402-core/\n\u2502   \u2502   \u2514\u2500\u2500 typescript/\n\u2502   \u2502       \u2514\u2500\u2500 @openlibx402/core\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 server/                    # Server-side libraries\n\u2502   \u2502   \u251c\u2500\u2500 python/\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 openlibx402-fastapi/\n\u2502   \u2502   \u2514\u2500\u2500 typescript/\n\u2502   \u2502       \u251c\u2500\u2500 @openlibx402/express\n\u2502   \u2502       \u251c\u2500\u2500 @openlibx402/nextjs\n\u2502   \u2502       \u2514\u2500\u2500 @openlibx402/hono\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 client/                    # Client-side libraries\n\u2502   \u2502   \u251c\u2500\u2500 python/\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 openlibx402-client/\n\u2502   \u2502   \u2514\u2500\u2500 typescript/\n\u2502   \u2502       \u2514\u2500\u2500 @openlibx402/client\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500 integrations/              # Framework integrations\n\u2502       \u251c\u2500\u2500 python/\n\u2502       \u2502   \u251c\u2500\u2500 openlibx402-langchain/\n\u2502       \u2502   \u2514\u2500\u2500 openlibx402-langgraph/\n\u2502       \u2514\u2500\u2500 typescript/\n\u2502           \u251c\u2500\u2500 @openlibx402/langchain\n\u2502           \u2514\u2500\u2500 @openlibx402/langgraph\n\u2502\n\u251c\u2500\u2500 examples/                      # Example implementations\n\u2502   \u251c\u2500\u2500 fastapi-server/\n\u2502   \u251c\u2500\u2500 langchain-agent/\n\u2502   \u251c\u2500\u2500 langgraph-workflow/\n\u2502   \u2514\u2500\u2500 fullstack-demo/\n\u2502\n\u2514\u2500\u2500 docs/\n    \u251c\u2500\u2500 getting-started.md\n    \u251c\u2500\u2500 api-reference.md\n    \u2514\u2500\u2500 integration-guides/\n</code></pre>"},{"location":"openlibx402-technical-spec/#1-core-protocol-implementation","title":"1. Core Protocol Implementation","text":""},{"location":"openlibx402-technical-spec/#package-openlibx402-core-python-openlibx402core-typescript","title":"Package: <code>openlibx402-core</code> (Python) / <code>@openlibx402/core</code> (TypeScript)","text":""},{"location":"openlibx402-technical-spec/#purpose","title":"Purpose","text":"<p>Core protocol logic for X402 payment flow, independent of any framework.</p>"},{"location":"openlibx402-technical-spec/#key-components","title":"Key Components","text":""},{"location":"openlibx402-technical-spec/#11-payment-request-structure","title":"1.1 Payment Request Structure","text":"<pre><code># Python\nfrom dataclasses import dataclass\nfrom typing import Optional\nfrom datetime import datetime\n\n@dataclass\nclass PaymentRequest:\n    \"\"\"Represents an X402 payment request (402 response)\"\"\"\n    max_amount_required: str           # Amount in token units (e.g., \"0.10\")\n    asset_type: str                    # \"SPL\" for Solana tokens\n    asset_address: str                 # Token mint address\n    payment_address: str               # Recipient's wallet address\n    network: str                       # \"solana-devnet\" | \"solana-mainnet\"\n    expires_at: datetime               # Expiration timestamp\n    nonce: str                         # Unique identifier for replay protection\n    payment_id: str                    # Unique payment request ID\n    resource: str                      # API endpoint being accessed\n    description: Optional[str] = None  # Human-readable description\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Convert to JSON-serializable dict\"\"\"\n        pass\n\n    @classmethod\n    def from_dict(cls, data: dict) -&gt; 'PaymentRequest':\n        \"\"\"Parse from 402 response JSON\"\"\"\n        pass\n\n    def is_expired(self) -&gt; bool:\n        \"\"\"Check if payment request has expired\"\"\"\n        pass\n</code></pre> <pre><code>// TypeScript\nexport interface PaymentRequest {\n  maxAmountRequired: string;\n  assetType: string;\n  assetAddress: string;\n  paymentAddress: string;\n  network: string;\n  expiresAt: Date;\n  nonce: string;\n  paymentId: string;\n  resource: string;\n  description?: string;\n}\n\nexport class PaymentRequestParser {\n  static parse(response: Response): PaymentRequest;\n  static isExpired(request: PaymentRequest): boolean;\n  static toJSON(request: PaymentRequest): string;\n}\n</code></pre>"},{"location":"openlibx402-technical-spec/#12-payment-authorization","title":"1.2 Payment Authorization","text":"<pre><code>@dataclass\nclass PaymentAuthorization:\n    \"\"\"Signed payment authorization to be sent with retry request\"\"\"\n    payment_id: str                    # From payment request\n    actual_amount: str                 # Amount being paid (\u2264 max_amount_required)\n    payment_address: str               # Recipient address\n    asset_address: str                 # Token mint address\n    network: str                       # Blockchain network\n    timestamp: datetime                # Authorization timestamp\n    signature: str                     # Solana signature\n    public_key: str                    # Payer's public key\n    transaction_hash: Optional[str]    # On-chain tx hash (after broadcast)\n\n    def to_header_value(self) -&gt; str:\n        \"\"\"Encode as X-Payment-Authorization header value\"\"\"\n        pass\n\n    @classmethod\n    def from_header(cls, header_value: str) -&gt; 'PaymentAuthorization':\n        \"\"\"Parse from request header\"\"\"\n        pass\n</code></pre> <pre><code>export interface PaymentAuthorization {\n  paymentId: string;\n  actualAmount: string;\n  paymentAddress: string;\n  assetAddress: string;\n  network: string;\n  timestamp: Date;\n  signature: string;\n  publicKey: string;\n  transactionHash?: string;\n}\n\nexport class PaymentAuthorizationHandler {\n  static toHeader(auth: PaymentAuthorization): string;\n  static fromHeader(headerValue: string): PaymentAuthorization;\n  static verify(auth: PaymentAuthorization, request: PaymentRequest): boolean;\n}\n</code></pre>"},{"location":"openlibx402-technical-spec/#13-solana-integration","title":"1.3 Solana Integration","text":"<pre><code>from solana.rpc.async_api import AsyncClient\nfrom solana.transaction import Transaction\nfrom solders.keypair import Keypair\nfrom solders.pubkey import Pubkey\nfrom spl.token.instructions import transfer_checked, TransferCheckedParams\n\nclass SolanaPaymentProcessor:\n    \"\"\"Handles Solana blockchain operations\"\"\"\n\n    def __init__(self, rpc_url: str, keypair: Optional[Keypair] = None):\n        self.client = AsyncClient(rpc_url)\n        self.keypair = keypair\n\n    async def create_payment_transaction(\n        self,\n        request: PaymentRequest,\n        amount: str,\n        payer_keypair: Keypair\n    ) -&gt; Transaction:\n        \"\"\"Create a Solana transaction for the payment\"\"\"\n        pass\n\n    async def sign_and_send_transaction(\n        self,\n        transaction: Transaction,\n        keypair: Keypair\n    ) -&gt; str:\n        \"\"\"Sign and broadcast transaction, return tx hash\"\"\"\n        pass\n\n    async def verify_transaction(\n        self,\n        transaction_hash: str,\n        expected_recipient: str,\n        expected_amount: str,\n        expected_token_mint: str\n    ) -&gt; bool:\n        \"\"\"Verify a transaction was successful and matches expectations\"\"\"\n        pass\n\n    async def get_token_balance(\n        self,\n        wallet_address: str,\n        token_mint: str\n    ) -&gt; float:\n        \"\"\"Get token balance for a wallet\"\"\"\n        pass\n</code></pre> <pre><code>import { Connection, Keypair, PublicKey, Transaction } from '@solana/web3.js';\nimport { getAssociatedTokenAddress, createTransferCheckedInstruction } from '@solana/spl-token';\n\nexport class SolanaPaymentProcessor {\n  private connection: Connection;\n  private keypair?: Keypair;\n\n  constructor(rpcUrl: string, keypair?: Keypair);\n\n  async createPaymentTransaction(\n    request: PaymentRequest,\n    amount: string,\n    payerKeypair: Keypair\n  ): Promise&lt;Transaction&gt;;\n\n  async signAndSendTransaction(\n    transaction: Transaction,\n    keypair: Keypair\n  ): Promise&lt;string&gt;;\n\n  async verifyTransaction(\n    transactionHash: string,\n    expectedRecipient: string,\n    expectedAmount: string,\n    expectedTokenMint: string\n  ): Promise&lt;boolean&gt;;\n\n  async getTokenBalance(\n    walletAddress: string,\n    tokenMint: string\n  ): Promise&lt;number&gt;;\n}\n</code></pre>"},{"location":"openlibx402-technical-spec/#14-error-handling","title":"1.4 Error Handling","text":"<pre><code>class X402Error(Exception):\n    \"\"\"Base exception for X402 protocol errors\"\"\"\n    code: str\n    message: str\n    details: Optional[dict]\n\nclass PaymentRequiredError(X402Error):\n    \"\"\"Raised when 402 response received\"\"\"\n    code = \"PAYMENT_REQUIRED\"\n    payment_request: PaymentRequest\n\nclass PaymentExpiredError(X402Error):\n    \"\"\"Payment request has expired\"\"\"\n    code = \"PAYMENT_EXPIRED\"\n\nclass InsufficientFundsError(X402Error):\n    \"\"\"Wallet has insufficient funds\"\"\"\n    code = \"INSUFFICIENT_FUNDS\"\n    required_amount: str\n    available_amount: str\n\nclass PaymentVerificationError(X402Error):\n    \"\"\"Payment verification failed\"\"\"\n    code = \"PAYMENT_VERIFICATION_FAILED\"\n\nclass TransactionBroadcastError(X402Error):\n    \"\"\"Failed to broadcast transaction\"\"\"\n    code = \"TRANSACTION_BROADCAST_FAILED\"\n\nclass InvalidPaymentRequestError(X402Error):\n    \"\"\"Payment request format is invalid\"\"\"\n    code = \"INVALID_PAYMENT_REQUEST\"\n</code></pre> <pre><code>export class X402Error extends Error {\n  code: string;\n  details?: Record&lt;string, any&gt;;\n  constructor(message: string, code: string, details?: Record&lt;string, any&gt;);\n}\n\nexport class PaymentRequiredError extends X402Error {\n  paymentRequest: PaymentRequest;\n  constructor(paymentRequest: PaymentRequest);\n}\n\nexport class PaymentExpiredError extends X402Error {\n  constructor(paymentRequest: PaymentRequest);\n}\n\nexport class InsufficientFundsError extends X402Error {\n  requiredAmount: string;\n  availableAmount: string;\n  constructor(required: string, available: string);\n}\n\nexport class PaymentVerificationError extends X402Error {\n  constructor(reason: string);\n}\n\nexport class TransactionBroadcastError extends X402Error {\n  constructor(reason: string);\n}\n\nexport class InvalidPaymentRequestError extends X402Error {\n  constructor(reason: string);\n}\n</code></pre>"},{"location":"openlibx402-technical-spec/#2-server-side-implementation","title":"2. Server-Side Implementation","text":""},{"location":"openlibx402-technical-spec/#package-openlibx402-fastapi-python","title":"Package: <code>openlibx402-fastapi</code> (Python)","text":""},{"location":"openlibx402-technical-spec/#purpose_1","title":"Purpose","text":"<p>FastAPI middleware for accepting X402 payments on API endpoints.</p>"},{"location":"openlibx402-technical-spec/#key-components_1","title":"Key Components","text":""},{"location":"openlibx402-technical-spec/#21-middleware","title":"2.1 Middleware","text":"<pre><code>from fastapi import Request, Response\nfrom typing import Callable, Optional\nfrom datetime import datetime, timedelta\nimport secrets\n\nclass X402PaymentMiddleware:\n    \"\"\"FastAPI middleware for X402 payment handling\"\"\"\n\n    def __init__(\n        self,\n        payment_address: str,           # Recipient wallet address\n        token_mint: str,                # SPL token mint address (USDC)\n        network: str = \"solana-devnet\", # Network identifier\n        rpc_url: str = None,            # Solana RPC endpoint\n        payment_timeout: int = 300,     # Payment validity in seconds\n        auto_verify: bool = True,       # Auto-verify payments\n    ):\n        self.payment_address = payment_address\n        self.token_mint = token_mint\n        self.network = network\n        self.rpc_url = rpc_url or self._default_rpc_url(network)\n        self.payment_timeout = payment_timeout\n        self.auto_verify = auto_verify\n        self.processor = SolanaPaymentProcessor(self.rpc_url)\n\n    async def __call__(\n        self,\n        request: Request,\n        call_next: Callable,\n    ) -&gt; Response:\n        \"\"\"Process request, check for payment, return 402 if needed\"\"\"\n        pass\n\ndef payment_required(\n    amount: str,\n    payment_address: str,\n    token_mint: str,\n    network: str = \"solana-devnet\",\n    description: Optional[str] = None,\n    expires_in: int = 300,\n):\n    \"\"\"\n    Decorator for FastAPI endpoints requiring payment\n\n    Usage:\n        @app.get(\"/premium-data\")\n        @payment_required(\n            amount=\"0.10\",\n            payment_address=\"FPxxx...\",\n            token_mint=\"USDC_MINT_ADDRESS\"\n        )\n        async def get_premium_data():\n            return {\"data\": \"Premium content\"}\n    \"\"\"\n    def decorator(func):\n        async def wrapper(*args, **kwargs):\n            # Check for payment authorization header\n            # If missing, return 402 response\n            # If present, verify payment\n            # If valid, call original function\n            pass\n        return wrapper\n    return decorator\n</code></pre>"},{"location":"openlibx402-technical-spec/#22-dependency-injection-pattern","title":"2.2 Dependency Injection Pattern","text":"<pre><code>from fastapi import Depends, HTTPException\n\nasync def verify_payment(\n    request: Request,\n    required_amount: str,\n    payment_address: str,\n    token_mint: str,\n) -&gt; PaymentAuthorization:\n    \"\"\"\n    FastAPI dependency for payment verification\n\n    Usage:\n        @app.get(\"/premium-data\")\n        async def get_premium_data(\n            payment: PaymentAuthorization = Depends(\n                verify_payment_factory(\"0.10\", WALLET, TOKEN)\n            )\n        ):\n            return {\"data\": \"Premium content\"}\n    \"\"\"\n    pass\n\ndef verify_payment_factory(\n    amount: str,\n    payment_address: str,\n    token_mint: str,\n    network: str = \"solana-devnet\",\n):\n    \"\"\"Factory for creating payment verification dependency\"\"\"\n    async def _verify(request: Request) -&gt; PaymentAuthorization:\n        return await verify_payment(\n            request, amount, payment_address, token_mint\n        )\n    return _verify\n</code></pre>"},{"location":"openlibx402-technical-spec/#23-configuration","title":"2.3 Configuration","text":"<pre><code>from pydantic import BaseModel\n\nclass X402Config(BaseModel):\n    \"\"\"Global X402 configuration\"\"\"\n    payment_address: str\n    token_mint: str\n    network: str = \"solana-devnet\"\n    rpc_url: Optional[str] = None\n    default_amount: str = \"0.01\"\n    payment_timeout: int = 300\n    auto_verify: bool = True\n\n    class Config:\n        env_prefix = \"X402_\"  # Load from X402_* environment variables\n\n# Singleton configuration\n_config: Optional[X402Config] = None\n\ndef init_x402(config: X402Config):\n    \"\"\"Initialize global X402 configuration\"\"\"\n    global _config\n    _config = config\n\ndef get_config() -&gt; X402Config:\n    \"\"\"Get global X402 configuration\"\"\"\n    if _config is None:\n        raise RuntimeError(\"X402 not initialized. Call init_x402() first.\")\n    return _config\n</code></pre>"},{"location":"openlibx402-technical-spec/#24-response-builder","title":"2.4 Response Builder","text":"<pre><code>from fastapi.responses import JSONResponse\n\ndef build_402_response(\n    amount: str,\n    payment_address: str,\n    token_mint: str,\n    network: str,\n    resource: str,\n    description: Optional[str] = None,\n    expires_in: int = 300,\n) -&gt; JSONResponse:\n    \"\"\"Build a properly formatted 402 Payment Required response\"\"\"\n\n    payment_request = PaymentRequest(\n        max_amount_required=amount,\n        asset_type=\"SPL\",\n        asset_address=token_mint,\n        payment_address=payment_address,\n        network=network,\n        expires_at=datetime.utcnow() + timedelta(seconds=expires_in),\n        nonce=secrets.token_urlsafe(32),\n        payment_id=secrets.token_urlsafe(16),\n        resource=resource,\n        description=description,\n    )\n\n    return JSONResponse(\n        status_code=402,\n        content=payment_request.to_dict(),\n        headers={\n            \"X-Payment-Required\": \"true\",\n            \"X-Payment-Protocol\": \"x402\",\n        }\n    )\n</code></pre>"},{"location":"openlibx402-technical-spec/#3-client-side-implementation","title":"3. Client-Side Implementation","text":""},{"location":"openlibx402-technical-spec/#package-openlibx402-client-python-openlibx402client-typescript","title":"Package: <code>openlibx402-client</code> (Python) / <code>@openlibx402/client</code> (TypeScript)","text":""},{"location":"openlibx402-technical-spec/#purpose_2","title":"Purpose","text":"<p>Client libraries for making X402-enabled API calls with automatic payment handling.</p>"},{"location":"openlibx402-technical-spec/#key-components_2","title":"Key Components","text":""},{"location":"openlibx402-technical-spec/#31-explicit-client-manual-payment-control","title":"3.1 Explicit Client (Manual Payment Control)","text":"<pre><code>from typing import Optional, Dict, Any\nimport httpx\n\nclass X402Client:\n    \"\"\"\n    Explicit X402 client - developer controls payment flow\n\n    Usage:\n        client = X402Client(wallet_keypair)\n\n        # Check if payment required\n        response = await client.get(\"https://api.example.com/data\")\n\n        if client.payment_required(response):\n            payment_request = client.parse_payment_request(response)\n\n            # Make payment\n            authorization = await client.create_payment(payment_request)\n\n            # Retry with payment\n            response = await client.get(\n                \"https://api.example.com/data\",\n                payment=authorization\n            )\n    \"\"\"\n\n    def __init__(\n        self,\n        wallet_keypair: Keypair,\n        rpc_url: Optional[str] = None,\n        http_client: Optional[httpx.AsyncClient] = None,\n    ):\n        self.wallet_keypair = wallet_keypair\n        self.http_client = http_client or httpx.AsyncClient()\n        self.processor = SolanaPaymentProcessor(\n            rpc_url or \"https://api.devnet.solana.com\"\n        )\n\n    async def get(\n        self,\n        url: str,\n        payment: Optional[PaymentAuthorization] = None,\n        **kwargs\n    ) -&gt; httpx.Response:\n        \"\"\"Make GET request with optional payment\"\"\"\n        headers = kwargs.get(\"headers\", {})\n        if payment:\n            headers[\"X-Payment-Authorization\"] = payment.to_header_value()\n        kwargs[\"headers\"] = headers\n        return await self.http_client.get(url, **kwargs)\n\n    async def post(\n        self,\n        url: str,\n        payment: Optional[PaymentAuthorization] = None,\n        **kwargs\n    ) -&gt; httpx.Response:\n        \"\"\"Make POST request with optional payment\"\"\"\n        pass\n\n    def payment_required(self, response: httpx.Response) -&gt; bool:\n        \"\"\"Check if response requires payment\"\"\"\n        return response.status_code == 402\n\n    def parse_payment_request(\n        self,\n        response: httpx.Response\n    ) -&gt; PaymentRequest:\n        \"\"\"Parse payment request from 402 response\"\"\"\n        if not self.payment_required(response):\n            raise ValueError(\"Response does not require payment\")\n        return PaymentRequest.from_dict(response.json())\n\n    async def create_payment(\n        self,\n        request: PaymentRequest,\n        amount: Optional[str] = None,\n    ) -&gt; PaymentAuthorization:\n        \"\"\"\n        Create and broadcast payment for a payment request\n\n        Args:\n            request: Payment request from 402 response\n            amount: Optional custom amount (defaults to max_amount_required)\n\n        Returns:\n            PaymentAuthorization with transaction hash\n        \"\"\"\n        # Validate request not expired\n        if request.is_expired():\n            raise PaymentExpiredError(request)\n\n        # Use provided amount or max required\n        pay_amount = amount or request.max_amount_required\n\n        # Check sufficient balance\n        balance = await self.processor.get_token_balance(\n            str(self.wallet_keypair.pubkey()),\n            request.asset_address\n        )\n        if balance &lt; float(pay_amount):\n            raise InsufficientFundsError(pay_amount, str(balance))\n\n        # Create transaction\n        tx = await self.processor.create_payment_transaction(\n            request, pay_amount, self.wallet_keypair\n        )\n\n        # Sign and broadcast\n        tx_hash = await self.processor.sign_and_send_transaction(\n            tx, self.wallet_keypair\n        )\n\n        # Create authorization\n        return PaymentAuthorization(\n            payment_id=request.payment_id,\n            actual_amount=pay_amount,\n            payment_address=request.payment_address,\n            asset_address=request.asset_address,\n            network=request.network,\n            timestamp=datetime.utcnow(),\n            signature=\"\",  # Solana signature\n            public_key=str(self.wallet_keypair.pubkey()),\n            transaction_hash=tx_hash,\n        )\n</code></pre>"},{"location":"openlibx402-technical-spec/#32-implicit-client-automatic-payment","title":"3.2 Implicit Client (Automatic Payment)","text":"<pre><code>class X402AutoClient:\n    \"\"\"\n    Implicit X402 client - automatically handles payment flow\n\n    Usage:\n        client = X402AutoClient(wallet_keypair)\n\n        # Automatically detects 402 and pays\n        response = await client.fetch(\"https://api.example.com/data\")\n        data = response.json()\n    \"\"\"\n\n    def __init__(\n        self,\n        wallet_keypair: Keypair,\n        rpc_url: Optional[str] = None,\n        max_retries: int = 1,\n        auto_retry: bool = True,\n        max_payment_amount: Optional[str] = None,  # Safety limit\n    ):\n        self.client = X402Client(wallet_keypair, rpc_url)\n        self.max_retries = max_retries\n        self.auto_retry = auto_retry\n        self.max_payment_amount = max_payment_amount\n\n    async def fetch(\n        self,\n        url: str,\n        method: str = \"GET\",\n        auto_retry: Optional[bool] = None,\n        **kwargs\n    ) -&gt; httpx.Response:\n        \"\"\"\n        Make HTTP request with automatic payment handling\n\n        Args:\n            url: Request URL\n            method: HTTP method\n            auto_retry: Override instance auto_retry setting\n            **kwargs: Additional arguments for httpx request\n\n        Returns:\n            Response after payment (if required)\n\n        Raises:\n            PaymentRequiredError: If auto_retry is False and 402 received\n            InsufficientFundsError: If wallet lacks funds\n            PaymentExpiredError: If payment request expired\n        \"\"\"\n        should_retry = auto_retry if auto_retry is not None else self.auto_retry\n\n        # Initial request\n        response = await self._make_request(method, url, **kwargs)\n\n        # Check if payment required\n        if self.client.payment_required(response):\n            if not should_retry:\n                raise PaymentRequiredError(\n                    self.client.parse_payment_request(response)\n                )\n\n            # Parse payment request\n            payment_request = self.client.parse_payment_request(response)\n\n            # Safety check\n            if self.max_payment_amount:\n                if float(payment_request.max_amount_required) &gt; float(self.max_payment_amount):\n                    raise ValueError(\n                        f\"Payment amount {payment_request.max_amount_required} \"\n                        f\"exceeds max allowed {self.max_payment_amount}\"\n                    )\n\n            # Create payment\n            authorization = await self.client.create_payment(payment_request)\n\n            # Retry with payment\n            response = await self._make_request(\n                method, url, payment=authorization, **kwargs\n            )\n\n        return response\n\n    async def _make_request(\n        self,\n        method: str,\n        url: str,\n        payment: Optional[PaymentAuthorization] = None,\n        **kwargs\n    ) -&gt; httpx.Response:\n        \"\"\"Internal method to make HTTP request\"\"\"\n        if method.upper() == \"GET\":\n            return await self.client.get(url, payment=payment, **kwargs)\n        elif method.upper() == \"POST\":\n            return await self.client.post(url, payment=payment, **kwargs)\n        # ... other methods\n\n    async def get(self, url: str, **kwargs) -&gt; httpx.Response:\n        \"\"\"GET request with auto-payment\"\"\"\n        return await self.fetch(url, method=\"GET\", **kwargs)\n\n    async def post(self, url: str, **kwargs) -&gt; httpx.Response:\n        \"\"\"POST request with auto-payment\"\"\"\n        return await self.fetch(url, method=\"POST\", **kwargs)\n</code></pre> <pre><code>// TypeScript versions with similar structure\n\nexport class X402Client {\n  // Explicit client implementation\n}\n\nexport class X402AutoClient {\n  // Implicit auto-payment client implementation\n}\n</code></pre>"},{"location":"openlibx402-technical-spec/#4-langchain-integration","title":"4. LangChain Integration","text":""},{"location":"openlibx402-technical-spec/#package-openlibx402-langchain-python-openlibx402langchain-typescript","title":"Package: <code>openlibx402-langchain</code> (Python) / <code>@openlibx402/langchain</code> (TypeScript)","text":""},{"location":"openlibx402-technical-spec/#purpose_3","title":"Purpose","text":"<p>Integrate X402 payments into LangChain agents via Tools and HTTP request middleware.</p>"},{"location":"openlibx402-technical-spec/#key-components_3","title":"Key Components","text":""},{"location":"openlibx402-technical-spec/#41-x402-tool-for-agents","title":"4.1 X402 Tool (For Agents)","text":"<pre><code>from langchain.tools import BaseTool\nfrom pydantic import Field\nfrom typing import Optional\n\nclass X402PaymentTool(BaseTool):\n    \"\"\"\n    LangChain tool that allows agents to make payments for API access\n\n    Usage:\n        wallet_keypair = load_keypair()\n\n        payment_tool = X402PaymentTool(\n            wallet_keypair=wallet_keypair,\n            name=\"pay_for_api\",\n            description=\"Make payment to access premium API data\"\n        )\n\n        agent = initialize_agent(\n            tools=[payment_tool, ...],\n            llm=llm,\n        )\n    \"\"\"\n\n    name: str = \"x402_payment\"\n    description: str = (\n        \"Make an X402 payment to access a paid API endpoint. \"\n        \"Input should be a JSON string with 'url' and optional 'amount'. \"\n        \"Returns the API response after successful payment.\"\n    )\n\n    wallet_keypair: Keypair = Field(exclude=True)\n    rpc_url: Optional[str] = Field(default=None, exclude=True)\n    max_payment: Optional[str] = Field(default=\"1.0\", exclude=True)\n\n    def _run(\n        self,\n        url: str,\n        amount: Optional[str] = None,\n        method: str = \"GET\",\n        **kwargs\n    ) -&gt; str:\n        \"\"\"Synchronous run (calls async version)\"\"\"\n        import asyncio\n        return asyncio.run(self._arun(url, amount, method, **kwargs))\n\n    async def _arun(\n        self,\n        url: str,\n        amount: Optional[str] = None,\n        method: str = \"GET\",\n        **kwargs\n    ) -&gt; str:\n        \"\"\"\n        Make paid API request\n\n        Args:\n            url: API endpoint URL\n            amount: Optional payment amount override\n            method: HTTP method\n            **kwargs: Additional request parameters\n\n        Returns:\n            API response as string\n        \"\"\"\n        client = X402AutoClient(\n            wallet_keypair=self.wallet_keypair,\n            rpc_url=self.rpc_url,\n            max_payment_amount=self.max_payment,\n        )\n\n        try:\n            response = await client.fetch(url, method=method, **kwargs)\n            return response.text\n        except X402Error as e:\n            return f\"Payment error: {e.code} - {e.message}\"\n</code></pre>"},{"location":"openlibx402-technical-spec/#42-request-middleware-intercept-all-api-calls","title":"4.2 Request Middleware (Intercept All API Calls)","text":"<pre><code>from langchain.requests import RequestsWrapper\nfrom typing import Dict, Any, Optional\n\nclass X402RequestsWrapper(RequestsWrapper):\n    \"\"\"\n    Drop-in replacement for LangChain's RequestsWrapper with X402 support\n\n    Usage:\n        from langchain.agents import load_tools\n\n        wallet_keypair = load_keypair()\n\n        requests_wrapper = X402RequestsWrapper(\n            wallet_keypair=wallet_keypair\n        )\n\n        # Use with LangChain tools that make HTTP requests\n        tools = load_tools(\n            [\"requests_all\"],\n            llm=llm,\n            requests_wrapper=requests_wrapper\n        )\n    \"\"\"\n\n    def __init__(\n        self,\n        wallet_keypair: Keypair,\n        rpc_url: Optional[str] = None,\n        max_payment: Optional[str] = \"1.0\",\n        **kwargs\n    ):\n        super().__init__(**kwargs)\n        self.client = X402AutoClient(\n            wallet_keypair=wallet_keypair,\n            rpc_url=rpc_url,\n            max_payment_amount=max_payment,\n        )\n\n    async def aget(self, url: str, **kwargs) -&gt; str:\n        \"\"\"Async GET with X402 support\"\"\"\n        response = await self.client.get(url, **kwargs)\n        return response.text\n\n    async def apost(self, url: str, **kwargs) -&gt; str:\n        \"\"\"Async POST with X402 support\"\"\"\n        response = await self.client.post(url, **kwargs)\n        return response.text\n\n    def get(self, url: str, **kwargs) -&gt; str:\n        \"\"\"Sync GET with X402 support\"\"\"\n        import asyncio\n        return asyncio.run(self.aget(url, **kwargs))\n\n    def post(self, url: str, **kwargs) -&gt; str:\n        \"\"\"Sync POST with X402 support\"\"\"\n        import asyncio\n        return asyncio.run(self.apost(url, **kwargs))\n</code></pre>"},{"location":"openlibx402-technical-spec/#43-integration-utilities","title":"4.3 Integration Utilities","text":"<pre><code>from langchain.chat_models import ChatOpenAI\nfrom langchain.agents import initialize_agent, AgentType\n\ndef create_x402_agent(\n    wallet_keypair: Keypair,\n    llm: Optional[Any] = None,\n    tools: Optional[list] = None,\n    rpc_url: Optional[str] = None,\n    max_payment: str = \"1.0\",\n    **agent_kwargs\n):\n    \"\"\"\n    Convenience function to create LangChain agent with X402 support\n\n    Usage:\n        agent = create_x402_agent(\n            wallet_keypair=my_keypair,\n            llm=ChatOpenAI(),\n            tools=[custom_tool_1, custom_tool_2],\n            max_payment=\"5.0\"\n        )\n\n        response = agent.run(\"Get me premium market data from api.example.com\")\n    \"\"\"\n    from langchain.agents import load_tools\n\n    # Create X402-enabled requests wrapper\n    requests_wrapper = X402RequestsWrapper(\n        wallet_keypair=wallet_keypair,\n        rpc_url=rpc_url,\n        max_payment=max_payment,\n    )\n\n    # Load standard tools with X402 wrapper\n    x402_tools = load_tools(\n        [\"requests_all\"],\n        llm=llm,\n        requests_wrapper=requests_wrapper\n    )\n\n    # Add custom tools\n    if tools:\n        x402_tools.extend(tools)\n\n    # Create agent\n    agent = initialize_agent(\n        tools=x402_tools,\n        llm=llm or ChatOpenAI(),\n        agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION,\n        **agent_kwargs\n    )\n\n    return agent\n</code></pre>"},{"location":"openlibx402-technical-spec/#5-langgraph-integration","title":"5. LangGraph Integration","text":""},{"location":"openlibx402-technical-spec/#package-openlibx402-langgraph-python-openlibx402langgraph-typescript","title":"Package: <code>openlibx402-langgraph</code> (Python) / <code>@openlibx402/langgraph</code> (TypeScript)","text":""},{"location":"openlibx402-technical-spec/#purpose_4","title":"Purpose","text":"<p>Integrate X402 payments into LangGraph workflows as nodes and conditional edges.</p>"},{"location":"openlibx402-technical-spec/#recommended-patterns","title":"Recommended Patterns","text":""},{"location":"openlibx402-technical-spec/#51-payment-node","title":"5.1 Payment Node","text":"<pre><code>from typing import TypedDict, Annotated\nfrom langgraph.graph import StateGraph, END\nfrom solders.keypair import Keypair\n\nclass AgentState(TypedDict):\n    \"\"\"State for LangGraph agent with payment support\"\"\"\n    messages: list\n    api_url: str\n    api_response: str\n    payment_required: bool\n    payment_completed: bool\n    payment_error: Optional[str]\n    wallet_keypair: Keypair\n\ndef payment_node(state: AgentState) -&gt; AgentState:\n    \"\"\"\n    LangGraph node that handles X402 payment\n\n    Usage in graph:\n        workflow = StateGraph(AgentState)\n        workflow.add_node(\"fetch_api\", fetch_api_node)\n        workflow.add_node(\"make_payment\", payment_node)\n        workflow.add_node(\"process_response\", process_response_node)\n\n        workflow.add_conditional_edges(\n            \"fetch_api\",\n            check_payment_required,\n            {\n                \"payment_required\": \"make_payment\",\n                \"success\": \"process_response\"\n            }\n        )\n    \"\"\"\n    client = X402AutoClient(\n        wallet_keypair=state[\"wallet_keypair\"],\n        auto_retry=True,\n    )\n\n    try:\n        response = asyncio.run(\n            client.fetch(state[\"api_url\"])\n        )\n        state[\"api_response\"] = response.text\n        state[\"payment_completed\"] = True\n        state[\"payment_error\"] = None\n    except X402Error as e:\n        state[\"payment_error\"] = f\"{e.code}: {e.message}\"\n        state[\"payment_completed\"] = False\n\n    return state\n\ndef check_payment_required(state: AgentState) -&gt; str:\n    \"\"\"Conditional edge function\"\"\"\n    if state.get(\"payment_required\"):\n        return \"payment_required\"\n    elif state.get(\"api_response\"):\n        return \"success\"\n    else:\n        return \"error\"\n</code></pre>"},{"location":"openlibx402-technical-spec/#52-payment-aware-api-node","title":"5.2 Payment-Aware API Node","text":"<pre><code>async def fetch_with_payment_node(state: AgentState) -&gt; AgentState:\n    \"\"\"\n    Combined node that fetches API and handles payment automatically\n\n    This is simpler than separate nodes but gives less control\n    \"\"\"\n    client = X402AutoClient(\n        wallet_keypair=state[\"wallet_keypair\"],\n        max_payment_amount=\"1.0\",\n    )\n\n    try:\n        response = await client.fetch(\n            state[\"api_url\"],\n            method=\"GET\"\n        )\n        state[\"api_response\"] = response.text\n        state[\"payment_completed\"] = True\n    except InsufficientFundsError as e:\n        state[\"payment_error\"] = f\"Insufficient funds: need {e.required_amount}\"\n    except X402Error as e:\n        state[\"payment_error\"] = f\"{e.code}: {e.message}\"\n\n    return state\n</code></pre>"},{"location":"openlibx402-technical-spec/#53-example-workflow","title":"5.3 Example Workflow","text":"<pre><code>from langgraph.graph import StateGraph, END\n\ndef create_x402_workflow(wallet_keypair: Keypair) -&gt; StateGraph:\n    \"\"\"\n    Create a LangGraph workflow with X402 payment support\n\n    Workflow:\n        1. Determine what API to call\n        2. Check if payment required\n        3. Make payment if needed\n        4. Process response\n    \"\"\"\n\n    workflow = StateGraph(AgentState)\n\n    # Add nodes\n    workflow.add_node(\"plan\", planning_node)\n    workflow.add_node(\"fetch_api\", fetch_api_node)\n    workflow.add_node(\"make_payment\", payment_node)\n    workflow.add_node(\"process\", process_response_node)\n\n    # Set entry point\n    workflow.set_entry_point(\"plan\")\n\n    # Add edges\n    workflow.add_edge(\"plan\", \"fetch_api\")\n\n    workflow.add_conditional_edges(\n        \"fetch_api\",\n        check_payment_required,\n        {\n            \"payment_required\": \"make_payment\",\n            \"success\": \"process\",\n            \"error\": END\n        }\n    )\n\n    workflow.add_edge(\"make_payment\", \"fetch_api\")  # Retry after payment\n    workflow.add_edge(\"process\", END)\n\n    return workflow.compile()\n</code></pre>"},{"location":"openlibx402-technical-spec/#54-helper-functions","title":"5.4 Helper Functions","text":"<pre><code>def create_payment_capable_graph(\n    state_schema: type,\n    wallet_keypair: Keypair,\n    rpc_url: Optional[str] = None,\n) -&gt; StateGraph:\n    \"\"\"\n    Create a StateGraph with X402 payment capabilities built-in\n\n    Automatically adds wallet_keypair to state and provides helper methods\n    \"\"\"\n    pass\n\ndef add_payment_node(\n    graph: StateGraph,\n    node_name: str = \"x402_payment\",\n    max_payment: str = \"1.0\",\n) -&gt; StateGraph:\n    \"\"\"Add a payment node to existing graph\"\"\"\n    pass\n</code></pre>"},{"location":"openlibx402-technical-spec/#6-error-handling-retry-logic","title":"6. Error Handling &amp; Retry Logic","text":""},{"location":"openlibx402-technical-spec/#automatic-retry-configuration","title":"Automatic Retry Configuration","text":"<pre><code>from dataclasses import dataclass\n\n@dataclass\nclass RetryConfig:\n    \"\"\"Configuration for automatic retry behavior\"\"\"\n    enabled: bool = True\n    max_retries: int = 1  # For payment, 1 retry is usually sufficient\n    retry_on_402: bool = True  # Retry when 402 received\n    retry_on_network_error: bool = True\n    exponential_backoff: bool = False  # Usually not needed for 402\n\nclass X402ClientWithRetry:\n    \"\"\"Client with configurable retry logic\"\"\"\n\n    def __init__(\n        self,\n        wallet_keypair: Keypair,\n        retry_config: Optional[RetryConfig] = None,\n    ):\n        self.wallet_keypair = wallet_keypair\n        self.retry_config = retry_config or RetryConfig()\n        self.client = X402AutoClient(\n            wallet_keypair=wallet_keypair,\n            auto_retry=retry_config.enabled if retry_config else True,\n        )\n</code></pre>"},{"location":"openlibx402-technical-spec/#error-code-reference","title":"Error Code Reference","text":"<pre><code>ERROR_CODES = {\n    \"PAYMENT_REQUIRED\": {\n        \"code\": \"PAYMENT_REQUIRED\",\n        \"message\": \"Payment is required to access this resource\",\n        \"retry\": True,\n        \"user_action\": \"Ensure wallet has sufficient funds and retry\"\n    },\n    \"PAYMENT_EXPIRED\": {\n        \"code\": \"PAYMENT_EXPIRED\",\n        \"message\": \"Payment request has expired\",\n        \"retry\": True,\n        \"user_action\": \"Request a new payment authorization\"\n    },\n    \"INSUFFICIENT_FUNDS\": {\n        \"code\": \"INSUFFICIENT_FUNDS\",\n        \"message\": \"Wallet has insufficient token balance\",\n        \"retry\": False,\n        \"user_action\": \"Add funds to wallet\"\n    },\n    \"PAYMENT_VERIFICATION_FAILED\": {\n        \"code\": \"PAYMENT_VERIFICATION_FAILED\",\n        \"message\": \"Server could not verify payment\",\n        \"retry\": True,\n        \"user_action\": \"Contact API provider if issue persists\"\n    },\n    \"TRANSACTION_BROADCAST_FAILED\": {\n        \"code\": \"TRANSACTION_BROADCAST_FAILED\",\n        \"message\": \"Failed to broadcast transaction to blockchain\",\n        \"retry\": True,\n        \"user_action\": \"Check network connection and RPC endpoint\"\n    },\n    \"INVALID_PAYMENT_REQUEST\": {\n        \"code\": \"INVALID_PAYMENT_REQUEST\",\n        \"message\": \"Payment request format is invalid\",\n        \"retry\": False,\n        \"user_action\": \"Contact API provider\"\n    },\n}\n</code></pre>"},{"location":"openlibx402-technical-spec/#7-testing-development","title":"7. Testing &amp; Development","text":""},{"location":"openlibx402-technical-spec/#test-utilities","title":"Test Utilities","text":"<pre><code># In openlibx402-core\n\nclass MockSolanaPaymentProcessor(SolanaPaymentProcessor):\n    \"\"\"Mock processor for testing without real blockchain\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.transactions: list = []\n        self.balance = 100.0  # Mock balance\n\n    async def create_payment_transaction(self, *args, **kwargs):\n        \"\"\"Return mock transaction\"\"\"\n        return MockTransaction()\n\n    async def sign_and_send_transaction(self, *args, **kwargs):\n        \"\"\"Return mock tx hash\"\"\"\n        tx_hash = f\"mock_tx_{len(self.transactions)}\"\n        self.transactions.append(tx_hash)\n        return tx_hash\n\n    async def verify_transaction(self, *args, **kwargs):\n        \"\"\"Always verify successfully\"\"\"\n        return True\n\n    async def get_token_balance(self, *args, **kwargs):\n        \"\"\"Return mock balance\"\"\"\n        return self.balance\n\nclass TestServer:\n    \"\"\"Mock X402 server for testing\"\"\"\n\n    def __init__(self, payment_address: str, token_mint: str):\n        self.payment_address = payment_address\n        self.token_mint = token_mint\n        self.payments_received: list = []\n\n    def require_payment(self, amount: str, resource: str):\n        \"\"\"Decorator that adds payment requirement\"\"\"\n        pass\n\n    def start(self, port: int = 8402):\n        \"\"\"Start test server\"\"\"\n        pass\n</code></pre>"},{"location":"openlibx402-technical-spec/#example-test","title":"Example Test","text":"<pre><code>import pytest\nfrom openlibx402_core.testing import MockSolanaPaymentProcessor, TestServer\n\n@pytest.mark.asyncio\nasync def test_payment_flow():\n    \"\"\"Test complete payment flow\"\"\"\n    # Setup test server\n    server = TestServer(\n        payment_address=\"mock_address\",\n        token_mint=\"mock_usdc\"\n    )\n    server.start(port=8402)\n\n    # Create client with mock processor\n    keypair = Keypair()  # Generate test keypair\n    client = X402AutoClient(wallet_keypair=keypair)\n    client.client.processor = MockSolanaPaymentProcessor()\n\n    # Make request to paywalled endpoint\n    response = await client.fetch(\"http://localhost:8402/premium-data\")\n\n    # Verify payment was made\n    assert response.status_code == 200\n    assert len(client.client.processor.transactions) == 1\n\n    # Cleanup\n    server.stop()\n</code></pre>"},{"location":"openlibx402-technical-spec/#8-example-implementations","title":"8. Example Implementations","text":""},{"location":"openlibx402-technical-spec/#81-fastapi-server-example","title":"8.1 FastAPI Server Example","text":"<pre><code># examples/fastapi-server/main.py\n\nfrom fastapi import FastAPI, Depends\nfrom openlibx402_fastapi import payment_required, X402Config, init_x402\nfrom solders.keypair import Keypair\nimport os\n\n# Initialize X402\nconfig = X402Config(\n    payment_address=os.getenv(\"PAYMENT_WALLET_ADDRESS\"),\n    token_mint=os.getenv(\"USDC_MINT_ADDRESS\"),\n    network=\"solana-devnet\",\n)\ninit_x402(config)\n\napp = FastAPI()\n\n# Simple decorator approach\n@app.get(\"/premium-data\")\n@payment_required(\n    amount=\"0.10\",\n    payment_address=config.payment_address,\n    token_mint=config.token_mint,\n    description=\"Access to premium market data\"\n)\nasync def get_premium_data():\n    return {\n        \"data\": \"This is premium content\",\n        \"price\": 100.50,\n        \"timestamp\": \"2025-05-06T10:00:00Z\"\n    }\n\n# Dependency injection approach\nfrom openlibx402_fastapi import verify_payment_factory\n\n@app.get(\"/expensive-data\")\nasync def get_expensive_data(\n    payment = Depends(\n        verify_payment_factory(\n            amount=\"1.00\",\n            payment_address=config.payment_address,\n            token_mint=config.token_mint,\n        )\n    )\n):\n    return {\n        \"data\": \"Very expensive content\",\n        \"payment_id\": payment.payment_id,\n        \"amount_paid\": payment.actual_amount,\n    }\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n</code></pre>"},{"location":"openlibx402-technical-spec/#82-langchain-agent-example","title":"8.2 LangChain Agent Example","text":"<pre><code># examples/langchain-agent/main.py\n\nfrom langchain.chat_models import ChatOpenAI\nfrom langchain.agents import initialize_agent, AgentType\nfrom openlibx402_langchain import X402PaymentTool, X402RequestsWrapper\nfrom solders.keypair import Keypair\nimport os\nimport json\n\n# Load wallet\nwith open(\"wallet.json\") as f:\n    wallet_data = json.load(f)\n    keypair = Keypair.from_bytes(bytes(wallet_data))\n\n# Create X402-enabled tools\npayment_tool = X402PaymentTool(\n    wallet_keypair=keypair,\n    max_payment=\"5.0\",\n    rpc_url=\"https://api.devnet.solana.com\"\n)\n\n# Create requests wrapper for automatic payment handling\nrequests_wrapper = X402RequestsWrapper(\n    wallet_keypair=keypair,\n    max_payment=\"1.0\"\n)\n\n# Load LangChain tools with X402 support\nfrom langchain.agents import load_tools\ntools = load_tools(\n    [\"requests_all\"],\n    llm=ChatOpenAI(),\n    requests_wrapper=requests_wrapper\n)\ntools.append(payment_tool)\n\n# Create agent\nagent = initialize_agent(\n    tools=tools,\n    llm=ChatOpenAI(temperature=0),\n    agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION,\n    verbose=True\n)\n\n# Run agent\nresponse = agent.run(\n    \"Get me the premium market data from http://localhost:8000/premium-data \"\n    \"and tell me the current price\"\n)\n\nprint(response)\n</code></pre>"},{"location":"openlibx402-technical-spec/#83-langgraph-workflow-example","title":"8.3 LangGraph Workflow Example","text":"<pre><code># examples/langgraph-workflow/main.py\n\nfrom typing import TypedDict, Annotated, Optional\nfrom langgraph.graph import StateGraph, END\nfrom openlibx402_langgraph import payment_node, check_payment_required\nfrom openlibx402_client import X402AutoClient\nfrom solders.keypair import Keypair\nimport json\nimport asyncio\n\n# Define state\nclass ResearchState(TypedDict):\n    query: str\n    api_url: str\n    api_response: Optional[str]\n    payment_required: bool\n    payment_completed: bool\n    payment_error: Optional[str]\n    wallet_keypair: Keypair\n    final_answer: Optional[str]\n\n# Load wallet\nwith open(\"wallet.json\") as f:\n    wallet_data = json.load(f)\n    keypair = Keypair.from_bytes(bytes(wallet_data))\n\n# Define nodes\ndef plan_node(state: ResearchState) -&gt; ResearchState:\n    \"\"\"Determine which API to call\"\"\"\n    state[\"api_url\"] = \"http://localhost:8000/premium-data\"\n    state[\"payment_required\"] = False\n    return state\n\nasync def fetch_api_node(state: ResearchState) -&gt; ResearchState:\n    \"\"\"Fetch from API\"\"\"\n    client = X402AutoClient(\n        wallet_keypair=state[\"wallet_keypair\"],\n        auto_retry=False,  # We'll handle retry via graph\n    )\n\n    try:\n        response = await client.fetch(state[\"api_url\"])\n        state[\"api_response\"] = response.text\n        state[\"payment_required\"] = False\n    except Exception as e:\n        if \"402\" in str(e):\n            state[\"payment_required\"] = True\n        else:\n            state[\"payment_error\"] = str(e)\n\n    return state\n\ndef process_node(state: ResearchState) -&gt; ResearchState:\n    \"\"\"Process API response\"\"\"\n    if state[\"api_response\"]:\n        # Parse and format response\n        state[\"final_answer\"] = f\"Retrieved data: {state['api_response']}\"\n    return state\n\n# Build workflow\nworkflow = StateGraph(ResearchState)\n\nworkflow.add_node(\"plan\", plan_node)\nworkflow.add_node(\"fetch\", fetch_api_node)\nworkflow.add_node(\"payment\", payment_node)  # From openlibx402-langgraph\nworkflow.add_node(\"process\", process_node)\n\nworkflow.set_entry_point(\"plan\")\nworkflow.add_edge(\"plan\", \"fetch\")\n\nworkflow.add_conditional_edges(\n    \"fetch\",\n    check_payment_required,  # From openlibx402-langgraph\n    {\n        \"payment_required\": \"payment\",\n        \"success\": \"process\",\n        \"error\": END\n    }\n)\n\nworkflow.add_edge(\"payment\", \"fetch\")  # Retry after payment\nworkflow.add_edge(\"process\", END)\n\n# Compile and run\napp = workflow.compile()\n\n# Execute\nresult = app.invoke({\n    \"query\": \"Get premium market data\",\n    \"wallet_keypair\": keypair,\n})\n\nprint(result[\"final_answer\"])\n</code></pre>"},{"location":"openlibx402-technical-spec/#9-package-metadata-publishing","title":"9. Package Metadata &amp; Publishing","text":""},{"location":"openlibx402-technical-spec/#python-packages-pypi","title":"Python Packages (PyPI)","text":"<pre><code># pyproject.toml example for openlibx402-core\n\n[build-system]\nrequires = [\"hatchling\"]\nbuild-backend = \"hatchling.build\"\n\n[project]\nname = \"openlibx402-core\"\nversion = \"0.1.1\"\ndescription = \"Core implementation of X402 payment protocol\"\nauthors = [\n    {name = \"OpenLibx402 Contributors\", email = \"hello@openlibx402.org\"},\n]\nreadme = \"README.md\"\nlicense = {text = \"MIT\"}\nrequires-python = \"&gt;=3.8\"\ndependencies = [\n    \"solana&gt;=0.30.0\",\n    \"solders&gt;=0.18.0\",\n    \"httpx&gt;=0.24.0\",\n    \"pydantic&gt;=2.0.0\",\n]\n\n[project.optional-dependencies]\ndev = [\n    \"pytest&gt;=7.0.0\",\n    \"pytest-asyncio&gt;=0.21.0\",\n    \"black&gt;=23.0.0\",\n    \"mypy&gt;=1.0.0\",\n]\n\n[project.urls]\nHomepage = \"https://openlib.xyz\"\nDocumentation = \"https://openlibx402.github.io/docs\"\nRepository = \"https://github.com/openlibx402/openlibx402\"\n</code></pre>"},{"location":"openlibx402-technical-spec/#typescript-packages-npm","title":"TypeScript Packages (npm)","text":"<pre><code>// package.json example for @openlibx402/core\n\n{\n  \"name\": \"@openlibx402/core\",\n  \"version\": \"0.1.0\",\n  \"description\": \"Core implementation of X402 payment protocol\",\n  \"main\": \"dist/index.js\",\n  \"types\": \"dist/index.d.ts\",\n  \"scripts\": {\n    \"build\": \"tsc\",\n    \"test\": \"jest\",\n    \"lint\": \"eslint src/**/*.ts\"\n  },\n  \"keywords\": [\"x402\", \"payments\", \"solana\", \"ai-agents\", \"web3\"],\n  \"author\": \"OpenLibx402 Contributors\",\n  \"license\": \"MIT\",\n  \"dependencies\": {\n    \"@solana/web3.js\": \"^1.87.0\",\n    \"@solana/spl-token\": \"^0.3.9\",\n    \"axios\": \"^1.6.0\"\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^20.0.0\",\n    \"typescript\": \"^5.0.0\",\n    \"jest\": \"^29.0.0\",\n    \"eslint\": \"^8.0.0\"\n  }\n}\n</code></pre>"},{"location":"openlibx402-technical-spec/#10-documentation-structure","title":"10. Documentation Structure","text":"<pre><code>docs/\n\u251c\u2500\u2500 getting-started/\n\u2502   \u251c\u2500\u2500 installation.md\n\u2502   \u251c\u2500\u2500 quickstart-server.md\n\u2502   \u251c\u2500\u2500 quickstart-client.md\n\u2502   \u2514\u2500\u2500 quickstart-agent.md\n\u251c\u2500\u2500 guides/\n\u2502   \u251c\u2500\u2500 fastapi-integration.md\n\u2502   \u251c\u2500\u2500 langchain-integration.md\n\u2502   \u251c\u2500\u2500 langgraph-integration.md\n\u2502   \u251c\u2500\u2500 wallet-setup.md\n\u2502   \u2514\u2500\u2500 testing-locally.md\n\u251c\u2500\u2500 api-reference/\n\u2502   \u251c\u2500\u2500 core/\n\u2502   \u251c\u2500\u2500 server/\n\u2502   \u251c\u2500\u2500 client/\n\u2502   \u2514\u2500\u2500 integrations/\n\u251c\u2500\u2500 examples/\n\u2502   \u251c\u2500\u2500 basic-api-server.md\n\u2502   \u251c\u2500\u2500 autonomous-agent.md\n\u2502   \u251c\u2500\u2500 multi-agent-workflow.md\n\u2502   \u2514\u2500\u2500 error-handling.md\n\u2514\u2500\u2500 advanced/\n    \u251c\u2500\u2500 custom-settlement.md\n    \u251c\u2500\u2500 performance-optimization.md\n    \u2514\u2500\u2500 security-best-practices.md\n</code></pre>"},{"location":"openlibx402-technical-spec/#11-development-roadmap","title":"11. Development Roadmap","text":""},{"location":"openlibx402-technical-spec/#phase-1-core-fastapi","title":"Phase 1: Core &amp; FastAPI","text":"<ul> <li>\u2705 Core protocol implementation (Python + TypeScript)</li> <li>\u2705 Solana blockchain integration</li> <li>\u2705 FastAPI server middleware</li> <li>\u2705 Basic client (explicit &amp; implicit)</li> <li>\u2705 Error handling</li> <li>\u2705 Testing utilities</li> <li>\u2705 Example implementations</li> </ul>"},{"location":"openlibx402-technical-spec/#phase-2-ai-agent-integrations","title":"Phase 2: AI Agent Integrations","text":"<ul> <li>\u2705 LangChain tool &amp; middleware</li> <li>\u2705 LangGraph nodes &amp; helpers</li> <li>\ud83d\udd32 Additional agent framework support (AutoGPT, CrewAI)</li> </ul>"},{"location":"openlibx402-technical-spec/#phase-3-additional-frameworks","title":"Phase 3: Additional Frameworks","text":"<ul> <li>\ud83d\udd32 Express.js middleware (TypeScript)</li> <li>\ud83d\udd32 Next.js API routes helper</li> <li>\ud83d\udd32 Flask middleware (Python)</li> <li>\ud83d\udd32 Django middleware (Python)</li> <li>\ud83d\udd32 Hono middleware (TypeScript)</li> </ul>"},{"location":"openlibx402-technical-spec/#phase-4-enhanced-features","title":"Phase 4: Enhanced Features","text":"<ul> <li>\ud83d\udd32 Payment batching</li> <li>\ud83d\udd32 Subscription management</li> <li>\ud83d\udd32 Usage analytics</li> <li>\ud83d\udd32 Multi-chain support (Ethereum, Base L2)</li> <li>\ud83d\udd32 Alternative tokens (beyond USDC)</li> </ul>"},{"location":"openlibx402-technical-spec/#phase-5-ecosystem","title":"Phase 5: Ecosystem","text":"<ul> <li>\ud83d\udd32 CLI tools</li> <li>\ud83d\udd32 Admin dashboard</li> <li>\ud83d\udd32 Wallet UI components</li> <li>\ud83d\udd32 Browser extension</li> <li>\ud83d\udd32 Zapier/Make.com integrations</li> </ul>"},{"location":"openlibx402-technical-spec/#12-security-considerations","title":"12. Security Considerations","text":""},{"location":"openlibx402-technical-spec/#wallet-security","title":"Wallet Security","text":"<ul> <li>Never log private keys</li> <li>Use environment variables for sensitive data</li> <li>Recommend hardware wallets for production</li> <li>Implement rate limiting on payment endpoints</li> </ul>"},{"location":"openlibx402-technical-spec/#transaction-verification","title":"Transaction Verification","text":"<ul> <li>Always verify transactions on-chain</li> <li>Check recipient, amount, and token mint</li> <li>Implement replay attack protection via nonce</li> <li>Set reasonable expiration times (5-10 minutes)</li> </ul>"},{"location":"openlibx402-technical-spec/#api-security","title":"API Security","text":"<ul> <li>Implement CORS properly</li> <li>Use HTTPS in production</li> <li>Rate limit payment requests</li> <li>Validate all payment authorization fields</li> </ul>"},{"location":"openlibx402-technical-spec/#13-performance-optimization","title":"13. Performance Optimization","text":""},{"location":"openlibx402-technical-spec/#client-side","title":"Client-Side","text":"<ul> <li>Reuse HTTP connections (connection pooling)</li> <li>Cache payment authorizations (with expiry)</li> <li>Batch multiple API calls where possible</li> <li>Use WebSocket for high-frequency payments</li> </ul>"},{"location":"openlibx402-technical-spec/#server-side","title":"Server-Side","text":"<ul> <li>Async transaction verification</li> <li>Cache verified payments (Redis)</li> <li>Background transaction confirmation</li> <li>Load balancing for RPC calls</li> </ul>"},{"location":"openlibx402-technical-spec/#14-monitoring-observability","title":"14. Monitoring &amp; Observability","text":""},{"location":"openlibx402-technical-spec/#metrics-to-track","title":"Metrics to Track","text":"<ul> <li>Payment success rate</li> <li>Transaction confirmation time</li> <li>RPC endpoint latency</li> <li>Token balance (for auto-replenishment alerts)</li> <li>Error rates by type</li> </ul>"},{"location":"openlibx402-technical-spec/#logging","title":"Logging","text":"<pre><code>import logging\n\nlogger = logging.getLogger(\"openlibx402\")\n\n# Log payment requests\nlogger.info(f\"Payment required: {amount} for {resource}\")\n\n# Log successful payments\nlogger.info(f\"Payment verified: tx_hash={tx_hash}\")\n\n# Log errors with context\nlogger.error(\n    f\"Payment failed: {error_code}\",\n    extra={\n        \"payment_id\": payment_id,\n        \"wallet\": wallet_address,\n        \"amount\": amount,\n    }\n)\n</code></pre>"},{"location":"openlibx402-technical-spec/#end-of-technical-specification","title":"End of Technical Specification","text":"<p>This specification provides a comprehensive blueprint for implementing the OpenLibx402 library ecosystem. The architecture is modular, allowing for incremental development and easy addition of new framework integrations.</p>"},{"location":"quick-reference/","title":"OpenLibx402 Quick Reference Guide","text":""},{"location":"quick-reference/#installation","title":"Installation","text":"<pre><code># Python\npip install openlibx402-core openlibx402-fastapi openlibx402-client\npip install openlibx402-langchain openlibx402-langgraph\n\n# TypeScript\nnpm install @openlibx402/core @openlibx402/fastapi @openlibx402/client\nnpm install @openlibx402/langchain @openlibx402/langgraph\n</code></pre>"},{"location":"quick-reference/#fastapi-server-examples","title":"FastAPI Server Examples","text":""},{"location":"quick-reference/#simple-decorator-approach","title":"Simple Decorator Approach","text":"<pre><code>from fastapi import FastAPI\nfrom openlibx402_fastapi import payment_required\n\napp = FastAPI()\n\n@app.get(\"/premium-data\")\n@payment_required(\n    amount=\"0.10\",\n    payment_address=\"YOUR_WALLET_ADDRESS\",\n    token_mint=\"USDC_MINT_ADDRESS\",\n    network=\"solana-devnet\",\n    description=\"Access to premium market data\"\n)\nasync def get_premium_data():\n    return {\"data\": \"Premium content\", \"price\": 100.50}\n</code></pre>"},{"location":"quick-reference/#dependency-injection-approach","title":"Dependency Injection Approach","text":"<pre><code>from fastapi import FastAPI, Depends\nfrom openlibx402_fastapi import verify_payment_factory, PaymentAuthorization\n\napp = FastAPI()\n\n@app.get(\"/expensive-data\")\nasync def get_expensive_data(\n    payment: PaymentAuthorization = Depends(\n        verify_payment_factory(\n            amount=\"1.00\",\n            payment_address=\"YOUR_WALLET_ADDRESS\",\n            token_mint=\"USDC_MINT_ADDRESS\"\n        )\n    )\n):\n    return {\n        \"data\": \"Very expensive content\",\n        \"payment_id\": payment.payment_id,\n        \"amount_paid\": payment.actual_amount\n    }\n</code></pre>"},{"location":"quick-reference/#global-configuration","title":"Global Configuration","text":"<pre><code>from openlibx402_fastapi import X402Config, init_x402\n\nconfig = X402Config(\n    payment_address=\"YOUR_WALLET_ADDRESS\",\n    token_mint=\"USDC_MINT_ADDRESS\",\n    network=\"solana-devnet\",\n    default_amount=\"0.01\"\n)\ninit_x402(config)\n\n@app.get(\"/data\")\n@payment_required(amount=\"0.05\")  # Uses global config\nasync def get_data():\n    return {\"data\": \"content\"}\n</code></pre>"},{"location":"quick-reference/#client-examples","title":"Client Examples","text":""},{"location":"quick-reference/#explicit-client-manual-control","title":"Explicit Client (Manual Control)","text":"<pre><code>from openlibx402_client import X402Client\nfrom solders.keypair import Keypair\n\n# Load wallet\nkeypair = Keypair()  # Or load from file\n\n# Create client\nclient = X402Client(\n    wallet_keypair=keypair,\n    rpc_url=\"https://api.devnet.solana.com\"\n)\n\n# Make initial request\nresponse = await client.get(\"https://api.example.com/premium-data\")\n\n# Check if payment required\nif client.payment_required(response):\n    # Parse payment details\n    payment_request = client.parse_payment_request(response)\n    print(f\"Payment required: {payment_request.max_amount_required} USDC\")\n\n    # Create and send payment\n    authorization = await client.create_payment(payment_request)\n\n    # Retry with payment\n    response = await client.get(\n        \"https://api.example.com/premium-data\",\n        payment=authorization\n    )\n\ndata = response.json()\nprint(data)\n</code></pre>"},{"location":"quick-reference/#implicit-client-auto-payment","title":"Implicit Client (Auto-Payment)","text":"<pre><code>from openlibx402_client import X402AutoClient\nfrom solders.keypair import Keypair\n\n# Load wallet\nkeypair = Keypair()\n\n# Create auto-client\nclient = X402AutoClient(\n    wallet_keypair=keypair,\n    max_payment_amount=\"5.0\"  # Safety limit\n)\n\n# Make request - automatically handles 402 and payment\nresponse = await client.fetch(\"https://api.example.com/premium-data\")\ndata = response.json()\nprint(data)\n\n# Disable auto-retry for specific request\nresponse = await client.fetch(\n    \"https://api.example.com/data\",\n    auto_retry=False\n)\n</code></pre>"},{"location":"quick-reference/#langchain-examples","title":"LangChain Examples","text":""},{"location":"quick-reference/#using-x402paymenttool","title":"Using X402PaymentTool","text":"<pre><code>from langchain.chat_models import ChatOpenAI\nfrom langchain.agents import initialize_agent, AgentType\nfrom openlibx402_langchain import X402PaymentTool\nfrom solders.keypair import Keypair\n\n# Load wallet\nkeypair = Keypair()\n\n# Create payment tool\npayment_tool = X402PaymentTool(\n    wallet_keypair=keypair,\n    max_payment=\"5.0\",\n    name=\"pay_for_api\",\n    description=\"Make payment to access premium API data\"\n)\n\n# Create agent with payment tool\nagent = initialize_agent(\n    tools=[payment_tool],\n    llm=ChatOpenAI(temperature=0),\n    agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION,\n    verbose=True\n)\n\n# Agent can now pay for APIs\nresponse = agent.run(\n    \"Get me the premium market data from https://api.example.com/premium-data\"\n)\nprint(response)\n</code></pre>"},{"location":"quick-reference/#using-x402requestswrapper-middleware","title":"Using X402RequestsWrapper (Middleware)","text":"<pre><code>from langchain.agents import load_tools, initialize_agent, AgentType\nfrom langchain.chat_models import ChatOpenAI\nfrom openlibx402_langchain import X402RequestsWrapper\nfrom solders.keypair import Keypair\n\n# Load wallet\nkeypair = Keypair()\n\n# Create X402-enabled requests wrapper\nrequests_wrapper = X402RequestsWrapper(\n    wallet_keypair=keypair,\n    max_payment=\"1.0\"\n)\n\n# Load standard tools with X402 wrapper\ntools = load_tools(\n    [\"requests_all\"],\n    llm=ChatOpenAI(),\n    requests_wrapper=requests_wrapper\n)\n\n# Create agent\nagent = initialize_agent(\n    tools=tools,\n    llm=ChatOpenAI(temperature=0),\n    agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION,\n    verbose=True\n)\n\n# All HTTP requests automatically handle X402 payments\nresponse = agent.run(\"Fetch data from https://api.example.com/premium-data\")\n</code></pre>"},{"location":"quick-reference/#convenience-function","title":"Convenience Function","text":"<pre><code>from openlibx402_langchain import create_x402_agent\nfrom langchain.chat_models import ChatOpenAI\nfrom solders.keypair import Keypair\n\n# Load wallet\nkeypair = Keypair()\n\n# Create agent with X402 support (one function!)\nagent = create_x402_agent(\n    wallet_keypair=keypair,\n    llm=ChatOpenAI(),\n    max_payment=\"5.0\"\n)\n\nresponse = agent.run(\"Get premium data from API\")\n</code></pre>"},{"location":"quick-reference/#langgraph-examples","title":"LangGraph Examples","text":""},{"location":"quick-reference/#basic-payment-node","title":"Basic Payment Node","text":"<pre><code>from typing import TypedDict\nfrom langgraph.graph import StateGraph, END\nfrom openlibx402_langgraph import payment_node, check_payment_required\nfrom openlibx402_client import X402AutoClient\nfrom solders.keypair import Keypair\n\n# Define state\nclass AgentState(TypedDict):\n    api_url: str\n    api_response: str\n    payment_required: bool\n    payment_completed: bool\n    payment_error: str | None\n    wallet_keypair: Keypair\n\n# Load wallet\nkeypair = Keypair()\n\n# Build workflow\nworkflow = StateGraph(AgentState)\n\nworkflow.add_node(\"fetch_api\", fetch_api_node)\nworkflow.add_node(\"make_payment\", payment_node)  # From openlibx402-langgraph\nworkflow.add_node(\"process\", process_response_node)\n\nworkflow.set_entry_point(\"fetch_api\")\n\n# Conditional edge based on payment\nworkflow.add_conditional_edges(\n    \"fetch_api\",\n    check_payment_required,  # From openlibx402-langgraph\n    {\n        \"payment_required\": \"make_payment\",\n        \"success\": \"process\",\n        \"error\": END\n    }\n)\n\nworkflow.add_edge(\"make_payment\", \"fetch_api\")  # Retry after payment\nworkflow.add_edge(\"process\", END)\n\n# Compile and run\napp = workflow.compile()\nresult = app.invoke({\n    \"api_url\": \"https://api.example.com/data\",\n    \"wallet_keypair\": keypair,\n})\n</code></pre>"},{"location":"quick-reference/#combined-fetch-and-pay-node","title":"Combined Fetch-and-Pay Node","text":"<pre><code>from openlibx402_client import X402AutoClient\n\nasync def fetch_with_payment_node(state: AgentState) -&gt; AgentState:\n    \"\"\"Node that fetches API and handles payment automatically\"\"\"\n    client = X402AutoClient(\n        wallet_keypair=state[\"wallet_keypair\"],\n        max_payment_amount=\"1.0\"\n    )\n\n    try:\n        response = await client.fetch(state[\"api_url\"])\n        state[\"api_response\"] = response.text\n        state[\"payment_completed\"] = True\n    except Exception as e:\n        state[\"payment_error\"] = str(e)\n\n    return state\n\n# Use in workflow\nworkflow.add_node(\"fetch\", fetch_with_payment_node)\n</code></pre>"},{"location":"quick-reference/#error-handling","title":"Error Handling","text":""},{"location":"quick-reference/#catching-specific-errors","title":"Catching Specific Errors","text":"<pre><code>from openlibx402_core import (\n    InsufficientFundsError,\n    PaymentExpiredError,\n    PaymentVerificationError,\n    TransactionBroadcastError\n)\nfrom openlibx402_client import X402AutoClient\n\nclient = X402AutoClient(wallet_keypair=keypair)\n\ntry:\n    response = await client.fetch(\"https://api.example.com/data\")\n\nexcept InsufficientFundsError as e:\n    print(f\"Insufficient funds: need {e.required_amount}, have {e.available_amount}\")\n    # Prompt user to add funds\n\nexcept PaymentExpiredError as e:\n    print(\"Payment request expired, retrying...\")\n    # Automatically handled by auto-client, but you can catch it\n\nexcept TransactionBroadcastError as e:\n    print(f\"Transaction failed: {e.message}\")\n    # Check network connection\n\nexcept PaymentVerificationError as e:\n    print(f\"Payment verification failed: {e.message}\")\n    # Contact API provider\n</code></pre>"},{"location":"quick-reference/#handling-all-x402-errors","title":"Handling All X402 Errors","text":"<pre><code>from openlibx402_core import X402Error\n\ntry:\n    response = await client.fetch(\"https://api.example.com/data\")\nexcept X402Error as e:\n    print(f\"X402 Error: {e.code}\")\n    print(f\"Message: {e.message}\")\n    print(f\"Details: {e.details}\")\n</code></pre>"},{"location":"quick-reference/#configuration","title":"Configuration","text":""},{"location":"quick-reference/#environment-variables","title":"Environment Variables","text":"<pre><code># .env file\nX402_PAYMENT_ADDRESS=YourSolanaWalletAddress\nX402_TOKEN_MINT=USDC_MINT_ADDRESS\nX402_NETWORK=solana-devnet\nX402_RPC_URL=https://api.devnet.solana.com\nX402_DEFAULT_AMOUNT=0.01\n</code></pre> <pre><code>from openlibx402_fastapi import X402Config, init_x402\nimport os\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nconfig = X402Config(\n    payment_address=os.getenv(\"X402_PAYMENT_ADDRESS\"),\n    token_mint=os.getenv(\"X402_TOKEN_MINT\"),\n    network=os.getenv(\"X402_NETWORK\", \"solana-devnet\"),\n    rpc_url=os.getenv(\"X402_RPC_URL\"),\n)\n\ninit_x402(config)\n</code></pre>"},{"location":"quick-reference/#testing","title":"Testing","text":""},{"location":"quick-reference/#mock-payment-processor","title":"Mock Payment Processor","text":"<pre><code>from openlibx402_core.testing import MockSolanaPaymentProcessor\n\n# Use in tests\nprocessor = MockSolanaPaymentProcessor()\nprocessor.balance = 100.0  # Set mock balance\n\nclient = X402AutoClient(wallet_keypair=test_keypair)\nclient.client.processor = processor\n\n# Make requests without real blockchain\nresponse = await client.fetch(\"http://localhost:8000/data\")\n\n# Check mock transactions\nassert len(processor.transactions) == 1\n</code></pre>"},{"location":"quick-reference/#test-server","title":"Test Server","text":"<pre><code>from openlibx402_core.testing import TestServer\n\n# Create test server\nserver = TestServer(\n    payment_address=\"test_address\",\n    token_mint=\"test_usdc\"\n)\n\n@server.require_payment(amount=\"0.10\", resource=\"/test\")\nasync def test_endpoint():\n    return {\"data\": \"test\"}\n\nserver.start(port=8402)\n\n# Test against mock server\n# ...\n\nserver.stop()\n</code></pre>"},{"location":"quick-reference/#wallet-setup","title":"Wallet Setup","text":""},{"location":"quick-reference/#creating-a-new-wallet","title":"Creating a New Wallet","text":"<pre><code>from solders.keypair import Keypair\nimport json\n\n# Generate new keypair\nkeypair = Keypair()\n\n# Save to file\nwallet_data = list(bytes(keypair))\nwith open(\"wallet.json\", \"w\") as f:\n    json.dump(wallet_data, f)\n\nprint(f\"Wallet address: {keypair.pubkey()}\")\n</code></pre>"},{"location":"quick-reference/#loading-wallet","title":"Loading Wallet","text":"<pre><code>from solders.keypair import Keypair\nimport json\n\n# Load from file\nwith open(\"wallet.json\") as f:\n    wallet_data = json.load(f)\n    keypair = Keypair.from_bytes(bytes(wallet_data))\n\nprint(f\"Loaded wallet: {keypair.pubkey()}\")\n</code></pre>"},{"location":"quick-reference/#getting-devnet-sol-for-fees","title":"Getting Devnet SOL (for fees)","text":"<pre><code># Use Solana CLI\nsolana airdrop 1 YOUR_WALLET_ADDRESS --url devnet\n\n# Or use web faucet\n# https://faucet.solana.com\n</code></pre>"},{"location":"quick-reference/#common-patterns","title":"Common Patterns","text":""},{"location":"quick-reference/#retry-configuration","title":"Retry Configuration","text":"<pre><code>from openlibx402_client import X402AutoClient, RetryConfig\n\nconfig = RetryConfig(\n    enabled=True,\n    max_retries=1,\n    retry_on_402=True,\n    retry_on_network_error=True\n)\n\nclient = X402AutoClient(\n    wallet_keypair=keypair,\n    retry_config=config\n)\n</code></pre>"},{"location":"quick-reference/#custom-payment-amount","title":"Custom Payment Amount","text":"<pre><code># Pay custom amount (less than max required)\nresponse = await client.get(\"https://api.example.com/data\")\n\nif client.payment_required(response):\n    request = client.parse_payment_request(response)\n    # Pay 50% of requested amount (if API supports it)\n    auth = await client.create_payment(request, amount=\"0.05\")\n    response = await client.get(url, payment=auth)\n</code></pre>"},{"location":"quick-reference/#multiple-apis","title":"Multiple APIs","text":"<pre><code># Configure client with higher payment limit\nclient = X402AutoClient(\n    wallet_keypair=keypair,\n    max_payment_amount=\"10.0\"\n)\n\n# Fetch from multiple paid APIs\ndata1 = await client.fetch(\"https://api1.example.com/data\")\ndata2 = await client.fetch(\"https://api2.example.com/data\")\ndata3 = await client.fetch(\"https://api3.example.com/data\")\n\n# Client automatically handles payment for each\n</code></pre>"},{"location":"quick-reference/#devnet-quick-start","title":"Devnet Quick Start","text":"<pre><code># 1. Install packages\npip install openlibx402-core openlibx402-fastapi openlibx402-client\n\n# 2. Create wallet\npython -c \"from solders.keypair import Keypair; import json; kp = Keypair(); \\\njson.dump(list(bytes(kp)), open('wallet.json', 'w')); \\\nprint(f'Address: {kp.pubkey()}')\"\n\n# 3. Get devnet SOL\nsolana airdrop 1 &lt;YOUR_ADDRESS&gt; --url devnet\n\n# 4. Run example server\ncd examples/fastapi-server\npip install -r requirements.txt\npython main.py\n\n# 5. Run example client\ncd examples/langchain-agent\npip install -r requirements.txt\npython main.py\n</code></pre>"},{"location":"quick-reference/#production-checklist","title":"Production Checklist","text":"<ul> <li>[ ] Use mainnet RPC URL</li> <li>[ ] Use real USDC mint address</li> <li>[ ] Never log private keys</li> <li>[ ] Use HTTPS for all APIs</li> <li>[ ] Implement rate limiting</li> <li>[ ] Set up monitoring</li> <li>[ ] Configure reasonable payment timeouts</li> <li>[ ] Implement proper error handling</li> <li>[ ] Use environment variables for config</li> <li>[ ] Test with small amounts first</li> <li>[ ] Set maximum payment limits</li> <li>[ ] Implement wallet balance monitoring</li> </ul>"},{"location":"quick-reference/#resources","title":"Resources","text":"<ul> <li>X402 Whitepaper: https://www.x402.org/x402-whitepaper.pdf</li> <li>Solana Docs: https://docs.solana.com</li> <li>SPL Token: https://spl.solana.com/token</li> <li>FastAPI: https://fastapi.tiangolo.com</li> <li>LangChain: https://python.langchain.com</li> <li>LangGraph: https://langchain-ai.github.io/langgraph</li> </ul>"},{"location":"quick-reference/#common-issues","title":"Common Issues","text":""},{"location":"quick-reference/#insufficient-funds-error","title":"\"Insufficient Funds\" Error","text":"<ul> <li>Check wallet balance: <code>solana balance &lt;ADDRESS&gt; --url devnet</code></li> <li>Ensure you have both SOL (for fees) and USDC (for payment)</li> </ul>"},{"location":"quick-reference/#transaction-failed-error","title":"\"Transaction Failed\" Error","text":"<ul> <li>Check network connectivity</li> <li>Verify RPC endpoint is accessible</li> <li>Ensure devnet is not experiencing issues</li> </ul>"},{"location":"quick-reference/#payment-verification-failed","title":"\"Payment Verification Failed\"","text":"<ul> <li>Transaction may not be confirmed yet</li> <li>Check transaction on Solana Explorer</li> <li>Verify payment address and amount are correct</li> </ul>"},{"location":"quick-reference/#import-errors","title":"Import Errors","text":"<ul> <li>Ensure all packages are installed</li> <li>Check Python version (requires 3.8+)</li> <li>Verify virtual environment is activated</li> </ul> <p>Happy Building! \ud83d\ude80</p>"},{"location":"examples/","title":"OpenLibx402 Examples","text":"<p>This directory contains example applications demonstrating the X402 payment protocol in both Python and TypeScript.</p>"},{"location":"examples/#structure","title":"\ud83d\udcc1 Structure","text":"<pre><code>examples/\n\u251c\u2500\u2500 python/                      # Python examples\n\u2502   \u251c\u2500\u2500 fastapi-server/          # FastAPI server with payment endpoints\n\u2502   \u251c\u2500\u2500 langchain-agent/         # LangChain agent with autonomous payments\n\u2502   \u2514\u2500\u2500 langgraph-workflow/      # LangGraph workflow with payment nodes\n\u2502\n\u2514\u2500\u2500 typescript/                  # TypeScript examples\n    \u251c\u2500\u2500 express-server/          # Express.js server with payment endpoints\n    \u251c\u2500\u2500 langchain-agent/         # LangChain.js agent with autonomous payments\n    \u2514\u2500\u2500 langgraph-workflow/      # LangGraph.js workflow with payment nodes\n</code></pre>"},{"location":"examples/#python-examples","title":"\ud83d\udc0d Python Examples","text":""},{"location":"examples/#fastapi-server","title":"FastAPI Server","text":"<p>HTTP API server that requires payments for premium endpoints.</p> <p>Location: <code>python/fastapi-server/</code></p> <p>Run: <pre><code>cd python/fastapi-server\nuv run uvicorn main:app --reload\n</code></pre></p> <p>Endpoints: - <code>GET /</code> - API info (free) - <code>GET /free-data</code> - Free endpoint - <code>GET /premium-data</code> - Requires 0.10 USDC - <code>GET /expensive-data</code> - Requires 1.00 USDC - <code>GET /tiered-data/{tier}</code> - Requires 0.05 USDC</p>"},{"location":"examples/#langchain-agent","title":"LangChain Agent","text":"<p>AI agent that autonomously pays for API access.</p> <p>Location: <code>python/langchain-agent/</code></p> <p>Run: <pre><code>cd python/langchain-agent\nexport OPENAI_API_KEY=\"your-key\"\nuv run python main.py\n</code></pre></p> <p>Features: - Autonomous payment capability - Multiple API access - Custom tool integration</p>"},{"location":"examples/#langgraph-workflow","title":"LangGraph Workflow","text":"<p>Workflows with payment nodes for accessing paid APIs.</p> <p>Location: <code>python/langgraph-workflow/</code></p> <p>Run: <pre><code>cd python/langgraph-workflow\nuv run python main.py\n</code></pre></p> <p>Features: - Payment nodes - Conditional routing - Multi-step workflows</p>"},{"location":"examples/#typescript-examples","title":"\ud83d\udce6 TypeScript Examples","text":""},{"location":"examples/#expressjs-server","title":"Express.js Server","text":"<p>HTTP API server that requires payments for premium endpoints.</p> <p>Location: <code>typescript/express-server/</code></p> <p>Run: <pre><code>cd typescript/express-server\npnpm install &amp;&amp; pnpm run build &amp;&amp; pnpm start\n</code></pre></p> <p>Or from root: <pre><code>make example-express\n</code></pre></p> <p>Endpoints: - <code>GET /</code> - API info (free) - <code>GET /free-data</code> - Free endpoint - <code>GET /premium-data</code> - Requires 0.10 USDC - <code>GET /expensive-data</code> - Requires 1.00 USDC - <code>GET /tiered-data/:tier</code> - Requires 0.05 USDC</p>"},{"location":"examples/#langchainjs-agent","title":"LangChain.js Agent","text":"<p>AI agent that autonomously pays for API access.</p> <p>Location: <code>typescript/langchain-agent/</code></p> <p>Run: <pre><code>cd typescript/langchain-agent\ncp .env.example .env\n# Edit .env and add OPENAI_API_KEY\npnpm install &amp;&amp; pnpm run build &amp;&amp; pnpm start\n</code></pre></p> <p>Or from root: <pre><code>make example-langchain\n</code></pre></p> <p>Features: - Autonomous payment capability - Multiple API access - Custom tool configuration</p>"},{"location":"examples/#langgraphjs-workflow","title":"LangGraph.js Workflow","text":"<p>Workflows with payment nodes for accessing paid APIs.</p> <p>Location: <code>typescript/langgraph-workflow/</code></p> <p>Run: <pre><code>cd typescript/langgraph-workflow\npnpm install &amp;&amp; pnpm run build &amp;&amp; pnpm start\n</code></pre></p> <p>Or from root: <pre><code>make example-langgraph\n</code></pre></p> <p>Features: - Payment nodes - Conditional routing - Multi-step workflows</p>"},{"location":"examples/#quick-start","title":"\ud83d\ude80 Quick Start","text":""},{"location":"examples/#1-start-a-server","title":"1. Start a Server","text":"<p>Python FastAPI: <pre><code>cd examples/python/fastapi-server\nuv run uvicorn main:app --reload\n</code></pre></p> <p>TypeScript Express: <pre><code>cd examples/typescript/express-server\npnpm install &amp;&amp; pnpm run build &amp;&amp; pnpm start\n</code></pre></p> <p>Server will be available at: - Python: <code>http://localhost:8000</code> - TypeScript: <code>http://localhost:3000</code></p>"},{"location":"examples/#2-test-with-client","title":"2. Test with Client","text":"<p>Python Client: <pre><code>from openlibx402_client import X402AutoClient\nfrom solders.keypair import Keypair\n\nkeypair = Keypair()  # Load your keypair\nclient = X402AutoClient(keypair)\n\nresponse = await client.get(\"http://localhost:8000/premium-data\")\nprint(response.json())\n</code></pre></p> <p>TypeScript Client: <pre><code>import { X402AutoClient } from '@openlibx402/client';\nimport { Keypair } from '@solana/web3.js';\n\nconst keypair = Keypair.generate();  // Load your keypair\nconst client = new X402AutoClient(keypair);\n\nconst response = await client.get('http://localhost:3000/premium-data');\nconsole.log(response.data);\n</code></pre></p>"},{"location":"examples/#3-run-agent-examples","title":"3. Run Agent Examples","text":"<p>Make sure the server is running first!</p> <p>Python LangChain: <pre><code>cd examples/python/langchain-agent\nexport OPENAI_API_KEY=\"your-key\"\nuv run python main.py\n</code></pre></p> <p>TypeScript LangChain.js: <pre><code>cd examples/typescript/langchain-agent\nexport OPENAI_API_KEY=\"your-key\"\npnpm run dev\n</code></pre></p>"},{"location":"examples/#prerequisites","title":"\ud83d\udd11 Prerequisites","text":""},{"location":"examples/#all-examples","title":"All Examples","text":"<ul> <li>Solana wallet with:</li> <li>SOL for transaction fees</li> <li>USDC tokens for payments</li> <li>Running server (FastAPI or Express)</li> </ul>"},{"location":"examples/#agent-examples-additional","title":"Agent Examples (Additional)","text":"<ul> <li>OpenAI API key (for LangChain/LangChain.js agents)</li> <li>Set as <code>OPENAI_API_KEY</code> environment variable</li> </ul>"},{"location":"examples/#wallet-setup","title":"\ud83d\udcb0 Wallet Setup","text":"<p>All examples will create a <code>wallet.json</code> file on first run.</p> <p>Fund your wallet:</p> <pre><code># Get SOL on devnet\nsolana airdrop 1 &lt;YOUR_ADDRESS&gt; --url devnet\n\n# Get USDC from a faucet\n# Visit: https://spl-token-faucet.com/\n</code></pre> <p>\u26a0\ufe0f Security Warning: - Never commit <code>wallet.json</code> to version control - In production, use secure key management - The wallet files are in <code>.gitignore</code></p>"},{"location":"examples/#testing-flow","title":"\ud83e\uddea Testing Flow","text":"<ol> <li>Start Server: Run FastAPI or Express server</li> <li>Test Free Endpoint: <code>curl http://localhost:3000/free-data</code></li> <li>Test Paid Endpoint: <code>curl http://localhost:3000/premium-data</code></li> <li>Should return 402 Payment Required</li> <li>Run Agent: Agent automatically handles payment</li> <li>Verify: Check agent receives data</li> </ol>"},{"location":"examples/#learn-more","title":"\ud83d\udcda Learn More","text":"<p>Each example directory contains its own detailed README:</p> <ul> <li>FastAPI Server</li> <li>Python LangChain Agent</li> <li>Python LangGraph Workflow</li> <li>Express.js Server</li> <li>TypeScript LangChain Agent</li> <li>TypeScript LangGraph Workflow</li> </ul>"},{"location":"examples/#troubleshooting","title":"\ud83d\udd27 Troubleshooting","text":""},{"location":"examples/#server-wont-start","title":"Server Won't Start","text":"<ul> <li>Check port isn't already in use</li> <li>Verify dependencies are installed</li> <li>Check wallet address is configured</li> </ul>"},{"location":"examples/#agent-cant-pay","title":"Agent Can't Pay","text":"<ul> <li>Ensure server is running</li> <li>Fund wallet with SOL and USDC</li> <li>Check OpenAI API key is set</li> <li>Verify server URL is correct</li> </ul>"},{"location":"examples/#payment-verification-fails","title":"Payment Verification Fails","text":"<ul> <li>Check RPC URL is accessible</li> <li>Ensure transaction was broadcast</li> <li>Verify wallet has sufficient funds</li> </ul>"},{"location":"examples/#next-steps","title":"\ud83c\udfaf Next Steps","text":"<ol> <li>Run the server examples</li> <li>Test with simple curl requests</li> <li>Try the agent examples</li> <li>Build your own application!</li> </ol> <p>For more information, see the main documentation.</p>"},{"location":"examples/python/fastapi-server/","title":"FastAPI Server Example","text":"<p>Example FastAPI server with X402 payment requirements.</p>"},{"location":"examples/python/fastapi-server/#setup","title":"Setup","text":"<ol> <li> <p>Install dependencies: <pre><code>pip install -r requirements.txt\n</code></pre></p> </li> <li> <p>Configure environment: <pre><code>cp .env.example .env\n# Edit .env with your wallet address and token mint\n</code></pre></p> </li> <li> <p>Run the server: <pre><code>python main.py\n</code></pre></p> </li> <li> <p>Visit http://localhost:8000/docs for API documentation</p> </li> </ol>"},{"location":"examples/python/fastapi-server/#testing","title":"Testing","text":""},{"location":"examples/python/fastapi-server/#get-free-data","title":"Get free data:","text":"<pre><code>curl http://localhost:8000/free-data\n</code></pre>"},{"location":"examples/python/fastapi-server/#try-premium-endpoint-will-return-402","title":"Try premium endpoint (will return 402):","text":"<pre><code>curl http://localhost:8000/premium-data\n</code></pre>"},{"location":"examples/python/fastapi-server/#with-payment-client","title":"With payment client:","text":"<p>See the langchain-agent example for how to make payments automatically.</p>"},{"location":"examples/python/fastapi-server/#endpoints","title":"Endpoints","text":"<ul> <li><code>GET /</code> - API information (free)</li> <li><code>GET /free-data</code> - Free data (no payment)</li> <li><code>GET /premium-data</code> - Premium data (0.10 USDC)</li> <li><code>GET /expensive-data</code> - Expensive AI data (1.00 USDC)</li> <li><code>GET /tiered-data/{tier}</code> - Tiered access (0.05 USDC)</li> </ul>"},{"location":"examples/python/langchain-agent/","title":"LangChain Agent Example","text":"<p>Example LangChain agent with autonomous X402 payment capabilities.</p>"},{"location":"examples/python/langchain-agent/#setup","title":"Setup","text":"<ol> <li> <p>Install dependencies: <pre><code>pip install -r requirements.txt\n</code></pre></p> </li> <li> <p>Set OpenAI API key: <pre><code>export OPENAI_API_KEY='your-key-here'\n</code></pre></p> </li> <li> <p>Create and fund wallet: <pre><code># Run the script once to generate wallet\npython main.py\n\n# Fund the wallet with SOL (for transaction fees)\nsolana airdrop 1 YOUR_WALLET_ADDRESS --url devnet\n\n# You'll also need USDC on devnet for payments\n# Use a faucet or swap service\n</code></pre></p> </li> <li> <p>Start the FastAPI server (in another terminal): <pre><code>cd ../fastapi-server\npython main.py\n</code></pre></p> </li> <li> <p>Run the agent examples: <pre><code>python main.py\n</code></pre></p> </li> </ol>"},{"location":"examples/python/langchain-agent/#what-it-does","title":"What it does","text":"<p>The examples demonstrate three scenarios:</p>"},{"location":"examples/python/langchain-agent/#example-1-simple-agent","title":"Example 1: Simple Agent","text":"<p>Creates an agent using the convenience function that can autonomously detect and pay for 402 responses.</p>"},{"location":"examples/python/langchain-agent/#example-2-custom-tools","title":"Example 2: Custom Tools","text":"<p>Shows how to combine X402 payment capabilities with other LangChain tools.</p>"},{"location":"examples/python/langchain-agent/#example-3-multi-api","title":"Example 3: Multi-API","text":"<p>Demonstrates an agent making multiple payments to different APIs in a single workflow.</p>"},{"location":"examples/python/langchain-agent/#key-features","title":"Key Features","text":"<ul> <li>Autonomous Payments: Agent detects 402 responses and pays automatically</li> <li>Safety Limits: <code>max_payment</code> parameter prevents overspending</li> <li>Transparent: Verbose mode shows payment decisions</li> <li>Flexible: Works with any X402-enabled API</li> </ul>"},{"location":"examples/python/langgraph-workflow/","title":"LangGraph Workflow Example","text":"<p>Example LangGraph workflows with X402 payment nodes.</p>"},{"location":"examples/python/langgraph-workflow/#setup","title":"Setup","text":"<ol> <li> <p>Install dependencies: <pre><code>pip install -r requirements.txt\n</code></pre></p> </li> <li> <p>Create and fund wallet: <pre><code># Run the script once to generate wallet\npython main.py\n\n# Fund the wallet with SOL (for transaction fees)\nsolana airdrop 1 YOUR_WALLET_ADDRESS --url devnet\n</code></pre></p> </li> <li> <p>Start the FastAPI server (in another terminal): <pre><code>cd ../fastapi-server\npython main.py\n</code></pre></p> </li> <li> <p>Run the workflow examples: <pre><code>python main.py\n</code></pre></p> </li> </ol>"},{"location":"examples/python/langgraph-workflow/#what-it-does","title":"What it does","text":"<p>The examples demonstrate three workflow patterns:</p>"},{"location":"examples/python/langgraph-workflow/#example-1-simple-workflow","title":"Example 1: Simple Workflow","text":"<p>Uses the convenience function to create a basic workflow with payment handling.</p>"},{"location":"examples/python/langgraph-workflow/#example-2-custom-workflow","title":"Example 2: Custom Workflow","text":"<p>Shows how to build a workflow with separate fetch and payment nodes for more control.</p>"},{"location":"examples/python/langgraph-workflow/#example-3-multi-step-workflow","title":"Example 3: Multi-Step Workflow","text":"<p>Demonstrates a workflow that accesses multiple paid APIs sequentially, handling payments for each.</p>"},{"location":"examples/python/langgraph-workflow/#key-features","title":"Key Features","text":"<ul> <li>Modular Design: Payment logic is isolated in dedicated nodes</li> <li>Conditional Routing: Workflows automatically route to payment nodes when needed</li> <li>Error Handling: Graceful handling of payment errors</li> <li>Composable: Easy to add payment capabilities to existing workflows</li> </ul>"},{"location":"examples/python/langgraph-workflow/#workflow-patterns","title":"Workflow Patterns","text":""},{"location":"examples/python/langgraph-workflow/#pattern-1-combined-node","title":"Pattern 1: Combined Node","text":"<p><pre><code>workflow.add_node(\"fetch\", fetch_with_payment_node)\n</code></pre> Simplest approach - fetch and pay in one node.</p>"},{"location":"examples/python/langgraph-workflow/#pattern-2-separate-nodes","title":"Pattern 2: Separate Nodes","text":"<p><pre><code>workflow.add_node(\"fetch\", fetch_node)\nworkflow.add_node(\"pay\", payment_node)\nworkflow.add_conditional_edges(\"fetch\", check_payment_required, {...})\n</code></pre> More control - explicit payment step.</p>"},{"location":"examples/python/langgraph-workflow/#pattern-3-multi-step","title":"Pattern 3: Multi-Step","text":"<p><pre><code># Loop through multiple APIs\nworkflow.add_conditional_edges(\"collect\", check_more_apis, {\n    \"fetch_next\": \"fetch\",\n    \"complete\": END\n})\n</code></pre> Complex workflows with multiple payments.</p>"},{"location":"examples/typescript/express-server/","title":"Express.js Server Example with X402 Payment Support","text":"<p>This example demonstrates how to create an Express.js API server with X402 payment requirements for specific endpoints.</p>"},{"location":"examples/typescript/express-server/#features","title":"Features","text":"<ul> <li>Free endpoints - Public access without payment</li> <li>Premium endpoints - Require payment to access</li> <li>Automatic payment verification - Built-in Solana blockchain verification</li> <li>Flexible pricing - Different amounts for different endpoints</li> <li>TypeScript - Full type safety</li> </ul>"},{"location":"examples/typescript/express-server/#setup","title":"Setup","text":""},{"location":"examples/typescript/express-server/#1-install-dependencies","title":"1. Install Dependencies","text":"<pre><code>npm install\n</code></pre>"},{"location":"examples/typescript/express-server/#2-configure-environment","title":"2. Configure Environment","text":"<p>Create a <code>.env</code> file based on <code>.env.example</code>:</p> <pre><code>cp .env.example .env\n</code></pre> <p>Edit <code>.env</code> with your Solana wallet details:</p> <pre><code>PAYMENT_WALLET_ADDRESS=your_solana_wallet_address_here\nUSDC_MINT_ADDRESS=EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\nSOLANA_RPC_URL=https://api.devnet.solana.com\nPORT=3000\n</code></pre>"},{"location":"examples/typescript/express-server/#3-build-and-run","title":"3. Build and Run","text":"<pre><code># Build TypeScript\nnpm run build\n\n# Start server\nnpm start\n\n# Or run in development mode\nnpm run dev\n</code></pre> <p>The server will start on <code>http://localhost:3000</code>.</p>"},{"location":"examples/typescript/express-server/#api-endpoints","title":"API Endpoints","text":""},{"location":"examples/typescript/express-server/#free-endpoints","title":"Free Endpoints","text":"<ul> <li>GET / - API information (no payment)</li> <li>GET /free-data - Free data access (no payment)</li> </ul>"},{"location":"examples/typescript/express-server/#paid-endpoints","title":"Paid Endpoints","text":"<ul> <li>GET /premium-data - Premium data (0.10 USDC)</li> <li>GET /expensive-data - AI inference (1.00 USDC)</li> <li>GET /tiered-data/:tier - Tiered content (0.05 USDC)</li> <li>POST /process-data - Data processing (0.25 USDC)</li> </ul>"},{"location":"examples/typescript/express-server/#usage-examples","title":"Usage Examples","text":""},{"location":"examples/typescript/express-server/#free-endpoint","title":"Free Endpoint","text":"<pre><code>curl http://localhost:3000/free-data\n</code></pre> <p>Response: <pre><code>{\n  \"data\": \"This is free content available to everyone\",\n  \"price\": 0,\n  \"access\": \"public\"\n}\n</code></pre></p>"},{"location":"examples/typescript/express-server/#paid-endpoint-without-payment","title":"Paid Endpoint (Without Payment)","text":"<pre><code>curl http://localhost:3000/premium-data\n</code></pre> <p>Response (402 Payment Required): ```json {   \"max_amount_required\": \"0.10\",   \"asset_type\": \"SPL\",   \"asset_address\": \"DEMO_USDC_MINT\",   \"payment_address\": \"DEMO_WALLET_ADDRESS\",   \"network\": \"solana-devnet\",   \"expires_at\": \"2025-01-01T10:05:00Z\",   \"nonce\": \"...\",   \"payment_id\": \"...\",</p>"},{"location":"examples/typescript/langchain-agent/","title":"LangChain.js Payment Tool Example","text":"<p>This example demonstrates the X402 payment tool for LangChain.js, which enables payment capabilities that can be integrated with AI agents.</p>"},{"location":"examples/typescript/langchain-agent/#features","title":"Features","text":"<ul> <li>X402 Payment Tool: LangChain.js tool for making payments to access APIs</li> <li>Multiple APIs: Examples of accessing multiple paid APIs</li> <li>Custom Behavior: Configurable payment limits and RPC URLs</li> <li>TypeScript: Full type safety and modern async/await patterns</li> <li>Agent-Ready: Tool can be integrated with LangChain agents for autonomous payments</li> </ul>"},{"location":"examples/typescript/langchain-agent/#overview","title":"Overview","text":"<p>The X402PaymentTool can be integrated with LangChain.js agents to enable autonomous payment capabilities. This example shows direct tool usage for clarity. In production, integrate this tool with LangChain agents that use LLMs to decide when to make payments.</p>"},{"location":"examples/typescript/langchain-agent/#prerequisites","title":"Prerequisites","text":"<ol> <li> <p>Express.js Server: The express-server example must be running    <pre><code>cd ../express-server\npnpm install &amp;&amp; pnpm run build &amp;&amp; pnpm start\n</code></pre></p> </li> <li> <p>Wallet with Funds: You need a Solana wallet with:</p> </li> <li>SOL for transaction fees</li> <li>USDC tokens for payments (on devnet)</li> </ol>"},{"location":"examples/typescript/langchain-agent/#setup","title":"Setup","text":"<ol> <li> <p>Install dependencies:    <pre><code>pnpm install\n</code></pre></p> </li> <li> <p>The first run will create a wallet file (<code>wallet.json</code>)</p> </li> <li>Important: Fund this wallet with SOL and USDC on devnet</li> <li>Get SOL: <code>solana airdrop 1 &lt;ADDRESS&gt; --url devnet</code></li> <li>Get USDC: Use a devnet faucet</li> </ol>"},{"location":"examples/typescript/langchain-agent/#running-examples","title":"Running Examples","text":"<pre><code># Build\npnpm run build\n\n# Run\npnpm start\n\n# Or run in dev mode\npnpm run dev\n</code></pre>"},{"location":"examples/typescript/langchain-agent/#examples","title":"Examples","text":""},{"location":"examples/typescript/langchain-agent/#example-1-simple-payment-tool","title":"Example 1: Simple Payment Tool","text":"<p>Demonstrates basic tool usage: - Creates X402PaymentTool - Makes payment to access a single API - Shows direct tool invocation</p>"},{"location":"examples/typescript/langchain-agent/#example-2-multiple-apis","title":"Example 2: Multiple APIs","text":"<p>Demonstrates accessing multiple paid APIs: - Higher payment limit for multiple payments - Sequential API access - Handles multiple 402 responses</p>"},{"location":"examples/typescript/langchain-agent/#example-3-custom-payment-behavior","title":"Example 3: Custom Payment Behavior","text":"<p>Shows customization options: - Custom RPC URL - Specific payment limits - Custom tool names and descriptions</p>"},{"location":"examples/typescript/langchain-agent/#integration-with-langchain-agents","title":"Integration with LangChain Agents","text":"<p>To use this tool with a LangChain agent:</p> <p>```typescript import { createX402PaymentTool } from '@openlibx402/langchain'; import { ChatOpenAI } from '@langchain/openai';</p> <p>// Create the payment tool const paymentTool = createX402PaymentTool({   walletKeypair: yourKeypair,   maxPayment: '5.0', });</p> <p>// Use with your LangChain agent const agent = createYourAgent({   llm: new ChatOpenAI(),   tools: [paymentTool, ...otherTools], });</p> <p>// Agent can now autonomously make payments const result = await agent.invoke({   input: 'Get data from http://localhost:3000/premium-data' });</p>"},{"location":"examples/typescript/langgraph-workflow/","title":"LangGraph.js Workflow with X402 Payment Support","text":"<p>This example demonstrates how to build LangGraph.js workflows that include payment nodes for accessing paid APIs using the X402 payment protocol.</p>"},{"location":"examples/typescript/langgraph-workflow/#features","title":"Features","text":"<ul> <li>Payment Nodes: Reusable nodes for handling payments in workflows</li> <li>Conditional Routing: Route based on payment requirements</li> <li>Multi-Step Workflows: Access multiple paid APIs in sequence</li> <li>State Management: Proper state handling for payment status</li> <li>TypeScript: Full type safety with LangGraph.js</li> </ul>"},{"location":"examples/typescript/langgraph-workflow/#prerequisites","title":"Prerequisites","text":"<ol> <li> <p>Express.js Server: The express-server example must be running    <pre><code>cd ../express-server\npnpm install &amp;&amp; pnpm run build &amp;&amp; pnpm start\n</code></pre></p> </li> <li> <p>Wallet with Funds: You need a Solana wallet with:</p> </li> <li>SOL for transaction fees</li> <li>USDC tokens for payments (on devnet)</li> </ol>"},{"location":"examples/typescript/langgraph-workflow/#setup","title":"Setup","text":"<ol> <li> <p>Install dependencies:    <pre><code>pnpm install\n</code></pre></p> </li> <li> <p>Create <code>.env</code> file (optional):    <pre><code>cp .env.example .env\n</code></pre></p> </li> <li> <p>The first run will create a wallet file (<code>wallet.json</code>)</p> </li> <li>Important: Fund this wallet with SOL and USDC on devnet</li> <li>Get SOL: <code>solana airdrop 1 &lt;ADDRESS&gt; --url devnet</code></li> <li>Get USDC: Use a devnet faucet</li> </ol>"},{"location":"examples/typescript/langgraph-workflow/#running-examples","title":"Running Examples","text":"<pre><code># Build\npnpm run build\n\n# Run\npnpm start\n\n# Or run in dev mode\npnpm run dev\n</code></pre>"},{"location":"examples/typescript/langgraph-workflow/#examples","title":"Examples","text":""},{"location":"examples/typescript/langgraph-workflow/#example-1-simple-payment-workflow","title":"Example 1: Simple Payment Workflow","text":"<p>Uses <code>fetchWithPaymentNode</code> for easy payment integration: - Single node handles both fetch and payment - Minimal configuration - Automatic payment handling</p>"},{"location":"examples/typescript/langgraph-workflow/#example-2-custom-workflow-with-conditional-payment","title":"Example 2: Custom Workflow with Conditional Payment","text":"<p>Demonstrates explicit payment handling: - Separate fetch and payment nodes - Conditional routing based on payment requirements - Custom error handling</p>"},{"location":"examples/typescript/langgraph-workflow/#example-3-multi-step-research-workflow","title":"Example 3: Multi-Step Research Workflow","text":"<p>Shows complex multi-API workflows: - Access multiple paid APIs sequentially - Collect and aggregate results - State management across multiple steps</p>"},{"location":"examples/typescript/langgraph-workflow/#how-it-works","title":"How It Works","text":""},{"location":"examples/typescript/langgraph-workflow/#payment-flow","title":"Payment Flow","text":"<ol> <li>Fetch Node: Attempts to fetch API</li> <li>Check Payment: Determines if payment is required (402 response)</li> <li>Payment Node: Creates and broadcasts payment if needed</li> <li>Process Node: Processes API response</li> <li>State Updates: Tracks payment status throughout workflow</li> </ol>"},{"location":"examples/typescript/langgraph-workflow/#state-management","title":"State Management","text":"<p>```typescript interface PaymentState {   wallet_keypair: Keypair;   api_url: string;   api_response?: string;   payment_required?: boolean;   payment_completed?: boolean;   payment_error?: string;   max_payment_amount?: string; }</p>"},{"location":"examples/typescript/nextjs-app/","title":"Next.js App Example with X402 Payment Support","text":"<p>This example demonstrates how to create a Next.js application with X402 payment requirements for API endpoints, including both server-side API routes and client-side payment handling.</p>"},{"location":"examples/typescript/nextjs-app/#features","title":"Features","text":"<ul> <li>Next.js App Router - Modern Next.js 14 with App Router</li> <li>Server-side API Routes - Protected endpoints with payment requirements</li> <li>Client-side Payment Handling - React components with automatic payment flow</li> <li>Free and Premium Endpoints - Mix of public and paid content</li> <li>TypeScript - Full type safety</li> <li>Tailwind CSS - Modern styling</li> <li>X402 Protocol - Blockchain-based micropayments</li> </ul>"},{"location":"examples/typescript/nextjs-app/#setup","title":"Setup","text":""},{"location":"examples/typescript/nextjs-app/#1-install-dependencies","title":"1. Install Dependencies","text":"<p>From the monorepo root:</p> <pre><code>pnpm install\n</code></pre> <p>Or from npm:</p> <pre><code>npm install\n</code></pre>"},{"location":"examples/typescript/nextjs-app/#2-configure-environment","title":"2. Configure Environment","text":"<p>Create a <code>.env.local</code> file based on <code>.env.example</code>:</p> <pre><code>cp .env.example .env.local\n</code></pre> <p>Edit <code>.env.local</code> with your Solana wallet details:</p> <pre><code>PAYMENT_WALLET_ADDRESS=your_solana_wallet_address_here\nUSDC_MINT_ADDRESS=EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\nSOLANA_RPC_URL=https://api.devnet.solana.com\n</code></pre>"},{"location":"examples/typescript/nextjs-app/#3-build-and-run","title":"3. Build and Run","text":"<pre><code># Development mode\nnpm run dev\n\n# Build for production\nnpm run build\n\n# Start production server\nnpm start\n</code></pre> <p>The app will start on <code>http://localhost:3000</code>.</p>"},{"location":"examples/typescript/nextjs-app/#api-endpoints","title":"API Endpoints","text":""},{"location":"examples/typescript/nextjs-app/#free-endpoints","title":"Free Endpoints","text":"<ul> <li>GET /api - API information (no payment)</li> <li>GET /api/free-data - Free data access (no payment)</li> </ul>"},{"location":"examples/typescript/nextjs-app/#paid-endpoints","title":"Paid Endpoints","text":"<ul> <li>GET /api/premium-data - Premium data (0.10 USDC)</li> <li>GET /api/expensive-data - AI inference (1.00 USDC)</li> <li>GET /api/tiered-data/[tier] - Tiered content (0.05 USDC)</li> <li>POST /api/process-data - Data processing (0.25 USDC)</li> </ul>"},{"location":"examples/typescript/nextjs-app/#how-it-works","title":"How It Works","text":""},{"location":"examples/typescript/nextjs-app/#server-side-api-routes","title":"Server-Side (API Routes)","text":"<ol> <li>Initialize X402 Configuration (<code>app/api/config.ts</code>):</li> </ol> <pre><code>import { X402Config, initX402 } from \"@openlibx402/nextjs\";\n\nconst config = new X402Config({\n  paymentAddress: process.env.PAYMENT_WALLET_ADDRESS!,\n  tokenMint: process.env.USDC_MINT_ADDRESS!,\n  network: \"solana-devnet\",\n});\n\ninitX402(config);\n</code></pre> <ol> <li>Protect API Routes with <code>withPayment</code>:</li> </ol> <pre><code>import { withPayment } from \"@openlibx402/nextjs\";\n\nexport const GET = withPayment(\n  {\n    amount: \"0.10\",\n    description: \"Access to premium data\",\n  },\n  async (req, context) =&gt; {\n    return NextResponse.json({\n      data: \"Premium content\",\n      payment_id: context.payment?.paymentId,\n    });\n  }\n);\n</code></pre>"},{"location":"examples/typescript/nextjs-app/#client-side-react-components","title":"Client-Side (React Components)","text":"<ol> <li>Setup X402 Client Provider (<code>app/components/X402ClientProvider.tsx</code>):</li> </ol> <pre><code>import { X402AutoClient } from \"@openlibx402/client\";\nimport { Keypair } from \"@solana/web3.js\";\n\nconst keypair = Keypair.generate(); // Or use browser wallet\nconst client = new X402AutoClient(keypair, rpcUrl);\n</code></pre> <ol> <li>Make Requests (automatic payment handling):</li> </ol> <pre><code>const response = await client.get(\"/api/premium-data\");\n// Payment is handled automatically if required\n</code></pre>"},{"location":"examples/typescript/nextjs-app/#payment-flow","title":"Payment Flow","text":"<ol> <li>User clicks \"Try Endpoint\" button</li> <li>Client makes request to API endpoint</li> <li>Server responds with 402 Payment Required (if no payment)</li> <li>Client detects 402 and creates payment</li> <li>Client retries request with payment authorization</li> <li>Server verifies payment on-chain</li> <li>Server returns protected content</li> </ol>"},{"location":"examples/typescript/nextjs-app/#browser-wallet-integration","title":"Browser Wallet Integration","text":"<p>To integrate with browser wallets in production:</p> <pre><code>// Instead of generating a keypair\nimport { useWallet } from \"@solana/wallet-adapter-react\";\n\nconst { publicKey, signTransaction } = useWallet();\n\n// Use wallet adapter with X402Client\nconst client = new X402Client(/* wallet adapter */, rpcUrl);\n</code></pre>"},{"location":"examples/typescript/nextjs-app/#development-tips","title":"Development Tips","text":"<ol> <li>Testing without funds: The demo will show payment required errors, which is expected behavior</li> <li>Hot reload: Changes to API routes and components are automatically reflected</li> <li>TypeScript: Full type checking for both client and server code</li> <li>Tailwind CSS: Utility-first styling for rapid UI development</li> </ol>"},{"location":"examples/typescript/nextjs-app/#learn-more","title":"Learn More","text":"<ul> <li>OpenLibx402 Documentation</li> <li>X402 Protocol Specification</li> <li>Next.js Documentation</li> <li>Solana Web3.js</li> </ul>"},{"location":"go/","title":"Go Implementation","text":"<p>Welcome to the OpenLibx402 Go implementation documentation. This section covers all Go packages, libraries, middleware, and examples for building X402-enabled APIs and clients.</p>"},{"location":"go/#overview","title":"Overview","text":"<p>The Go implementation provides:</p> <ul> <li>Core Library - X402 protocol implementation with models, errors, and Solana payment processing</li> <li>Client Library - HTTP client with automatic and explicit payment handling</li> <li>Middleware - Integration with popular Go web frameworks (net/http, Echo)</li> <li>Examples - Complete working examples for server and client implementations</li> </ul>"},{"location":"go/#quick-navigation","title":"Quick Navigation","text":""},{"location":"go/#libraries","title":"\ud83d\udcda Libraries","text":"<ul> <li>Core Library - Payment models, errors, and Solana processor</li> <li>Client Library - X402 HTTP client with auto-payment support</li> </ul>"},{"location":"go/#middleware","title":"\ud83d\udd17 Middleware","text":"<ul> <li>net/http Middleware - Standard Go net/http integration</li> <li>Echo Middleware - Echo web framework integration</li> </ul>"},{"location":"go/#examples","title":"\ud83d\ude80 Examples","text":"<ul> <li>net/http Server - Complete server with multiple pricing tiers</li> <li>Echo Server - Echo framework server with dynamic pricing</li> </ul>"},{"location":"go/#getting-started","title":"\ud83d\udcd6 Getting Started","text":"<ul> <li>Installation</li> <li>Quick Start Server</li> <li>Quick Start Client</li> </ul>"},{"location":"go/#reference","title":"\ud83d\udd27 Reference","text":"<ul> <li>API Reference</li> <li>Configuration</li> <li>Error Handling</li> </ul>"},{"location":"go/#key-features","title":"Key Features","text":"<p>\u2728 One-Line Integration - Add payment requirements with minimal code \ud83e\udd16 Automatic Payments - Clients automatically handle payment flows \u26a1 Instant Settlement - ~200ms on Solana \ud83d\udcb0 Micropayments - Support payments as low as $0.001 \ud83d\udd10 Secure - SSRF protection, payment verification, nonce-based replay protection \ud83c\udf10 Framework Agnostic - Works with net/http, Echo, and custom implementations</p>"},{"location":"go/#import-paths","title":"Import Paths","text":"<pre><code>// Core protocol\nimport \"github.com/openlibx402/go/openlibx402-core\"\n\n// HTTP client\nimport \"github.com/openlibx402/go/openlibx402-client\"\n\n// net/http middleware\nimport nethttp \"github.com/openlibx402/go/openlibx402-nethttp\"\n\n// Echo middleware\nimport echox402 \"github.com/openlibx402/go/openlibx402-echo\"\n</code></pre>"},{"location":"go/#installation","title":"Installation","text":"<pre><code># Core package (required)\ngo get github.com/openlibx402/go/openlibx402-core\n\n# Client (for consuming paid APIs)\ngo get github.com/openlibx402/go/openlibx402-client\n\n# Middleware for your framework\ngo get github.com/openlibx402/go/openlibx402-nethttp\n# or\ngo get github.com/openlibx402/go/openlibx402-echo\n</code></pre>"},{"location":"go/#the-x402-flow","title":"The X402 Flow","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  AI Agent   \u2502  \u25001\u2500\u2192   \u2502  API Server  \u2502         \u2502 Blockchain \u2502\n\u2502   (Client)  \u2502         \u2502   (Server)   \u2502         \u2502  (Solana)  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n     \u2502                        \u2502                        \u2502\n     \u2502  GET /data             \u2502                        \u2502\n     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2192\u2502                        \u2502\n     \u2502                        \u2502                        \u2502\n     \u2502  402 Payment Required  \u2502                        \u2502\n     \u2502  + Payment Details     \u2502                        \u2502\n     \u2502\u2190\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524                        \u2502\n     \u2502                        \u2502                        \u2502\n     \u2502  Create &amp; Broadcast    \u2502                        \u2502\n     \u2502  Payment Transaction   \u2502                        \u2502\n     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2192\u2502\n     \u2502                        \u2502                        \u2502\n     \u2502                        \u2502   Verify Transaction   \u2502\n     \u2502                        \u2502\u2190\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n     \u2502                        \u2502                        \u2502\n     \u2502  GET /data             \u2502                        \u2502\n     \u2502  + Payment Auth Header \u2502                        \u2502\n     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2192\u2502                        \u2502\n     \u2502                        \u2502                        \u2502\n     \u2502  200 OK + Data         \u2502                        \u2502\n     \u2502\u2190\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524                        \u2502\n</code></pre>"},{"location":"go/#support","title":"Support","text":"<p>For issues, questions, or contributions: - GitHub Issues - GitHub Discussions - X402 Protocol</p>"},{"location":"go/#next-steps","title":"Next Steps","text":"<p>Start with the Installation guide and choose your path:</p> <ul> <li>Building a Server? \u2192 Server Quick Start</li> <li>Building a Client? \u2192 Client Quick Start</li> <li>Need Details? \u2192 API Reference</li> </ul>"},{"location":"go/examples/echo-server/","title":"Echo Server Example","text":"<p>Complete working example of an X402-enabled server using the Echo web framework.</p>"},{"location":"go/examples/echo-server/#overview","title":"Overview","text":"<p>This example demonstrates:</p> <ul> <li>Free and paid endpoints</li> <li>Multiple pricing tiers</li> <li>Dynamic pricing by URL parameter</li> <li>Payment verification and logging</li> <li>POST request handling with payment</li> </ul>"},{"location":"go/examples/echo-server/#running-the-example","title":"Running the Example","text":""},{"location":"go/examples/echo-server/#1-setup-environment","title":"1. Setup Environment","text":"<pre><code># Clone and navigate to example\ncd examples/go/echo-server\n\n# Set your Solana wallet\nexport X402_PAYMENT_ADDRESS=\"YOUR_SOLANA_WALLET_ADDRESS\"\nexport X402_TOKEN_MINT=\"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\"\nexport X402_NETWORK=\"solana-devnet\"\n</code></pre>"},{"location":"go/examples/echo-server/#2-install-dependencies","title":"2. Install Dependencies","text":"<pre><code>go mod tidy\n</code></pre>"},{"location":"go/examples/echo-server/#3-run-server","title":"3. Run Server","text":"<pre><code>go run main.go\n</code></pre> <p>Output: <pre><code>\ud83d\ude80 X402 Echo Server starting on port 8080\n\ud83d\udccd Network: solana-devnet\n\ud83d\udcb0 Payment Address: YOUR_WALLET_ADDRESS\n\ud83e\ude99 Token Mint: EPjFWdd5...\n\nAvailable endpoints:\n  GET  /api/free-data         - Free access (no payment)\n  GET  /api/premium-data      - $0.10 USDC\n  GET  /api/expensive-data    - $1.00 USDC\n  POST /api/process           - $0.50 USDC\n  GET  /api/tiered/:tier      - Dynamic pricing by tier\n</code></pre></p>"},{"location":"go/examples/echo-server/#4-test-endpoints","title":"4. Test Endpoints","text":"<p>Free endpoint (no payment needed): <pre><code>curl http://localhost:8080/api/free-data | jq\n</code></pre></p> <p>Response: <pre><code>{\n  \"message\": \"This is free public data\",\n  \"data\": {\n    \"timestamp\": \"2024-01-01T00:00:00Z\",\n    \"value\": \"basic information\"\n  }\n}\n</code></pre></p> <p>Premium endpoint (payment required): <pre><code>curl http://localhost:8080/api/premium-data\n</code></pre></p> <p>Response (402 Payment Required): <pre><code>{\n  \"max_amount_required\": \"0.10\",\n  \"asset_type\": \"SPL\",\n  \"asset_address\": \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\",\n  \"payment_address\": \"YOUR_WALLET_ADDRESS\",\n  \"network\": \"solana-devnet\",\n  \"expires_at\": \"2025-01-01T00:05:00Z\",\n  \"nonce\": \"abc123...\",\n  \"payment_id\": \"def456...\",\n  \"resource\": \"/api/premium-data\",\n  \"description\": \"Premium market data access\"\n}\n</code></pre></p> <p>Tiered endpoint with dynamic pricing: <pre><code># Basic tier ($0.05)\ncurl http://localhost:8080/api/tiered/basic\n\n# Standard tier ($0.10)\ncurl http://localhost:8080/api/tiered/standard\n\n# Premium tier ($0.25)\ncurl http://localhost:8080/api/tiered/premium\n\n# Ultimate tier ($1.00)\ncurl http://localhost:8080/api/tiered/ultimate\n</code></pre></p> <p>POST endpoint with data: <pre><code>curl -X POST -H \"Content-Type: application/json\" \\\n  -d '{\"data\": \"to process\"}' \\\n  http://localhost:8080/api/process\n</code></pre></p>"},{"location":"go/examples/echo-server/#server-code","title":"Server Code","text":"<p>The server (<code>main.go</code>) contains:</p>"},{"location":"go/examples/echo-server/#configuration","title":"Configuration","text":"<pre><code>echox402.InitX402(&amp;echox402.Config{\n    PaymentAddress: os.Getenv(\"X402_PAYMENT_ADDRESS\"),\n    TokenMint:      os.Getenv(\"X402_TOKEN_MINT\"),\n    Network:        \"solana-devnet\",\n    AutoVerify:     true,\n})\n</code></pre>"},{"location":"go/examples/echo-server/#endpoint-setup","title":"Endpoint Setup","text":"<pre><code>// Free endpoint\ne.GET(\"/api/free-data\", freeDataHandler)\n\n// Premium endpoints with different prices\ne.GET(\"/api/premium-data\", premiumDataHandler, echox402.PaymentRequired(echox402.PaymentRequiredOptions{\n    Amount:      \"0.10\",\n    Description: \"Premium market data access\",\n}))\n\n// Dynamic pricing by tier\ne.GET(\"/api/tiered/:tier\", tieredDataHandler)\n</code></pre>"},{"location":"go/examples/echo-server/#handler-examples","title":"Handler Examples","text":""},{"location":"go/examples/echo-server/#free-handler","title":"Free Handler","text":"<pre><code>func freeDataHandler(c echo.Context) error {\n    data := map[string]interface{}{\n        \"message\": \"This is free public data\",\n        \"data\": map[string]interface{}{\n            \"timestamp\": \"2024-01-01T00:00:00Z\",\n            \"value\":     \"basic information\",\n        },\n    }\n    return c.JSON(http.StatusOK, data)\n}\n</code></pre>"},{"location":"go/examples/echo-server/#premium-handler-with-payment-access","title":"Premium Handler (with Payment Access)","text":"<pre><code>func premiumDataHandler(c echo.Context) error {\n    // Access payment details if needed\n    auth := echox402.GetPaymentAuthorization(c)\n    if auth != nil {\n        log.Printf(\"\u2705 Payment received: %s USDC from %s\",\n            auth.ActualAmount, auth.PublicKey)\n    }\n\n    data := map[string]interface{}{\n        \"message\": \"This is premium data (paid $0.10)\",\n        \"data\": map[string]interface{}{\n            \"timestamp\": \"2024-01-01T00:00:00Z\",\n            \"value\":     \"premium market data\",\n            \"metrics\": map[string]interface{}{\n                \"price\":  42.50,\n                \"volume\": 1000000,\n                \"trend\":  \"bullish\",\n            },\n        },\n    }\n    return c.JSON(http.StatusOK, data)\n}\n</code></pre>"},{"location":"go/examples/echo-server/#post-handler-with-payment","title":"POST Handler with Payment","text":"<pre><code>func processHandler(c echo.Context) error {\n    auth := echox402.GetPaymentAuthorization(c)\n    if auth != nil {\n        log.Printf(\"\u2705 Payment received: %s USDC from %s\",\n            auth.ActualAmount, auth.PublicKey)\n    }\n\n    // Parse request body\n    var input map[string]interface{}\n    if err := c.Bind(&amp;input); err != nil {\n        return echo.NewHTTPError(http.StatusBadRequest, \"Invalid JSON\")\n    }\n\n    // Process the data\n    result := map[string]interface{}{\n        \"message\": \"Data processed successfully (paid $0.50)\",\n        \"input\":   input,\n        \"result\": map[string]interface{}{\n            \"processed\": true,\n            \"timestamp\": \"2024-01-01T00:00:00Z\",\n            \"output\":    \"Processed: \" + fmt.Sprint(input),\n        },\n    }\n    return c.JSON(http.StatusOK, result)\n}\n</code></pre>"},{"location":"go/examples/echo-server/#dynamic-pricing-handler","title":"Dynamic Pricing Handler","text":"<pre><code>func tieredDataHandler(c echo.Context) error {\n    tier := c.Param(\"tier\")\n\n    // Define pricing per tier\n    pricing := map[string]string{\n        \"basic\":    \"0.05\",\n        \"standard\": \"0.10\",\n        \"premium\":  \"0.25\",\n        \"ultimate\": \"1.00\",\n    }\n\n    amount, ok := pricing[tier]\n    if !ok {\n        return echo.NewHTTPError(http.StatusBadRequest, \"Invalid tier\")\n    }\n\n    // Apply payment middleware dynamically\n    paymentMiddleware := echox402.PaymentRequired(echox402.PaymentRequiredOptions{\n        Amount:      amount,\n        Description: fmt.Sprintf(\"Tiered data access - %s tier\", tier),\n    })\n\n    // Wrap handler with payment middleware\n    handler := paymentMiddleware(func(c echo.Context) error {\n        auth := echox402.GetPaymentAuthorization(c)\n        if auth != nil {\n            log.Printf(\"\u2705 Payment received: %s USDC from %s for %s tier\",\n                auth.ActualAmount, auth.PublicKey, tier)\n        }\n\n        data := map[string]interface{}{\n            \"message\": fmt.Sprintf(\"This is %s tier data (paid $%s)\", tier, amount),\n            \"tier\":    tier,\n            \"data\": map[string]interface{}{\n                \"timestamp\": \"2024-01-01T00:00:00Z\",\n                \"value\":     fmt.Sprintf(\"%s tier content\", tier),\n                \"quality\":   tier,\n            },\n        }\n        return c.JSON(http.StatusOK, data)\n    })\n\n    return handler(c)\n}\n</code></pre>"},{"location":"go/examples/echo-server/#client-example","title":"Client Example","text":""},{"location":"go/examples/echo-server/#automatic-payment","title":"Automatic Payment","text":"<p>The client automatically handles 402 responses:</p> <pre><code># Set your wallet private key\nexport X402_PRIVATE_KEY=\"your-base58-private-key\"\n\n# Run client\ngo run client_example.go\n</code></pre> <p>The client will: 1. Request protected endpoint 2. Receive 402 response 3. Parse payment request 4. Create payment transaction 5. Broadcast to Solana 6. Retry with payment authorization 7. Display response</p>"},{"location":"go/examples/echo-server/#auto-client-code","title":"Auto Client Code","text":"<pre><code>client := client.NewAutoClient(walletKeypair, \"\", &amp;client.AutoClientOptions{\n    MaxPaymentAmount: \"10.0\",\n    AutoRetry:        true,\n    AllowLocal:       true,\n})\ndefer client.Close()\n\n// Automatically handles payment\nresp, err := client.Get(context.Background(), \"http://localhost:8080/api/premium-data\")\n</code></pre>"},{"location":"go/examples/echo-server/#project-structure","title":"Project Structure","text":"<pre><code>echo-server/\n\u251c\u2500\u2500 main.go              # Server with multiple endpoints\n\u251c\u2500\u2500 go.mod              # Module definition\n\u2514\u2500\u2500 README.md           # This file\n</code></pre>"},{"location":"go/examples/echo-server/#endpoint-details","title":"Endpoint Details","text":""},{"location":"go/examples/echo-server/#apifree-data-free","title":"/api/free-data (Free)","text":"<p>No payment required. Returns basic data.</p> <pre><code>curl http://localhost:8080/api/free-data | jq\n</code></pre>"},{"location":"go/examples/echo-server/#apipremium-data-010","title":"/api/premium-data ($0.10)","text":"<p>Requires $0.10 USDC payment. Returns market data.</p> <pre><code># First request returns 402\ncurl http://localhost:8080/api/premium-data\n\n# After payment with auth header\ncurl -H \"X-Payment-Authorization: &lt;base64&gt;\" http://localhost:8080/api/premium-data\n</code></pre>"},{"location":"go/examples/echo-server/#apiexpensive-data-100","title":"/api/expensive-data ($1.00)","text":"<p>Requires $1.00 USDC payment. Returns exclusive insights.</p> <pre><code>curl http://localhost:8080/api/expensive-data\n</code></pre>"},{"location":"go/examples/echo-server/#apiprocess-050","title":"/api/process ($0.50)","text":"<p>POST endpoint requiring $0.50 USDC. Processes data.</p> <pre><code>curl -X POST -H \"Content-Type: application/json\" \\\n  -d '{\"data\": \"to process\"}' \\\n  http://localhost:8080/api/process\n</code></pre>"},{"location":"go/examples/echo-server/#apitieredtier-variable","title":"/api/tiered/:tier (Variable)","text":"<p>Dynamic pricing based on tier parameter: - <code>basic</code>: $0.05 - <code>standard</code>: $0.10 - <code>premium</code>: $0.25 - <code>ultimate</code>: $1.00</p> <pre><code>curl http://localhost:8080/api/tiered/premium\n</code></pre>"},{"location":"go/examples/echo-server/#configuration-options","title":"Configuration Options","text":""},{"location":"go/examples/echo-server/#environment-variables","title":"Environment Variables","text":"<pre><code># Required\nX402_PAYMENT_ADDRESS=\"YOUR_SOLANA_WALLET\"\nX402_TOKEN_MINT=\"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\"\n\n# Optional\nX402_NETWORK=\"solana-devnet\"  # or solana-mainnet\nX402_RPC_URL=\"https://api.devnet.solana.com\"\nPORT=8080\n</code></pre>"},{"location":"go/examples/echo-server/#per-endpoint-configuration","title":"Per-Endpoint Configuration","text":"<p>In <code>main.go</code>, modify the <code>PaymentRequiredOptions</code>:</p> <pre><code>echox402.PaymentRequired(echox402.PaymentRequiredOptions{\n    Amount:      \"0.10\",\n    Description: \"Custom description\",\n    ExpiresIn:   300,  // Seconds\n    AutoVerify:  true, // Verify on-chain\n})\n</code></pre>"},{"location":"go/examples/echo-server/#middleware-setup","title":"Middleware Setup","text":"<p>The example uses Echo's standard middleware:</p> <pre><code>// Request logging\ne.Use(middleware.Logger())\n\n// Panic recovery\ne.Use(middleware.Recover())\n\n// CORS support\ne.Use(middleware.CORS())\n</code></pre> <p>Add the X402 payment middleware on specific routes:</p> <pre><code>e.GET(\"/api/premium\", handler, echox402.PaymentRequired(opts))\n</code></pre>"},{"location":"go/examples/echo-server/#testing-locally","title":"Testing Locally","text":""},{"location":"go/examples/echo-server/#test-without-real-payments","title":"Test Without Real Payments","text":"<p>For development, test the payment flow without real transactions:</p> <ol> <li>Use devnet tokens (free from faucet)</li> <li>Set <code>AutoVerify: false</code> to skip on-chain verification</li> <li>Use client with <code>AllowLocal: true</code></li> </ol>"},{"location":"go/examples/echo-server/#mock-payment-response","title":"Mock Payment Response","text":"<p>For testing without a server:</p> <pre><code>// Simulate 402 response\nresp := &amp;http.Response{\n    StatusCode: http.StatusPaymentRequired,\n    Body:       io.NopCloser(bytes.NewBufferString(paymentJSON)),\n}\n\n// Test parsing\npaymentReq, err := client.ParsePaymentRequest(resp)\n</code></pre>"},{"location":"go/examples/echo-server/#production-considerations","title":"Production Considerations","text":""},{"location":"go/examples/echo-server/#1-use-mainnet","title":"1. Use Mainnet","text":"<p>Update environment: <pre><code>export X402_NETWORK=\"solana-mainnet\"\nexport X402_RPC_URL=\"https://api.mainnet-beta.solana.com\"\n</code></pre></p>"},{"location":"go/examples/echo-server/#2-enable-https","title":"2. Enable HTTPS","text":"<pre><code>e.StartTLS(\":443\", \"cert.pem\", \"key.pem\")\n</code></pre>"},{"location":"go/examples/echo-server/#3-add-rate-limiting","title":"3. Add Rate Limiting","text":"<pre><code>import \"golang.org/x/time/rate\"\n\nvar limiter = rate.NewLimiter(100, 10)\n\nfunc rateLimited(next echo.HandlerFunc) echo.HandlerFunc {\n    return func(c echo.Context) error {\n        if !limiter.Allow() {\n            return echo.NewHTTPError(http.StatusTooManyRequests, \"Rate limited\")\n        }\n        return next(c)\n    }\n}\n\ne.Use(rateLimited)\n</code></pre>"},{"location":"go/examples/echo-server/#4-add-logging","title":"4. Add Logging","text":"<pre><code>e.Use(middleware.LoggerWithConfig(middleware.LoggerConfig{\n    Format: \"[${time_rfc3339}] ${status} ${method} ${path}\\n\",\n}))\n</code></pre>"},{"location":"go/examples/echo-server/#5-monitor-payments","title":"5. Monitor Payments","text":"<pre><code>func logPayment(auth *core.PaymentAuthorization) {\n    log.Printf(\"[PAYMENT] ID:%s Amount:%s Payer:%s TX:%s\",\n        auth.PaymentID,\n        auth.ActualAmount,\n        auth.PublicKey[:8],\n        auth.TransactionHash[:8])\n}\n</code></pre>"},{"location":"go/examples/echo-server/#6-graceful-shutdown","title":"6. Graceful Shutdown","text":"<pre><code>import \"os/signal\"\n\ngo func() {\n    if err := e.Start(\":8080\"); err != nil {\n        e.Logger.Info(\"shutting down:\", err)\n    }\n}()\n\nquit := make(chan os.Signal, 1)\nsignal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)\n&lt;-quit\n\nctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\ndefer cancel()\nif err := e.Shutdown(ctx); err != nil {\n    e.Logger.Fatal(err)\n}\n</code></pre>"},{"location":"go/examples/echo-server/#troubleshooting","title":"Troubleshooting","text":""},{"location":"go/examples/echo-server/#402-responses-even-after-payment","title":"402 responses even after payment","text":"<ul> <li>Check payment amount matches exactly</li> <li>Verify payment address is correct</li> <li>Ensure RPC endpoint is accessible</li> <li>Check network configuration (devnet vs mainnet)</li> </ul>"},{"location":"go/examples/echo-server/#server-wont-start","title":"Server won't start","text":"<ul> <li>Check port is available: <code>lsof -i :8080</code></li> <li>Verify environment variables are set</li> <li>Ensure dependencies are installed: <code>go mod tidy</code></li> </ul>"},{"location":"go/examples/echo-server/#payment-verification-failures","title":"Payment verification failures","text":"<ul> <li>Disable <code>AutoVerify: false</code> temporarily for testing</li> <li>Check Solana network is operational</li> <li>Verify RPC endpoint is responding</li> </ul>"},{"location":"go/examples/echo-server/#echo-context-issues","title":"Echo context issues","text":"<ul> <li>Ensure payment middleware is added to route definition</li> <li>Payment middleware must be called after route handler is defined</li> <li>Use <code>echox402.GetPaymentAuthorization(c)</code> to access payment in handler</li> </ul>"},{"location":"go/examples/echo-server/#extended-examples","title":"Extended Examples","text":""},{"location":"go/examples/echo-server/#route-groups-with-different-tiers","title":"Route Groups with Different Tiers","text":"<pre><code>// Free tier\nfree := e.Group(\"/api/free\")\nfree.GET(\"/data\", freeDataHandler)\n\n// Premium tier\npremium := e.Group(\"/api/premium\", echox402.PaymentRequired(echox402.PaymentRequiredOptions{\n    Amount: \"0.10\",\n}))\npremium.GET(\"/data\", premiumDataHandler)\npremium.POST(\"/export\", exportHandler)\n\n// Enterprise tier\nenterprise := e.Group(\"/api/enterprise\", echox402.PaymentRequired(echox402.PaymentRequiredOptions{\n    Amount: \"5.00\",\n}))\nenterprise.GET(\"/analytics\", analyticsHandler)\nenterprise.GET(\"/export\", enterpriseExportHandler)\n</code></pre>"},{"location":"go/examples/echo-server/#subscription-based-access","title":"Subscription-Based Access","text":"<p>Track payments and allow multiple requests:</p> <pre><code>type Subscription struct {\n    Address    string\n    PaidUntil  time.Time\n    Requests   int\n}\n\nfunc checkSubscription(auth *core.PaymentAuthorization) bool {\n    // Check if payer has active subscription\n    return true\n}\n</code></pre>"},{"location":"go/examples/echo-server/#custom-error-responses","title":"Custom Error Responses","text":"<pre><code>e.HTTPErrorHandler = func(err error, c echo.Context) {\n    code := http.StatusInternalServerError\n    message := \"Internal Server Error\"\n\n    if he, ok := err.(*echo.HTTPError); ok {\n        code = he.Code\n        message = fmt.Sprint(he.Message)\n    }\n\n    c.JSON(code, map[string]interface{}{\n        \"error\": message,\n    })\n}\n</code></pre>"},{"location":"go/examples/echo-server/#see-also","title":"See Also","text":"<ul> <li>net/http Server Example</li> <li>Echo Middleware Docs</li> <li>Server Quick Start</li> <li>Client Library Docs</li> </ul>"},{"location":"go/examples/nethttp-server/","title":"net/http Server Example","text":"<p>Complete working example of an X402-enabled server using Go's standard <code>net/http</code> package.</p>"},{"location":"go/examples/nethttp-server/#overview","title":"Overview","text":"<p>This example demonstrates:</p> <ul> <li>Free and paid endpoints</li> <li>Multiple pricing tiers</li> <li>Payment verification</li> <li>Processing payment details in handlers</li> </ul>"},{"location":"go/examples/nethttp-server/#running-the-example","title":"Running the Example","text":""},{"location":"go/examples/nethttp-server/#1-setup-environment","title":"1. Setup Environment","text":"<pre><code># Clone and navigate to example\ncd examples/go/nethttp-server\n\n# Set your Solana wallet\nexport X402_PAYMENT_ADDRESS=\"YOUR_SOLANA_WALLET_ADDRESS\"\nexport X402_TOKEN_MINT=\"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\"\nexport X402_NETWORK=\"solana-devnet\"\n</code></pre>"},{"location":"go/examples/nethttp-server/#2-install-dependencies","title":"2. Install Dependencies","text":"<pre><code>go mod tidy\n</code></pre>"},{"location":"go/examples/nethttp-server/#3-run-server","title":"3. Run Server","text":"<pre><code>go run main.go\n</code></pre> <p>Output: <pre><code>\ud83d\ude80 X402 Server starting on port 8080\n\ud83d\udccd Network: solana-devnet\n\ud83d\udcb0 Payment Address: YOUR_WALLET_ADDRESS\n\ud83e\ude99 Token Mint: EPjFWdd5...\n\nAvailable endpoints:\n  GET  /api/free-data       - Free access (no payment)\n  GET  /api/premium-data    - $0.10 USDC\n  GET  /api/expensive-data  - $1.00 USDC\n  POST /api/process         - $0.50 USDC\n</code></pre></p>"},{"location":"go/examples/nethttp-server/#4-test-endpoints","title":"4. Test Endpoints","text":"<p>Free endpoint (no payment needed): <pre><code>curl http://localhost:8080/api/free-data\n</code></pre></p> <p>Response: <pre><code>{\n  \"message\": \"This is free public data\",\n  \"data\": {\n    \"timestamp\": \"2024-01-01T00:00:00Z\",\n    \"value\": \"basic information\"\n  }\n}\n</code></pre></p> <p>Premium endpoint (payment required): <pre><code>curl http://localhost:8080/api/premium-data\n</code></pre></p> <p>Response (402 Payment Required): <pre><code>{\n  \"max_amount_required\": \"0.10\",\n  \"asset_type\": \"SPL\",\n  \"asset_address\": \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\",\n  \"payment_address\": \"YOUR_WALLET_ADDRESS\",\n  \"network\": \"solana-devnet\",\n  \"expires_at\": \"2025-01-01T00:05:00Z\",\n  \"nonce\": \"abc123...\",\n  \"payment_id\": \"def456...\",\n  \"resource\": \"/api/premium-data\",\n  \"description\": \"Premium market data access\"\n}\n</code></pre></p>"},{"location":"go/examples/nethttp-server/#server-code","title":"Server Code","text":"<p>The server (<code>main.go</code>) contains:</p>"},{"location":"go/examples/nethttp-server/#configuration","title":"Configuration","text":"<pre><code>nethttp.InitX402(&amp;nethttp.Config{\n    PaymentAddress: os.Getenv(\"X402_PAYMENT_ADDRESS\"),\n    TokenMint:      os.Getenv(\"X402_TOKEN_MINT\"),\n    Network:        \"solana-devnet\",\n    AutoVerify:     true,\n})\n</code></pre>"},{"location":"go/examples/nethttp-server/#endpoint-setup","title":"Endpoint Setup","text":"<pre><code>// Free endpoint\nmux.HandleFunc(\"/api/free-data\", freeDataHandler)\n\n// Premium endpoints with different prices\nmux.Handle(\"/api/premium-data\", nethttp.PaymentRequired(nethttp.PaymentRequiredOptions{\n    Amount:      \"0.10\",\n    Description: \"Premium market data access\",\n})(http.HandlerFunc(premiumDataHandler)))\n</code></pre>"},{"location":"go/examples/nethttp-server/#client-example","title":"Client Example","text":""},{"location":"go/examples/nethttp-server/#automatic-payment","title":"Automatic Payment","text":"<p>The <code>client_example.go</code> shows automatic payment:</p> <pre><code># Set your wallet private key\nexport X402_PRIVATE_KEY=\"your-base58-private-key\"\n\n# Run client\ngo run client_example.go\n</code></pre> <p>The client will: 1. Request protected endpoint 2. Receive 402 response 3. Parse payment request 4. Create payment transaction 5. Broadcast to Solana 6. Retry with payment authorization 7. Display response</p>"},{"location":"go/examples/nethttp-server/#auto-client-code","title":"Auto Client Code","text":"<pre><code>client := client.NewAutoClient(walletKeypair, \"\", &amp;client.AutoClientOptions{\n    MaxPaymentAmount: \"10.0\",\n    AutoRetry:        true,\n    AllowLocal:       true,\n})\ndefer client.Close()\n\n// Automatically handles payment\nresp, err := client.Get(context.Background(), \"http://localhost:8080/api/premium-data\")\n</code></pre>"},{"location":"go/examples/nethttp-server/#explicit-client-code","title":"Explicit Client Code","text":"<pre><code>// Manual payment control\nclient := client.NewX402Client(walletKeypair, \"\", nil, true)\ndefer client.Close()\n\nresp, err := client.Get(ctx, url, nil)\n\nif client.PaymentRequired(resp) {\n    paymentReq, _ := client.ParsePaymentRequest(resp)\n    auth, _ := client.CreatePayment(ctx, paymentReq, \"\")\n    resp, _ = client.Get(ctx, url, auth)\n}\n</code></pre>"},{"location":"go/examples/nethttp-server/#project-structure","title":"Project Structure","text":"<pre><code>nethttp-server/\n\u251c\u2500\u2500 main.go              # Server with multiple endpoints\n\u251c\u2500\u2500 client_example.go    # Example clients (auto and explicit)\n\u251c\u2500\u2500 go.mod              # Module definition\n\u2514\u2500\u2500 README.md           # This file\n</code></pre>"},{"location":"go/examples/nethttp-server/#endpoint-details","title":"Endpoint Details","text":""},{"location":"go/examples/nethttp-server/#apifree-data-free","title":"/api/free-data (Free)","text":"<p>No payment required. Returns basic data.</p> <pre><code>curl http://localhost:8080/api/free-data | jq\n</code></pre>"},{"location":"go/examples/nethttp-server/#apipremium-data-010","title":"/api/premium-data ($0.10)","text":"<p>Requires $0.10 USDC payment. Returns market data.</p> <pre><code># First request returns 402\ncurl http://localhost:8080/api/premium-data\n\n# After payment with auth header\ncurl -H \"X-Payment-Authorization: &lt;base64&gt;\" http://localhost:8080/api/premium-data\n</code></pre>"},{"location":"go/examples/nethttp-server/#apiexpensive-data-100","title":"/api/expensive-data ($1.00)","text":"<p>Requires $1.00 USDC payment. Returns exclusive insights.</p> <pre><code>curl http://localhost:8080/api/expensive-data\n</code></pre>"},{"location":"go/examples/nethttp-server/#apiprocess-050","title":"/api/process ($0.50)","text":"<p>POST endpoint requiring $0.50 USDC. Processes data.</p> <pre><code>curl -X POST -H \"Content-Type: application/json\" \\\n  -d '{\"data\": \"to process\"}' \\\n  http://localhost:8080/api/process\n</code></pre>"},{"location":"go/examples/nethttp-server/#handler-examples","title":"Handler Examples","text":""},{"location":"go/examples/nethttp-server/#free-handler","title":"Free Handler","text":"<pre><code>func freeDataHandler(w http.ResponseWriter, r *http.Request) {\n    data := map[string]interface{}{\n        \"message\": \"This is free public data\",\n        \"data\": map[string]interface{}{\n            \"timestamp\": \"2024-01-01T00:00:00Z\",\n            \"value\":     \"basic information\",\n        },\n    }\n    respondJSON(w, http.StatusOK, data)\n}\n</code></pre>"},{"location":"go/examples/nethttp-server/#premium-handler-with-payment-access","title":"Premium Handler (with Payment Access)","text":"<pre><code>func premiumDataHandler(w http.ResponseWriter, r *http.Request) {\n    // Access payment details if needed\n    auth := nethttp.GetPaymentAuthorization(r)\n    if auth != nil {\n        log.Printf(\"\u2705 Payment received: %s USDC from %s\",\n            auth.ActualAmount, auth.PublicKey)\n    }\n\n    data := map[string]interface{}{\n        \"message\": \"This is premium data (paid $0.10)\",\n        \"data\": map[string]interface{}{\n            \"timestamp\": \"2024-01-01T00:00:00Z\",\n            \"value\":     \"premium market data\",\n            \"metrics\": map[string]interface{}{\n                \"price\":  42.50,\n                \"volume\": 1000000,\n                \"trend\":  \"bullish\",\n            },\n        },\n    }\n    respondJSON(w, http.StatusOK, data)\n}\n</code></pre>"},{"location":"go/examples/nethttp-server/#configuration-options","title":"Configuration Options","text":""},{"location":"go/examples/nethttp-server/#environment-variables","title":"Environment Variables","text":"<pre><code># Required\nX402_PAYMENT_ADDRESS=\"YOUR_SOLANA_WALLET\"\nX402_TOKEN_MINT=\"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\"\n\n# Optional\nX402_NETWORK=\"solana-devnet\"  # or solana-mainnet\nX402_RPC_URL=\"https://api.devnet.solana.com\"\nPORT=8080\n</code></pre>"},{"location":"go/examples/nethttp-server/#per-endpoint-configuration","title":"Per-Endpoint Configuration","text":"<p>In <code>main.go</code>, modify the <code>PaymentRequiredOptions</code>:</p> <pre><code>nethttp.PaymentRequired(nethttp.PaymentRequiredOptions{\n    Amount:      \"0.10\",\n    Description: \"Custom description\",\n    ExpiresIn:   300,  // Seconds\n    AutoVerify:  true, // Verify on-chain\n})\n</code></pre>"},{"location":"go/examples/nethttp-server/#testing-locally","title":"Testing Locally","text":""},{"location":"go/examples/nethttp-server/#test-without-real-payments","title":"Test Without Real Payments","text":"<p>For development, you can test the payment flow without real transactions:</p> <ol> <li>Use devnet tokens (free from faucet)</li> <li>Set <code>AutoVerify: false</code> to skip on-chain verification</li> <li>Use client with <code>AllowLocal: true</code></li> </ol>"},{"location":"go/examples/nethttp-server/#mock-payment-response","title":"Mock Payment Response","text":"<p>For testing without a server:</p> <pre><code>// Simulate 402 response\nresp := &amp;http.Response{\n    StatusCode: http.StatusPaymentRequired,\n    Body:       io.NopCloser(bytes.NewBufferString(paymentJSON)),\n}\n\n// Test parsing\npaymentReq, err := client.ParsePaymentRequest(resp)\n</code></pre>"},{"location":"go/examples/nethttp-server/#production-considerations","title":"Production Considerations","text":""},{"location":"go/examples/nethttp-server/#1-use-mainnet","title":"1. Use Mainnet","text":"<p>Update environment: <pre><code>export X402_NETWORK=\"solana-mainnet\"\nexport X402_RPC_URL=\"https://api.mainnet-beta.solana.com\"\n</code></pre></p>"},{"location":"go/examples/nethttp-server/#2-enable-https","title":"2. Enable HTTPS","text":"<pre><code>err := http.ListenAndServeTLS(\":443\", \"cert.pem\", \"key.pem\", mux)\n</code></pre>"},{"location":"go/examples/nethttp-server/#3-add-rate-limiting","title":"3. Add Rate Limiting","text":"<pre><code>import \"golang.org/x/time/rate\"\n\nvar limiter = rate.NewLimiter(100, 10)\n\nfunc rateLimited(h http.HandlerFunc) http.HandlerFunc {\n    return func(w http.ResponseWriter, r *http.Request) {\n        if !limiter.Allow() {\n            http.Error(w, \"Too many requests\", http.StatusTooManyRequests)\n            return\n        }\n        h(w, r)\n    }\n}\n\nmux.Handle(\"/api/premium\", rateLimited(premiumHandler))\n</code></pre>"},{"location":"go/examples/nethttp-server/#4-add-logging","title":"4. Add Logging","text":"<pre><code>import \"log\"\n\nfunc logRequest(handler http.HandlerFunc) http.HandlerFunc {\n    return func(w http.ResponseWriter, r *http.Request) {\n        log.Printf(\"%s %s\", r.Method, r.URL.Path)\n        handler(w, r)\n    }\n}\n</code></pre>"},{"location":"go/examples/nethttp-server/#5-monitor-payments","title":"5. Monitor Payments","text":"<pre><code>func logPayment(auth *core.PaymentAuthorization) {\n    log.Printf(\"[PAYMENT] ID:%s Amount:%s Payer:%s TX:%s\",\n        auth.PaymentID,\n        auth.ActualAmount,\n        auth.PublicKey[:8],\n        auth.TransactionHash[:8])\n}\n</code></pre>"},{"location":"go/examples/nethttp-server/#troubleshooting","title":"Troubleshooting","text":""},{"location":"go/examples/nethttp-server/#402-responses-even-after-payment","title":"402 responses even after payment","text":"<ul> <li>Check payment amount matches exactly</li> <li>Verify payment address is correct</li> <li>Ensure RPC endpoint is accessible</li> <li>Check network configuration (devnet vs mainnet)</li> </ul>"},{"location":"go/examples/nethttp-server/#client-connection-refused","title":"Client connection refused","text":"<ul> <li>Ensure server is running: <code>go run main.go</code></li> <li>Check port is correct: <code>lsof -i :8080</code></li> <li>Verify localhost is accessible</li> </ul>"},{"location":"go/examples/nethttp-server/#payment-verification-failures","title":"Payment verification failures","text":"<ul> <li>Disable <code>AutoVerify: false</code> temporarily for testing</li> <li>Check Solana network is operational</li> <li>Verify RPC endpoint is responding</li> </ul>"},{"location":"go/examples/nethttp-server/#extended-examples","title":"Extended Examples","text":""},{"location":"go/examples/nethttp-server/#dynamic-pricing","title":"Dynamic Pricing","text":"<p>Modify the endpoint setup:</p> <pre><code>func getPriceTier(endpoint string) string {\n    switch endpoint {\n    case \"/api/basic\":\n        return \"0.05\"\n    case \"/api/premium\":\n        return \"0.10\"\n    case \"/api/ultimate\":\n        return \"1.00\"\n    default:\n        return \"0.05\"\n    }\n}\n</code></pre>"},{"location":"go/examples/nethttp-server/#subscription-based","title":"Subscription-Based","text":"<p>Track payments and allow multiple requests:</p> <pre><code>type Subscription struct {\n    Address    string\n    PaidUntil  time.Time\n    Requests   int\n}\n\nfunc checkSubscription(auth *core.PaymentAuthorization) bool {\n    // Check if payer has active subscription\n    return true\n}\n</code></pre>"},{"location":"go/examples/nethttp-server/#see-also","title":"See Also","text":"<ul> <li>Echo Server Example</li> <li>Server Quick Start</li> <li>net/http Middleware Docs</li> <li>Client Library Docs</li> </ul>"},{"location":"go/getting-started/client-quickstart/","title":"Client Quick Start","text":"<p>Build a client that automatically pays for API access in minutes.</p>"},{"location":"go/getting-started/client-quickstart/#5-minute-auto-paying-client","title":"5-Minute Auto-Paying Client","text":""},{"location":"go/getting-started/client-quickstart/#step-1-initialize-your-project","title":"Step 1: Initialize Your Project","text":"<pre><code>mkdir x402-client\ncd x402-client\ngo mod init github.com/yourname/x402-client\n</code></pre>"},{"location":"go/getting-started/client-quickstart/#step-2-install-dependencies","title":"Step 2: Install Dependencies","text":"<pre><code>go get github.com/openlibx402/go/openlibx402-client\ngo get github.com/gagliardetto/solana-go\n</code></pre>"},{"location":"go/getting-started/client-quickstart/#step-3-create-your-client","title":"Step 3: Create Your Client","text":"<p>Create <code>main.go</code>:</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"io\"\n    \"log\"\n    \"os\"\n\n    \"github.com/gagliardetto/solana-go\"\n    \"github.com/mr-tron/base58\"\n    \"github.com/openlibx402/go/openlibx402-client\"\n)\n\nfunc main() {\n    // Load wallet from environment\n    privateKeyStr := os.Getenv(\"X402_PRIVATE_KEY\")\n    if privateKeyStr == \"\" {\n        log.Fatal(\"X402_PRIVATE_KEY not set\")\n    }\n\n    // Decode private key\n    privateKeyBytes := base58.Decode(privateKeyStr)\n    walletKeypair := solana.PrivateKey(privateKeyBytes)\n\n    // Create auto client (automatically handles 402 and pays)\n    client := client.NewAutoClient(walletKeypair, \"\", &amp;client.AutoClientOptions{\n        MaxPaymentAmount: \"10.0\",  // Safety limit\n        AutoRetry:        true,    // Auto-pay on 402\n    })\n    defer client.Close()\n\n    ctx := context.Background()\n\n    // Access premium endpoint (automatically pays if needed)\n    log.Println(\"Accessing premium endpoint...\")\n    resp, err := client.Get(ctx, \"https://api.example.com/api/premium\")\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer resp.Body.Close()\n\n    // Read response\n    data, _ := io.ReadAll(resp.Body)\n    log.Printf(\"Response: %s\", string(data))\n}\n</code></pre>"},{"location":"go/getting-started/client-quickstart/#step-4-get-your-wallet-private-key","title":"Step 4: Get Your Wallet Private Key","text":"<pre><code># If you have a Solana wallet file\nsolana-keygen show --private-key\n\n# Output will be base58 encoded private key\n# Export it\nexport X402_PRIVATE_KEY=\"your-base58-private-key\"\n</code></pre>"},{"location":"go/getting-started/client-quickstart/#step-5-run-your-client","title":"Step 5: Run Your Client","text":"<pre><code>export X402_PRIVATE_KEY=\"your-private-key-here\"\ngo run main.go\n</code></pre>"},{"location":"go/getting-started/client-quickstart/#explicit-control-mode","title":"Explicit Control Mode","text":"<p>For applications needing fine-grained control:</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"io\"\n    \"log\"\n\n    \"github.com/gagliardetto/solana-go\"\n    \"github.com/openlibx402/go/openlibx402-client\"\n)\n\nfunc main() {\n    walletKeypair := solana.NewWallet().PrivateKey\n\n    // Create explicit client (manual control)\n    client := client.NewX402Client(walletKeypair, \"\", nil, false)\n    defer client.Close()\n\n    ctx := context.Background()\n\n    // Step 1: Make initial request\n    log.Println(\"Making request...\")\n    resp, err := client.Get(ctx, \"https://api.example.com/premium\", nil)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Step 2: Check if payment required\n    if client.PaymentRequired(resp) {\n        log.Println(\"Payment required!\")\n\n        // Step 3: Parse payment request\n        paymentReq, err := client.ParsePaymentRequest(resp)\n        if err != nil {\n            log.Fatal(err)\n        }\n\n        log.Printf(\"Amount: %s USDC\", paymentReq.MaxAmountRequired)\n\n        // Step 4: User confirmation (optional)\n        if !userConfirms() {\n            log.Fatal(\"Payment declined\")\n        }\n\n        // Step 5: Create and broadcast payment\n        log.Println(\"Creating payment...\")\n        auth, err := client.CreatePayment(ctx, paymentReq, \"\")\n        if err != nil {\n            log.Fatal(err)\n        }\n\n        log.Printf(\"Payment sent: %s\", auth.TransactionHash)\n\n        // Step 6: Retry with payment\n        log.Println(\"Retrying with payment...\")\n        resp, err = client.Get(ctx, \"https://api.example.com/premium\", auth)\n        if err != nil {\n            log.Fatal(err)\n        }\n    }\n\n    // Step 7: Process response\n    data, _ := io.ReadAll(resp.Body)\n    resp.Body.Close()\n    log.Printf(\"Data: %s\", string(data))\n}\n\nfunc userConfirms() bool {\n    // Implement your confirmation logic\n    return true\n}\n</code></pre>"},{"location":"go/getting-started/client-quickstart/#postputdelete-requests","title":"POST/PUT/DELETE Requests","text":"<pre><code>// POST request\ndata := []byte(`{\"name\": \"value\"}`)\nresp, err := client.Post(ctx, \"https://api.example.com/data\", data)\n\n// PUT request\nresp, err := client.Put(ctx, \"https://api.example.com/data\", data)\n\n// DELETE request\nresp, err := client.Delete(ctx, \"https://api.example.com/data\")\n</code></pre>"},{"location":"go/getting-started/client-quickstart/#error-handling","title":"Error Handling","text":"<pre><code>import \"github.com/openlibx402/go/openlibx402-core\"\n\nresp, err := client.Get(ctx, url)\nif err != nil {\n    switch err := err.(type) {\n    case *core.PaymentExpiredError:\n        log.Println(\"Payment request expired\")\n    case *core.InsufficientFundsError:\n        log.Printf(\"Need: %s, Have: %s\",\n            err.RequiredAmount,\n            err.AvailableAmount)\n    case *core.PaymentVerificationError:\n        log.Println(\"Payment verification failed\")\n    default:\n        log.Println(\"Other error:\", err)\n    }\n}\n</code></pre>"},{"location":"go/getting-started/client-quickstart/#accessing-payment-details","title":"Accessing Payment Details","text":"<pre><code>auth, err := client.CreatePayment(ctx, paymentReq, \"\")\nif err != nil {\n    log.Fatal(err)\n}\n\nlog.Printf(\"Payment ID: %s\", auth.PaymentID)\nlog.Printf(\"Amount: %s\", auth.ActualAmount)\nlog.Printf(\"Payment Address: %s\", auth.PaymentAddress)\nlog.Printf(\"Network: %s\", auth.Network)\nlog.Printf(\"Signature: %s\", auth.Signature)\nlog.Printf(\"Transaction: %s\", auth.TransactionHash)\n</code></pre>"},{"location":"go/getting-started/client-quickstart/#auto-client-options","title":"Auto Client Options","text":"<pre><code>client := client.NewAutoClient(walletKeypair, rpcURL, &amp;client.AutoClientOptions{\n    MaxPaymentAmount: \"10.0\",   // Safety limit - reject payments over this\n    AutoRetry:        true,     // Auto-retry on 402 with payment\n    AllowLocal:       false,    // Allow localhost URLs (dev only!)\n})\n</code></pre>"},{"location":"go/getting-started/client-quickstart/#handling-multiple-payment-types","title":"Handling Multiple Payment Types","text":"<pre><code>// Different endpoints with different pricing\nendpoints := map[string]string{\n    \"basic\":    \"https://api.example.com/basic\",\n    \"premium\":  \"https://api.example.com/premium\",\n    \"ultimate\": \"https://api.example.com/ultimate\",\n}\n\nfor name, endpoint := range endpoints {\n    log.Printf(\"Accessing %s endpoint...\", name)\n    resp, err := client.Get(ctx, endpoint)\n    if err != nil {\n        log.Printf(\"Error accessing %s: %v\", name, err)\n        continue\n    }\n\n    data, _ := io.ReadAll(resp.Body)\n    resp.Body.Close()\n    log.Printf(\"%s response: %s\", name, string(data))\n}\n</code></pre>"},{"location":"go/getting-started/client-quickstart/#testing-with-local-server","title":"Testing with Local Server","text":"<p>For local development, enable local URLs:</p> <pre><code>// Development: allow localhost\nclient := client.NewAutoClient(walletKeypair, \"\", &amp;client.AutoClientOptions{\n    AllowLocal: true,  // Enable for http://localhost:8080\n})\n\nresp, err := client.Get(ctx, \"http://localhost:8080/api/premium\")\n</code></pre>"},{"location":"go/getting-started/client-quickstart/#configuration","title":"Configuration","text":"<pre><code>// Custom RPC endpoint\nrpcURL := \"https://api.mainnet-beta.solana.com\"\nclient := client.NewAutoClient(walletKeypair, rpcURL, nil)\n\n// Custom options\nclient := client.NewAutoClient(walletKeypair, rpcURL, &amp;client.AutoClientOptions{\n    MaxPaymentAmount: \"100.0\",  // Higher limit for expensive APIs\n    AutoRetry:        true,\n    AllowLocal:       false,\n})\n</code></pre>"},{"location":"go/getting-started/client-quickstart/#safety-best-practices","title":"Safety Best Practices","text":"<pre><code>// \u2705 Good: Always use payment limit\nclient := client.NewAutoClient(walletKeypair, \"\", &amp;client.AutoClientOptions{\n    MaxPaymentAmount: \"10.0\",  // Prevent accidental overpayment\n})\n\n// \u2705 Good: Always close\ndefer client.Close()\n\n// \u2705 Good: Use context with timeout\nctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)\ndefer cancel()\n\n// \u274c Bad: No safety limits\nclient := client.NewAutoClient(walletKeypair, \"\", nil)\n\n// \u274c Bad: AllowLocal in production\nclient := client.NewAutoClient(walletKeypair, \"\", &amp;client.AutoClientOptions{\n    AllowLocal: true,  // Only for development!\n})\n</code></pre>"},{"location":"go/getting-started/client-quickstart/#rate-limiting-payments","title":"Rate Limiting Payments","text":"<pre><code>// Track payments to avoid excessive spending\ntype PaymentTracker struct {\n    totalSpent float64\n    maxSpend   float64\n}\n\nfunc (pt *PaymentTracker) canPay(amount string) bool {\n    amountFloat, _ := strconv.ParseFloat(amount, 64)\n    return (pt.totalSpent + amountFloat) &lt;= pt.maxSpend\n}\n\n// Usage\ntracker := &amp;PaymentTracker{\n    totalSpent: 0,\n    maxSpend:   10.0,\n}\n\nresp, err := client.Get(ctx, url)\nif err != nil {\n    if paymentErr, ok := err.(*core.PaymentRequiredError); ok {\n        if !tracker.canPay(paymentErr.PaymentRequest.MaxAmountRequired) {\n            log.Fatal(\"Would exceed spending limit\")\n        }\n    }\n}\n</code></pre>"},{"location":"go/getting-started/client-quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Full Example: See net/http Client Example</li> <li>Error Handling: Error Reference</li> <li>API Details: Client Library Documentation</li> <li>Building a Server: Server Quick Start</li> </ul>"},{"location":"go/getting-started/client-quickstart/#support","title":"Support","text":"<ul> <li>Client Library Docs</li> <li>API Reference</li> <li>Error Handling</li> </ul>"},{"location":"go/getting-started/installation/","title":"Installation","text":"<p>Get started with OpenLibx402 Go packages in minutes.</p>"},{"location":"go/getting-started/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Go: 1.21 or later</li> <li>Solana Wallet: For testing (testnet/devnet tokens recommended)</li> <li>Git: For cloning the repository</li> </ul>"},{"location":"go/getting-started/installation/#package-installation","title":"Package Installation","text":""},{"location":"go/getting-started/installation/#option-1-using-go-get-recommended-for-users","title":"Option 1: Using <code>go get</code> (Recommended for Users)","text":"<p>Install the packages you need:</p> <pre><code># Core protocol (required)\ngo get github.com/openlibx402/go/openlibx402-core\n\n# Client for consuming APIs\ngo get github.com/openlibx402/go/openlibx402-client\n\n# Middleware for your framework\ngo get github.com/openlibx402/go/openlibx402-nethttp\n# or\ngo get github.com/openlibx402/go/openlibx402-echo\n</code></pre>"},{"location":"go/getting-started/installation/#option-2-development-installation-for-contributors","title":"Option 2: Development Installation (for Contributors)","text":"<pre><code># Clone the repository\ngit clone https://github.com/openlibx402/openlibx402.git\ncd openlibx402\n\n# Navigate to a package\ncd packages/go/openlibx402-core\n\n# Install dependencies\ngo mod tidy\n\n# Build and test\ngo build\ngo test ./...\n</code></pre>"},{"location":"go/getting-started/installation/#verifying-installation","title":"Verifying Installation","text":""},{"location":"go/getting-started/installation/#verify-with-go","title":"Verify with Go","text":"<pre><code>go list -m github.com/openlibx402/go/openlibx402-core\n</code></pre> <p>Output should show: <pre><code>github.com/openlibx402/go/openlibx402-core v0.1.0\n</code></pre></p>"},{"location":"go/getting-started/installation/#verify-with-pkggodev","title":"Verify with pkg.go.dev","text":"<p>Visit: https://pkg.go.dev/github.com/openlibx402/go/openlibx402-core</p>"},{"location":"go/getting-started/installation/#import-statements","title":"Import Statements","text":"<p>Once installed, you can import in your code:</p> <pre><code>package main\n\nimport (\n    \"github.com/openlibx402/go/openlibx402-core\"\n    \"github.com/openlibx402/go/openlibx402-client\"\n)\n</code></pre> <p>Or with aliases:</p> <pre><code>import (\n    nethttp \"github.com/openlibx402/go/openlibx402-nethttp\"\n    echox402 \"github.com/openlibx402/go/openlibx402-echo\"\n)\n</code></pre>"},{"location":"go/getting-started/installation/#environment-setup","title":"Environment Setup","text":""},{"location":"go/getting-started/installation/#for-server-development","title":"For Server Development","text":"<p>Create a <code>.env</code> file:</p> <pre><code># Your Solana wallet address\nX402_PAYMENT_ADDRESS=\"YOUR_SOLANA_WALLET_ADDRESS\"\n\n# USDC token mint (devnet: EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v)\nX402_TOKEN_MINT=\"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\"\n\n# Network (solana-devnet, solana-mainnet)\nX402_NETWORK=\"solana-devnet\"\n\n# RPC endpoint\nX402_RPC_URL=\"https://api.devnet.solana.com\"\n\n# Server port\nPORT=8080\n</code></pre> <p>Load in your code:</p> <pre><code>import \"os\"\n\npaymentAddress := os.Getenv(\"X402_PAYMENT_ADDRESS\")\ntokenMint := os.Getenv(\"X402_TOKEN_MINT\")\n</code></pre>"},{"location":"go/getting-started/installation/#for-client-development","title":"For Client Development","text":"<pre><code># Your wallet's private key (base58 encoded)\nexport X402_PRIVATE_KEY=\"your-base58-private-key\"\n\n# Optional: RPC endpoint\nexport X402_RPC_URL=\"https://api.devnet.solana.com\"\n</code></pre>"},{"location":"go/getting-started/installation/#getting-devnet-tokens","title":"Getting Devnet Tokens","text":"<p>To test on Solana devnet:</p> <ol> <li> <p>Create a Solana wallet:    <pre><code>solana-keygen new\n</code></pre></p> </li> <li> <p>Get devnet SOL:    <pre><code>solana airdrop 2 $(solana address) --url devnet\n</code></pre></p> </li> <li> <p>Get devnet USDC:</p> </li> <li>Use spl-token</li> <li>Or visit a devnet faucet</li> </ol>"},{"location":"go/getting-started/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"go/getting-started/installation/#module-not-found-error","title":"Module not found error","text":"<pre><code>go: github.com/openlibx402/go/openlibx402-core@latest:\nreading go.sum: no matching version found\n</code></pre> <p>Solution: Clear module cache and retry: <pre><code>go clean -modcache\ngo get github.com/openlibx402/go/openlibx402-core@latest\n</code></pre></p>"},{"location":"go/getting-started/installation/#version-mismatch","title":"Version mismatch","text":"<pre><code>different modules with the same import path\n</code></pre> <p>Solution: Ensure you're using the correct import path: <pre><code># Wrong (old path)\nimport \"github.com/openlibx402/openlibx402/go/openlibx402-core\"\n\n# Correct (simplified path)\nimport \"github.com/openlibx402/go/openlibx402-core\"\n</code></pre></p>"},{"location":"go/getting-started/installation/#missing-go-version","title":"Missing Go version","text":"<p>Solution: Update Go: <pre><code># macOS with Homebrew\nbrew upgrade go\n\n# Or download from https://golang.org/dl/\n</code></pre></p>"},{"location":"go/getting-started/installation/#next-steps","title":"Next Steps","text":"<p>After installation:</p> <ol> <li>Choose Your Path:</li> <li>Server Quick Start - Build a payment-required API</li> <li> <p>Client Quick Start - Build a payment client</p> </li> <li> <p>Explore Examples:</p> </li> <li>net/http Server Example</li> <li> <p>Echo Server Example</p> </li> <li> <p>Learn More:</p> </li> <li>Core Library</li> <li>Client Library</li> </ol>"},{"location":"go/getting-started/installation/#support","title":"Support","text":"<ul> <li>Issues: GitHub Issues</li> <li>Discussions: GitHub Discussions</li> </ul>"},{"location":"go/getting-started/server-quickstart/","title":"Server Quick Start","text":"<p>Build a payment-required API in minutes with OpenLibx402.</p>"},{"location":"go/getting-started/server-quickstart/#5-minute-server","title":"5-Minute Server","text":""},{"location":"go/getting-started/server-quickstart/#step-1-initialize-your-project","title":"Step 1: Initialize Your Project","text":"<pre><code>mkdir x402-server\ncd x402-server\ngo mod init github.com/yourname/x402-server\n</code></pre>"},{"location":"go/getting-started/server-quickstart/#step-2-install-dependencies","title":"Step 2: Install Dependencies","text":"<pre><code>go get github.com/openlibx402/go/openlibx402-nethttp\n</code></pre>"},{"location":"go/getting-started/server-quickstart/#step-3-create-your-server","title":"Step 3: Create Your Server","text":"<p>Create <code>main.go</code>:</p> <pre><code>package main\n\nimport (\n    \"encoding/json\"\n    \"log\"\n    \"net/http\"\n    \"os\"\n\n    nethttp \"github.com/openlibx402/go/openlibx402-nethttp\"\n)\n\nfunc main() {\n    // Initialize X402 with configuration\n    nethttp.InitX402(&amp;nethttp.Config{\n        PaymentAddress: os.Getenv(\"X402_PAYMENT_ADDRESS\"),\n        TokenMint:      os.Getenv(\"X402_TOKEN_MINT\"),\n        Network:        \"solana-devnet\",\n        AutoVerify:     true,\n    })\n\n    // Free endpoint (no payment required)\n    http.HandleFunc(\"/api/free\", func(w http.ResponseWriter, r *http.Request) {\n        json.NewEncoder(w).Encode(map[string]string{\n            \"message\": \"Free data\",\n            \"data\":    \"Available to everyone\",\n        })\n    })\n\n    // Premium endpoint (requires $0.10)\n    http.Handle(\"/api/premium\", nethttp.PaymentRequired(nethttp.PaymentRequiredOptions{\n        Amount:      \"0.10\",\n        Description: \"Premium data access\",\n    })(http.HandlerFunc(premiumHandler)))\n\n    log.Println(\"Server listening on :8080\")\n    log.Fatal(http.ListenAndServe(\":8080\", nil))\n}\n\nfunc premiumHandler(w http.ResponseWriter, r *http.Request) {\n    // Access payment details if needed\n    auth := nethttp.GetPaymentAuthorization(r)\n    if auth != nil {\n        log.Printf(\"Payment received: %s USDC\", auth.ActualAmount)\n    }\n\n    json.NewEncoder(w).Encode(map[string]interface{}{\n        \"message\": \"Premium data\",\n        \"data\":    \"You paid for this!\",\n        \"premium\": true,\n    })\n}\n</code></pre>"},{"location":"go/getting-started/server-quickstart/#step-4-set-environment-variables","title":"Step 4: Set Environment Variables","text":"<pre><code>export X402_PAYMENT_ADDRESS=\"YOUR_SOLANA_WALLET_ADDRESS\"\nexport X402_TOKEN_MINT=\"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\"\n</code></pre>"},{"location":"go/getting-started/server-quickstart/#step-5-run-your-server","title":"Step 5: Run Your Server","text":"<pre><code>go run main.go\n</code></pre> <p>Output: <pre><code>Server listening on :8080\n</code></pre></p>"},{"location":"go/getting-started/server-quickstart/#step-6-test-it","title":"Step 6: Test It","text":"<p>Test free endpoint: <pre><code>curl http://localhost:8080/api/free\n</code></pre></p> <p>Response: <pre><code>{\n  \"message\": \"Free data\",\n  \"data\": \"Available to everyone\"\n}\n</code></pre></p> <p>Test premium endpoint (will get 402): <pre><code>curl http://localhost:8080/api/premium\n</code></pre></p> <p>Response (402 Payment Required): <pre><code>{\n  \"max_amount_required\": \"0.10\",\n  \"asset_type\": \"SPL\",\n  \"asset_address\": \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\",\n  \"payment_address\": \"YOUR_WALLET_ADDRESS\",\n  \"network\": \"solana-devnet\",\n  \"expires_at\": \"2025-01-01T00:05:00Z\",\n  \"payment_id\": \"...\",\n  \"resource\": \"/api/premium\",\n  \"description\": \"Premium data access\"\n}\n</code></pre></p>"},{"location":"go/getting-started/server-quickstart/#with-echo-framework","title":"With Echo Framework","text":"<p>Prefer Echo? It's even simpler:</p> <pre><code>go get github.com/openlibx402/go/openlibx402-echo\n</code></pre> <pre><code>package main\n\nimport (\n    \"net/http\"\n    \"os\"\n\n    \"github.com/labstack/echo/v4\"\n    echox402 \"github.com/openlibx402/go/openlibx402-echo\"\n)\n\nfunc main() {\n    echox402.InitX402(&amp;echox402.Config{\n        PaymentAddress: os.Getenv(\"X402_PAYMENT_ADDRESS\"),\n        TokenMint:      os.Getenv(\"X402_TOKEN_MINT\"),\n        Network:        \"solana-devnet\",\n        AutoVerify:     true,\n    })\n\n    e := echo.New()\n\n    // Free endpoint\n    e.GET(\"/api/free\", func(c echo.Context) error {\n        return c.JSON(http.StatusOK, map[string]string{\n            \"message\": \"Free data\",\n        })\n    })\n\n    // Premium endpoint\n    e.GET(\"/api/premium\", premiumHandler, echox402.PaymentRequired(echox402.PaymentRequiredOptions{\n        Amount:      \"0.10\",\n        Description: \"Premium data access\",\n    }))\n\n    e.Start(\":8080\")\n}\n\nfunc premiumHandler(c echo.Context) error {\n    // Access payment details\n    auth := echox402.GetPaymentAuthorization(c)\n    if auth != nil {\n        c.Logger().Infof(\"Payment: %s USDC\", auth.ActualAmount)\n    }\n\n    return c.JSON(http.StatusOK, map[string]interface{}{\n        \"message\": \"Premium data\",\n        \"premium\": true,\n    })\n}\n</code></pre>"},{"location":"go/getting-started/server-quickstart/#adding-multiple-price-tiers","title":"Adding Multiple Price Tiers","text":"<pre><code>// Basic tier: $0.05\nhttp.Handle(\"/api/basic\", nethttp.PaymentRequired(nethttp.PaymentRequiredOptions{\n    Amount:      \"0.05\",\n    Description: \"Basic data access\",\n})(basicHandler))\n\n// Standard tier: $0.10\nhttp.Handle(\"/api/standard\", nethttp.PaymentRequired(nethttp.PaymentRequiredOptions{\n    Amount:      \"0.10\",\n    Description: \"Standard data access\",\n})(standardHandler))\n\n// Premium tier: $1.00\nhttp.Handle(\"/api/premium\", nethttp.PaymentRequired(nethttp.PaymentRequiredOptions{\n    Amount:      \"1.00\",\n    Description: \"Premium data access\",\n})(premiumHandler))\n</code></pre>"},{"location":"go/getting-started/server-quickstart/#accessing-payment-details","title":"Accessing Payment Details","text":"<p>Your handlers can access payment information:</p> <pre><code>func myHandler(w http.ResponseWriter, r *http.Request) {\n    auth := nethttp.GetPaymentAuthorization(r)\n    if auth != nil {\n        // Access payment details\n        log.Printf(\"Payment ID: %s\", auth.PaymentID)\n        log.Printf(\"Amount: %s\", auth.ActualAmount)\n        log.Printf(\"Payer: %s\", auth.PublicKey)\n        log.Printf(\"TX Hash: %s\", auth.TransactionHash)\n    }\n\n    // Serve premium content\n    json.NewEncoder(w).Encode(premiumData)\n}\n</code></pre>"},{"location":"go/getting-started/server-quickstart/#configuration-options","title":"Configuration Options","text":"<pre><code>nethttp.InitX402(&amp;nethttp.Config{\n    PaymentAddress: \"wallet_address\",     // Required: where payments go\n    TokenMint:      \"token_mint_address\", // Required: which token\n    Network:        \"solana-devnet\",      // Optional: solana-mainnet for production\n    RPCURL:         \"https://...\",        // Optional: custom RPC endpoint\n    AutoVerify:     true,                 // Optional: verify payments on-chain\n})\n</code></pre>"},{"location":"go/getting-started/server-quickstart/#payment-options","title":"Payment Options","text":"<pre><code>nethttp.PaymentRequired(nethttp.PaymentRequiredOptions{\n    Amount:      \"0.10\",                  // Required: payment amount\n    PaymentAddress: \"override_address\",   // Optional: override global\n    TokenMint:    \"override_mint\",        // Optional: override global\n    Network:      \"solana-mainnet\",       // Optional: override global\n    Description:  \"Premium data access\", // Optional: description shown to user\n    ExpiresIn:    300,                    // Optional: expiration in seconds\n    AutoVerify:   true,                   // Optional: verify payment on-chain\n})\n</code></pre>"},{"location":"go/getting-started/server-quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Production Setup: Configure for Solana mainnet</li> <li>Full Example: See net/http Server Example</li> <li>Client Development: Client Quick Start</li> <li>API Reference: Core Library Documentation</li> </ul>"},{"location":"go/getting-started/server-quickstart/#common-patterns","title":"Common Patterns","text":""},{"location":"go/getting-started/server-quickstart/#dynamic-pricing","title":"Dynamic Pricing","text":"<pre><code>func getPriceTier(tier string) string {\n    switch tier {\n    case \"basic\":\n        return \"0.05\"\n    case \"premium\":\n        return \"0.10\"\n    case \"ultimate\":\n        return \"1.00\"\n    default:\n        return \"0.05\"\n    }\n}\n</code></pre>"},{"location":"go/getting-started/server-quickstart/#rate-limiting-per-payment","title":"Rate Limiting Per Payment","text":"<pre><code>func rateLimitHandler(w http.ResponseWriter, r *http.Request) {\n    auth := nethttp.GetPaymentAuthorization(r)\n\n    // Allow 100 requests per $1 paid\n    if auth != nil {\n        amount, _ := strconv.ParseFloat(auth.ActualAmount, 64)\n        requestsAllowed := int(amount * 100)\n        // Implement rate limiting based on payment\n    }\n\n    json.NewEncoder(w).Encode(data)\n}\n</code></pre>"},{"location":"go/getting-started/server-quickstart/#logging-payments","title":"Logging Payments","text":"<pre><code>func logPayment(auth *core.PaymentAuthorization) {\n    if auth != nil {\n        log.Printf(\"[PAYMENT] ID:%s Amount:%s Payer:%s TX:%s\",\n            auth.PaymentID,\n            auth.ActualAmount,\n            auth.PublicKey,\n            auth.TransactionHash)\n    }\n}\n</code></pre>"},{"location":"go/getting-started/server-quickstart/#troubleshooting","title":"Troubleshooting","text":""},{"location":"go/getting-started/server-quickstart/#x402-not-initialized-error","title":"\"X402 not initialized\" error","text":"<p>Make sure to call <code>InitX402()</code> before defining handlers.</p>"},{"location":"go/getting-started/server-quickstart/#paymentaddress-and-tokenmint-must-be-configured","title":"\"paymentAddress and tokenMint must be configured\"","text":"<p>Check that environment variables are set: <pre><code>echo $X402_PAYMENT_ADDRESS\necho $X402_TOKEN_MINT\n</code></pre></p>"},{"location":"go/getting-started/server-quickstart/#payment-verification-failures","title":"Payment verification failures","text":"<ul> <li>Ensure RPC endpoint is accessible</li> <li>Check network configuration matches (devnet vs mainnet)</li> <li>Verify transaction hash is valid</li> </ul>"},{"location":"go/getting-started/server-quickstart/#support","title":"Support","text":"<ul> <li>Examples</li> <li>API Reference</li> <li>Error Handling</li> </ul>"},{"location":"go/libraries/client/","title":"Client Library","text":"<p>HTTP client with automatic and explicit payment handling for accessing X402-protected APIs.</p>"},{"location":"go/libraries/client/#overview","title":"Overview","text":"<p>The <code>openlibx402-client</code> package provides two client types:</p> <ul> <li>X402Client: Explicit, manual payment control</li> <li>X402AutoClient: Automatic payment handling</li> </ul>"},{"location":"go/libraries/client/#installation","title":"Installation","text":"<pre><code>go get github.com/openlibx402/go/openlibx402-client\n</code></pre>"},{"location":"go/libraries/client/#x402client-explicit-mode","title":"X402Client (Explicit Mode)","text":"<p>Manual control over the payment flow.</p>"},{"location":"go/libraries/client/#constructor","title":"Constructor","text":"<pre><code>client := client.NewX402Client(\n    walletKeypair,  // solana.PrivateKey\n    rpcURL,         // Optional: defaults to devnet\n    httpClient,     // Optional: custom *http.Client\n    allowLocal,     // bool: allow localhost URLs\n)\ndefer client.Close()\n</code></pre>"},{"location":"go/libraries/client/#methods","title":"Methods","text":""},{"location":"go/libraries/client/#get","title":"Get()","text":"<p>Execute a GET request.</p> <pre><code>resp, err := client.Get(ctx, url, nil)\nif err != nil {\n    log.Fatal(err)\n}\ndefer resp.Body.Close()\n</code></pre> <p>With payment authorization:</p> <pre><code>resp, err := client.Get(ctx, url, paymentAuth)\n</code></pre>"},{"location":"go/libraries/client/#post","title":"Post()","text":"<p>Execute a POST request.</p> <pre><code>body := []byte(`{\"data\": \"value\"}`)\nresp, err := client.Post(ctx, url, body, nil)\n</code></pre>"},{"location":"go/libraries/client/#put","title":"Put()","text":"<p>Execute a PUT request.</p> <pre><code>body := []byte(`{\"update\": \"value\"}`)\nresp, err := client.Put(ctx, url, body, nil)\n</code></pre>"},{"location":"go/libraries/client/#delete","title":"Delete()","text":"<p>Execute a DELETE request.</p> <pre><code>resp, err := client.Delete(ctx, url, nil)\n</code></pre>"},{"location":"go/libraries/client/#do","title":"Do()","text":"<p>Execute any HTTP request.</p> <pre><code>req, _ := http.NewRequest(\"PATCH\", url, body)\nresp, err := client.Do(ctx, req, nil)\n</code></pre>"},{"location":"go/libraries/client/#paymentrequired","title":"PaymentRequired()","text":"<p>Check if response is 402 Payment Required.</p> <pre><code>if client.PaymentRequired(resp) {\n    // Handle payment\n}\n</code></pre>"},{"location":"go/libraries/client/#parsepaymentrequest","title":"ParsePaymentRequest()","text":"<p>Parse PaymentRequest from 402 response.</p> <pre><code>paymentReq, err := client.ParsePaymentRequest(resp)\nif err != nil {\n    log.Fatal(err)\n}\n\nlog.Printf(\"Amount: %s\", paymentReq.MaxAmountRequired)\n</code></pre>"},{"location":"go/libraries/client/#createpayment","title":"CreatePayment()","text":"<p>Create and broadcast a payment transaction.</p> <pre><code>auth, err := client.CreatePayment(ctx, paymentReq, \"\")\nif err != nil {\n    log.Fatal(err)\n}\n\nlog.Printf(\"Sent: %s\", auth.TransactionHash)\n</code></pre> <p>Optional custom amount:</p> <pre><code>auth, err := client.CreatePayment(ctx, paymentReq, \"0.05\")\n</code></pre>"},{"location":"go/libraries/client/#close","title":"Close()","text":"<p>Close client and cleanup resources.</p> <pre><code>defer client.Close()\n</code></pre>"},{"location":"go/libraries/client/#x402autoclient-automatic-mode","title":"X402AutoClient (Automatic Mode)","text":"<p>Automatically handles payment flow.</p>"},{"location":"go/libraries/client/#constructor_1","title":"Constructor","text":"<pre><code>client := client.NewAutoClient(\n    walletKeypair,  // solana.PrivateKey\n    rpcURL,         // Optional: defaults to devnet\n    options,        // Optional: *client.AutoClientOptions\n)\ndefer client.Close()\n</code></pre>"},{"location":"go/libraries/client/#options","title":"Options","text":"<pre><code>&amp;client.AutoClientOptions{\n    MaxPaymentAmount: \"10.0\",  // Safety limit\n    AutoRetry:        true,    // Auto-pay on 402\n    AllowLocal:       false,   // Allow localhost URLs\n}\n</code></pre>"},{"location":"go/libraries/client/#methods_1","title":"Methods","text":""},{"location":"go/libraries/client/#get_1","title":"Get()","text":"<p>Execute GET request (auto-pays if needed).</p> <pre><code>resp, err := client.Get(ctx, url)\nif err != nil {\n    log.Fatal(err)\n}\ndefer resp.Body.Close()\n// Payment was handled automatically if needed\n</code></pre>"},{"location":"go/libraries/client/#post_1","title":"Post()","text":"<p>Execute POST request (auto-pays if needed).</p> <pre><code>body := []byte(`{\"data\": \"value\"}`)\nresp, err := client.Post(ctx, url, body)\n</code></pre>"},{"location":"go/libraries/client/#put_1","title":"Put()","text":"<p>Execute PUT request (auto-pays if needed).</p> <pre><code>body := []byte(`{\"update\": \"value\"}`)\nresp, err := client.Put(ctx, url, body)\n</code></pre>"},{"location":"go/libraries/client/#delete_1","title":"Delete()","text":"<p>Execute DELETE request (auto-pays if needed).</p> <pre><code>resp, err := client.Delete(ctx, url)\n</code></pre>"},{"location":"go/libraries/client/#close_1","title":"Close()","text":"<p>Close client and cleanup.</p> <pre><code>defer client.Close()\n</code></pre>"},{"location":"go/libraries/client/#usage-patterns","title":"Usage Patterns","text":""},{"location":"go/libraries/client/#simple-auto-payment","title":"Simple Auto-Payment","text":"<pre><code>client := client.NewAutoClient(keypair, \"\", &amp;client.AutoClientOptions{\n    MaxPaymentAmount: \"10.0\",\n})\ndefer client.Close()\n\n// Just call the endpoint - payment handled automatically\nresp, err := client.Get(ctx, \"https://api.example.com/premium\")\nif err != nil {\n    log.Fatal(err)\n}\n\ndata, _ := io.ReadAll(resp.Body)\nresp.Body.Close()\nlog.Println(string(data))\n</code></pre>"},{"location":"go/libraries/client/#explicit-payment-flow","title":"Explicit Payment Flow","text":"<pre><code>client := client.NewX402Client(keypair, \"\", nil, false)\ndefer client.Close()\n\n// Step 1: Initial request\nresp, err := client.Get(ctx, url, nil)\nif err != nil {\n    log.Fatal(err)\n}\n\n// Step 2: Check if payment needed\nif client.PaymentRequired(resp) {\n    // Step 3: Parse request\n    paymentReq, err := client.ParsePaymentRequest(resp)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Step 4: User confirmation (optional)\n    if !userConfirms(paymentReq) {\n        log.Fatal(\"Payment declined\")\n    }\n\n    // Step 5: Create payment\n    auth, err := client.CreatePayment(ctx, paymentReq, \"\")\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Step 6: Retry with payment\n    resp, err = client.Get(ctx, url, auth)\n    if err != nil {\n        log.Fatal(err)\n    }\n}\n\n// Step 7: Process response\ndata, _ := io.ReadAll(resp.Body)\nresp.Body.Close()\n</code></pre>"},{"location":"go/libraries/client/#multiple-endpoints","title":"Multiple Endpoints","text":"<pre><code>client := client.NewAutoClient(keypair, \"\", &amp;client.AutoClientOptions{\n    MaxPaymentAmount: \"10.0\",\n})\ndefer client.Close()\n\nendpoints := map[string]string{\n    \"users\":   \"https://api.example.com/users\",\n    \"posts\":   \"https://api.example.com/posts\",\n    \"premium\": \"https://api.example.com/premium\",\n}\n\nfor name, endpoint := range endpoints {\n    resp, err := client.Get(ctx, endpoint)\n    if err != nil {\n        log.Printf(\"Error accessing %s: %v\", name, err)\n        continue\n    }\n\n    data, _ := io.ReadAll(resp.Body)\n    resp.Body.Close()\n    log.Printf(\"%s: %s\", name, string(data))\n}\n</code></pre>"},{"location":"go/libraries/client/#with-payment-tracking","title":"With Payment Tracking","text":"<pre><code>type PaymentTracker struct {\n    totalSpent float64\n    maxSpend   float64\n    payments   []string\n}\n\nfunc (pt *PaymentTracker) trackPayment(auth *core.PaymentAuthorization) {\n    amount, _ := strconv.ParseFloat(auth.ActualAmount, 64)\n    pt.totalSpent += amount\n    pt.payments = append(pt.payments, auth.TransactionHash)\n    log.Printf(\"Total spent: %.2f / %.2f\", pt.totalSpent, pt.maxSpend)\n}\n\n// Usage\ntracker := &amp;PaymentTracker{\n    totalSpent: 0,\n    maxSpend:   10.0,\n}\n\nclient := client.NewAutoClient(keypair, \"\", &amp;client.AutoClientOptions{\n    MaxPaymentAmount: \"5.0\",  // Prevent individual payments over $5\n})\n\n// Track payments by monitoring response\n// Note: Auto client doesn't expose auth, so you'd need explicit mode for tracking\n</code></pre>"},{"location":"go/libraries/client/#custom-http-client","title":"Custom HTTP Client","text":"<pre><code>httpClient := &amp;http.Client{\n    Timeout: 30 * time.Second,\n    Transport: &amp;http.Transport{\n        MaxIdleConns: 10,\n    },\n}\n\nclient := client.NewX402Client(keypair, \"\", httpClient, false)\n</code></pre>"},{"location":"go/libraries/client/#context-with-timeout","title":"Context with Timeout","text":"<pre><code>ctx, cancel := context.WithTimeout(context.Background(), 60*time.Second)\ndefer cancel()\n\nresp, err := client.Get(ctx, url, nil)\nif errors.Is(err, context.DeadlineExceeded) {\n    log.Println(\"Request timeout\")\n}\n</code></pre>"},{"location":"go/libraries/client/#error-handling","title":"Error Handling","text":"<pre><code>import \"github.com/openlibx402/go/openlibx402-core\"\n\nresp, err := client.Get(ctx, url, nil)\nif err != nil {\n    switch e := err.(type) {\n    case *core.PaymentExpiredError:\n        log.Println(\"Payment request expired\")\n        // Retry or request new payment\n\n    case *core.InsufficientFundsError:\n        log.Printf(\"Insufficient balance: %s\", e.RequiredAmount)\n        // Cannot proceed - need funds\n\n    case *core.PaymentVerificationError:\n        log.Println(\"Payment verification failed\")\n        // Retry - might be temporary\n\n    case *core.InvalidPaymentRequestError:\n        log.Println(\"Invalid payment request\")\n        // Contact API provider\n\n    default:\n        log.Println(\"Unknown error:\", err)\n    }\n}\n</code></pre>"},{"location":"go/libraries/client/#configuration","title":"Configuration","text":""},{"location":"go/libraries/client/#environment-variables","title":"Environment Variables","text":"<pre><code>import \"os\"\n\nrpcURL := os.Getenv(\"X402_RPC_URL\")\nif rpcURL == \"\" {\n    rpcURL = \"https://api.devnet.solana.com\"\n}\n\nmaxPayment := os.Getenv(\"X402_MAX_PAYMENT\")\nif maxPayment == \"\" {\n    maxPayment = \"10.0\"\n}\n</code></pre>"},{"location":"go/libraries/client/#from-config-file","title":"From Config File","text":"<pre><code>type ClientConfig struct {\n    WalletPrivateKey string\n    RPCURL          string\n    MaxPaymentAmount string\n    AutoRetry       bool\n    AllowLocal      bool\n}\n\n// Load from JSON, YAML, TOML, etc\nconfig := loadConfig(\"config.yaml\")\n\nprivateKeyBytes := base58.Decode(config.WalletPrivateKey)\nkeypair := solana.PrivateKey(privateKeyBytes)\n\nclient := client.NewAutoClient(\n    keypair,\n    config.RPCURL,\n    &amp;client.AutoClientOptions{\n        MaxPaymentAmount: config.MaxPaymentAmount,\n        AutoRetry:        config.AutoRetry,\n        AllowLocal:       config.AllowLocal,\n    },\n)\n</code></pre>"},{"location":"go/libraries/client/#security-best-practices","title":"Security Best Practices","text":""},{"location":"go/libraries/client/#do_1","title":"\u2705 Do","text":"<pre><code>// Use payment limits\nclient := client.NewAutoClient(keypair, \"\", &amp;client.AutoClientOptions{\n    MaxPaymentAmount: \"10.0\",  // Prevent overspending\n})\n\n// Use context timeout\nctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)\ndefer cancel()\n\n// Close client when done\ndefer client.Close()\n\n// Validate URLs in explicit mode\n// Client validates URLs automatically\n</code></pre>"},{"location":"go/libraries/client/#dont","title":"\u274c Don't","text":"<pre><code>// Don't use without payment limit\nclient := client.NewAutoClient(keypair, \"\", nil)\n\n// Don't allow local in production\nclient := client.NewAutoClient(keypair, \"\", &amp;client.AutoClientOptions{\n    AllowLocal: true,  // Only for dev!\n})\n\n// Don't forget to close\nclient := client.NewAutoClient(keypair, \"\", nil)\n// Missing: defer client.Close()\n\n// Don't hardcode URLs\nclient.Get(ctx, \"http://192.168.1.1/api\")  // SSRF risk\n</code></pre>"},{"location":"go/libraries/client/#performance-tips","title":"Performance Tips","text":""},{"location":"go/libraries/client/#connection-reuse","title":"Connection Reuse","text":"<pre><code>// Good: Reuse client for multiple requests\nclient := client.NewAutoClient(keypair, \"\", nil)\ndefer client.Close()\n\nfor _, url := range urls {\n    resp, _ := client.Get(ctx, url)\n    // Use response\n}\n</code></pre>"},{"location":"go/libraries/client/#timeout-configuration","title":"Timeout Configuration","text":"<pre><code>// Different timeouts for different needs\nshortTimeout := 10 * time.Second\nlongTimeout := 60 * time.Second\n\nfor _, url := range urls {\n    ctx, cancel := context.WithTimeout(context.Background(), shortTimeout)\n    resp, _ := client.Get(ctx, url)\n    cancel()\n}\n</code></pre>"},{"location":"go/libraries/client/#batch-processing","title":"Batch Processing","text":"<pre><code>// Process multiple endpoints efficiently\nresults := make(chan string)\nfor _, url := range urls {\n    go func(u string) {\n        resp, _ := client.Get(ctx, u)\n        data, _ := io.ReadAll(resp.Body)\n        results &lt;- string(data)\n        resp.Body.Close()\n    }(url)\n}\n\nfor range urls {\n    log.Println(&lt;-results)\n}\n</code></pre>"},{"location":"go/libraries/client/#see-also","title":"See Also","text":"<ul> <li>Core Library - Underlying payment types</li> <li>Server Quick Start</li> <li>Client Quick Start</li> <li>Error Reference</li> </ul>"},{"location":"go/libraries/core/","title":"Core Library","text":"<p>The core library provides the fundamental data structures and Solana blockchain operations for the X402 protocol.</p>"},{"location":"go/libraries/core/#overview","title":"Overview","text":"<p>The <code>openlibx402-core</code> package contains:</p> <ul> <li>Models: <code>PaymentRequest</code>, <code>PaymentAuthorization</code></li> <li>Errors: Complete error hierarchy</li> <li>SolanaPaymentProcessor: Blockchain operations</li> <li>Utilities: Helper functions and types</li> </ul>"},{"location":"go/libraries/core/#installation","title":"Installation","text":"<pre><code>go get github.com/openlibx402/go/openlibx402-core\n</code></pre>"},{"location":"go/libraries/core/#paymentrequest","title":"PaymentRequest","text":"<p>Represents a 402 payment request from a server.</p>"},{"location":"go/libraries/core/#structure","title":"Structure","text":"<pre><code>type PaymentRequest struct {\n    MaxAmountRequired string    // Amount in token units (e.g., \"0.10\")\n    AssetType         string    // \"SPL\" for Solana tokens\n    AssetAddress      string    // Token mint address\n    PaymentAddress    string    // Recipient's wallet address\n    Network           string    // \"solana-devnet\" | \"solana-mainnet\"\n    ExpiresAt         time.Time // Expiration timestamp\n    Nonce             string    // Unique identifier for replay protection\n    PaymentID         string    // Unique payment request ID\n    Resource          string    // API endpoint being accessed\n    Description       string    // Human-readable description (optional)\n}\n</code></pre>"},{"location":"go/libraries/core/#methods","title":"Methods","text":""},{"location":"go/libraries/core/#isexpired","title":"IsExpired()","text":"<p>Check if the payment request has expired.</p> <pre><code>if paymentRequest.IsExpired() {\n    return core.NewPaymentExpiredError(paymentRequest, \"\")\n}\n</code></pre>"},{"location":"go/libraries/core/#tojson","title":"ToJSON()","text":"<p>Convert to JSON string.</p> <pre><code>jsonStr, err := paymentRequest.ToJSON()\n</code></pre>"},{"location":"go/libraries/core/#paymentrequestfromjson","title":"PaymentRequestFromJSON()","text":"<p>Parse from JSON string.</p> <pre><code>paymentReq, err := core.PaymentRequestFromJSON(jsonStr)\nif err != nil {\n    log.Fatal(err)\n}\n</code></pre>"},{"location":"go/libraries/core/#paymentauthorization","title":"PaymentAuthorization","text":"<p>Represents a signed payment authorization to include in retry requests.</p>"},{"location":"go/libraries/core/#structure_1","title":"Structure","text":"<pre><code>type PaymentAuthorization struct {\n    PaymentID       string    // From payment request\n    ActualAmount    string    // Amount being paid (\u2264 max_amount_required)\n    PaymentAddress  string    // Recipient address\n    AssetAddress    string    // Token mint address\n    Network         string    // Blockchain network\n    Timestamp       time.Time // Authorization timestamp\n    Signature       string    // Solana signature\n    PublicKey       string    // Payer's public key\n    TransactionHash string    // On-chain tx hash (after broadcast)\n}\n</code></pre>"},{"location":"go/libraries/core/#methods_1","title":"Methods","text":""},{"location":"go/libraries/core/#toheadervalue","title":"ToHeaderValue()","text":"<p>Encode as base64 JSON for HTTP header.</p> <pre><code>headerValue, err := authorization.ToHeaderValue()\n// Use in X-Payment-Authorization header\n</code></pre>"},{"location":"go/libraries/core/#fromheader","title":"FromHeader()","text":"<p>Parse from HTTP header.</p> <pre><code>auth, err := core.PaymentAuthorizationFromHeader(headerValue)\n</code></pre>"},{"location":"go/libraries/core/#tojson_1","title":"ToJSON()","text":"<p>Convert to JSON string.</p> <pre><code>jsonStr, err := authorization.ToJSON()\n</code></pre>"},{"location":"go/libraries/core/#solanapaymentprocessor","title":"SolanaPaymentProcessor","text":"<p>Handles Solana blockchain operations.</p>"},{"location":"go/libraries/core/#constructor","title":"Constructor","text":"<pre><code>processor := core.NewSolanaPaymentProcessor(\n    \"https://api.devnet.solana.com\",  // RPC endpoint\n    &amp;walletKeypair,                    // Optional keypair\n)\ndefer processor.Close()\n</code></pre>"},{"location":"go/libraries/core/#methods_2","title":"Methods","text":""},{"location":"go/libraries/core/#createpaymenttransaction","title":"CreatePaymentTransaction()","text":"<p>Create a Solana transaction for payment.</p> <pre><code>tx, err := processor.CreatePaymentTransaction(\n    ctx,                    // context\n    paymentRequest,         // PaymentRequest\n    \"0.10\",                // amount\n    walletKeypair,         // payer keypair\n)\nif err != nil {\n    log.Fatal(err)\n}\n</code></pre>"},{"location":"go/libraries/core/#signandsendtransaction","title":"SignAndSendTransaction()","text":"<p>Sign and broadcast transaction to Solana.</p> <pre><code>txHash, err := processor.SignAndSendTransaction(ctx, tx, walletKeypair)\nif err != nil {\n    log.Fatal(err)\n}\nlog.Printf(\"Sent: %s\", txHash)\n</code></pre>"},{"location":"go/libraries/core/#verifytransaction","title":"VerifyTransaction()","text":"<p>Verify that a transaction exists on-chain and matches parameters.</p> <pre><code>verified, err := processor.VerifyTransaction(\n    ctx,\n    \"transaction_hash\",\n    \"expected_recipient\",\n    \"0.10\",\n    \"token_mint_address\",\n)\nif err != nil || !verified {\n    log.Fatal(\"Verification failed\")\n}\n</code></pre>"},{"location":"go/libraries/core/#gettokenbalance","title":"GetTokenBalance()","text":"<p>Get SPL token balance for a wallet.</p> <pre><code>balance, err := processor.GetTokenBalance(\n    ctx,\n    \"wallet_address\",\n    \"token_mint\",\n)\nif err != nil {\n    log.Fatal(err)\n}\nlog.Printf(\"Balance: %f\", balance)\n</code></pre>"},{"location":"go/libraries/core/#getdefaultrpcurl","title":"GetDefaultRPCURL()","text":"<p>Get the default RPC URL for a network.</p> <pre><code>rpcURL := core.GetDefaultRPCURL(\"solana-devnet\")\n// Returns: \"https://api.devnet.solana.com\"\n</code></pre>"},{"location":"go/libraries/core/#error-types","title":"Error Types","text":""},{"location":"go/libraries/core/#x402error","title":"X402Error","text":"<p>Base error type with code and details.</p> <pre><code>type X402Error struct {\n    Message string\n    Code    string\n    Details map[string]interface{}\n}\n\n// Use\nif err := someFunction(); err != nil {\n    if x402Err, ok := err.(*core.X402Error); ok {\n        log.Printf(\"Code: %s\", x402Err.Code)\n        log.Printf(\"Message: %s\", x402Err.Message)\n    }\n}\n</code></pre>"},{"location":"go/libraries/core/#paymentrequirederror","title":"PaymentRequiredError","text":"<p>Raised when a 402 response is received.</p> <pre><code>return core.NewPaymentRequiredError(paymentRequest, \"\")\n\n// With custom message\nreturn core.NewPaymentRequiredError(\n    paymentRequest,\n    \"Payment required for premium access\",\n)\n</code></pre>"},{"location":"go/libraries/core/#paymentexpirederror","title":"PaymentExpiredError","text":"<p>Payment request has expired.</p> <pre><code>return core.NewPaymentExpiredError(paymentRequest, \"\")\n</code></pre>"},{"location":"go/libraries/core/#insufficientfundserror","title":"InsufficientFundsError","text":"<p>Wallet lacks sufficient funds.</p> <pre><code>return core.NewInsufficientFundsError(\"0.10\", \"0.05\")\n</code></pre>"},{"location":"go/libraries/core/#paymentverificationerror","title":"PaymentVerificationError","text":"<p>Payment verification failed.</p> <pre><code>return core.NewPaymentVerificationError(\"transaction not found\")\n</code></pre>"},{"location":"go/libraries/core/#transactionbroadcasterror","title":"TransactionBroadcastError","text":"<p>Failed to broadcast transaction.</p> <pre><code>return core.NewTransactionBroadcastError(\"network error\")\n</code></pre>"},{"location":"go/libraries/core/#invalidpaymentrequesterror","title":"InvalidPaymentRequestError","text":"<p>Invalid payment request format.</p> <pre><code>return core.NewInvalidPaymentRequestError(\"missing payment_id\")\n</code></pre>"},{"location":"go/libraries/core/#error-codes-reference","title":"Error Codes Reference","text":"<pre><code>core.ErrorCodes[\"PAYMENT_REQUIRED\"]\ncore.ErrorCodes[\"PAYMENT_EXPIRED\"]\ncore.ErrorCodes[\"INSUFFICIENT_FUNDS\"]\ncore.ErrorCodes[\"PAYMENT_VERIFICATION_FAILED\"]\ncore.ErrorCodes[\"TRANSACTION_BROADCAST_FAILED\"]\ncore.ErrorCodes[\"INVALID_PAYMENT_REQUEST\"]\n</code></pre> <p>Each error code includes: - <code>Code</code>: Error code string - <code>Message</code>: Default message - <code>Retry</code>: Whether to retry - <code>UserAction</code>: What user should do</p>"},{"location":"go/libraries/core/#usage-examples","title":"Usage Examples","text":""},{"location":"go/libraries/core/#parse-and-validate-payment-request","title":"Parse and Validate Payment Request","text":"<pre><code>// From 402 response\njsonStr := `{...}`\npaymentReq, err := core.PaymentRequestFromJSON(jsonStr)\nif err != nil {\n    return err\n}\n\n// Check if expired\nif paymentReq.IsExpired() {\n    return core.NewPaymentExpiredError(paymentReq, \"\")\n}\n\n// Use details\nlog.Printf(\"Pay %s to %s\", paymentReq.MaxAmountRequired, paymentReq.PaymentAddress)\n</code></pre>"},{"location":"go/libraries/core/#create-and-verify-payment","title":"Create and Verify Payment","text":"<pre><code>// Create transaction\nprocessor := core.NewSolanaPaymentProcessor(rpcURL, nil)\ndefer processor.Close()\n\ntx, err := processor.CreatePaymentTransaction(ctx, paymentReq, amount, keypair)\nif err != nil {\n    return err\n}\n\n// Broadcast\ntxHash, err := processor.SignAndSendTransaction(ctx, tx, keypair)\nif err != nil {\n    return err\n}\n\n// Verify\nverified, err := processor.VerifyTransaction(\n    ctx,\n    txHash,\n    paymentReq.PaymentAddress,\n    amount,\n    paymentReq.AssetAddress,\n)\nif !verified {\n    return core.NewPaymentVerificationError(\"verification failed\")\n}\n</code></pre>"},{"location":"go/libraries/core/#handle-errors","title":"Handle Errors","text":"<pre><code>resp, err := client.Get(ctx, url)\nif err != nil {\n    switch e := err.(type) {\n    case *core.PaymentRequiredError:\n        log.Println(\"Payment needed\")\n        handlePayment(e.PaymentRequest)\n\n    case *core.InsufficientFundsError:\n        log.Printf(\"Need: %s, Have: %s\", e.RequiredAmount, e.AvailableAmount)\n        // Direct user to add funds\n\n    case *core.PaymentExpiredError:\n        log.Println(\"Request expired, retrying...\")\n        // Retry fresh request\n\n    case *core.PaymentVerificationError:\n        log.Println(\"Verification failed\")\n        // Log and retry\n\n    default:\n        log.Println(\"Unknown error:\", err)\n    }\n}\n</code></pre>"},{"location":"go/libraries/core/#network-configuration","title":"Network Configuration","text":""},{"location":"go/libraries/core/#supported-networks","title":"Supported Networks","text":"<pre><code>// Devnet (testing)\ncore.GetDefaultRPCURL(\"solana-devnet\")\n// \u2192 \"https://api.devnet.solana.com\"\n\n// Testnet\ncore.GetDefaultRPCURL(\"solana-testnet\")\n// \u2192 \"https://api.testnet.solana.com\"\n\n// Mainnet (production)\ncore.GetDefaultRPCURL(\"solana-mainnet\")\n// \u2192 \"https://api.mainnet-beta.solana.com\"\n</code></pre>"},{"location":"go/libraries/core/#custom-rpc-endpoint","title":"Custom RPC Endpoint","text":"<pre><code>processor := core.NewSolanaPaymentProcessor(\n    \"https://your-rpc-endpoint.com\",\n    &amp;keypair,\n)\n</code></pre>"},{"location":"go/libraries/core/#best-practices","title":"Best Practices","text":""},{"location":"go/libraries/core/#do","title":"\u2705 Do","text":"<pre><code>// Check balance before attempting payment\nbalance, _ := processor.GetTokenBalance(ctx, wallet, mint)\nif balance &gt;= requiredAmount {\n    // Safe to proceed\n}\n\n// Validate request not expired\nif !paymentRequest.IsExpired() {\n    // Safe to proceed\n}\n\n// Verify payment on-chain\nverified, _ := processor.VerifyTransaction(ctx, hash, recipient, amount, mint)\n</code></pre>"},{"location":"go/libraries/core/#dont","title":"\u274c Don't","text":"<pre><code>// Don't ignore errors\nprocessor.CreatePaymentTransaction(ctx, req, amount, key)\n\n// Don't skip expiration check\n_ = paymentRequest.IsExpired()\n\n// Don't trust unverified payments\n</code></pre>"},{"location":"go/libraries/core/#see-also","title":"See Also","text":"<ul> <li>Client Library - HTTP client using core library</li> <li>Middleware - Server-side payment handling</li> <li>Error Reference - Complete error documentation</li> </ul>"},{"location":"go/middleware/echo/","title":"Echo Middleware","text":"<p>Server-side X402 payment handling for the Echo web framework.</p>"},{"location":"go/middleware/echo/#overview","title":"Overview","text":"<p>The <code>openlibx402-echo</code> package provides middleware for Echo to require payments for endpoints.</p>"},{"location":"go/middleware/echo/#installation","title":"Installation","text":"<pre><code>go get github.com/openlibx402/go/openlibx402-echo\n</code></pre>"},{"location":"go/middleware/echo/#quick-start","title":"Quick Start","text":"<pre><code>package main\n\nimport (\n    \"net/http\"\n    \"os\"\n\n    \"github.com/labstack/echo/v4\"\n    echox402 \"github.com/openlibx402/go/openlibx402-echo\"\n)\n\nfunc main() {\n    // Initialize configuration\n    echox402.InitX402(&amp;echox402.Config{\n        PaymentAddress: os.Getenv(\"X402_PAYMENT_ADDRESS\"),\n        TokenMint:      os.Getenv(\"X402_TOKEN_MINT\"),\n        Network:        \"solana-devnet\",\n        AutoVerify:     true,\n    })\n\n    e := echo.New()\n\n    // Free endpoint\n    e.GET(\"/api/free\", freeHandler)\n\n    // Protected endpoint\n    e.GET(\"/api/premium\", premiumHandler, echox402.PaymentRequired(echox402.PaymentRequiredOptions{\n        Amount: \"0.10\",\n    }))\n\n    e.Start(\":8080\")\n}\n\nfunc freeHandler(c echo.Context) error {\n    return c.JSON(http.StatusOK, map[string]string{\"data\": \"free\"})\n}\n\nfunc premiumHandler(c echo.Context) error {\n    return c.JSON(http.StatusOK, map[string]string{\"data\": \"premium\"})\n}\n</code></pre>"},{"location":"go/middleware/echo/#configuration","title":"Configuration","text":""},{"location":"go/middleware/echo/#initx402","title":"InitX402()","text":"<p>Initialize global X402 configuration. Call once at startup.</p> <pre><code>echox402.InitX402(&amp;echox402.Config{\n    PaymentAddress: \"YOUR_SOLANA_WALLET\",      // Required\n    TokenMint:      \"USDC_MINT_ADDRESS\",       // Required\n    Network:        \"solana-devnet\",           // Optional\n    RPCURL:         \"https://api.devnet...\",   // Optional\n    AutoVerify:     true,                      // Optional\n})\n</code></pre>"},{"location":"go/middleware/echo/#config-fields","title":"Config Fields","text":"Field Type Required Default Description PaymentAddress string Yes - Wallet receiving payments TokenMint string Yes - SPL token mint address Network string No \"solana-devnet\" Solana network RPCURL string No Auto RPC endpoint AutoVerify bool No false Verify payments on-chain"},{"location":"go/middleware/echo/#middleware","title":"Middleware","text":""},{"location":"go/middleware/echo/#paymentrequired","title":"PaymentRequired()","text":"<p>Add payment requirement to routes.</p> <pre><code>e.GET(\"/api/premium\", handler, echox402.PaymentRequired(echox402.PaymentRequiredOptions{\n    Amount: \"0.10\",\n}))\n</code></pre> <p>Multiple routes:</p> <pre><code>admin := e.Group(\"/admin\", echox402.PaymentRequired(echox402.PaymentRequiredOptions{\n    Amount: \"1.00\",\n}))\nadmin.GET(\"/users\", adminHandler)\nadmin.GET(\"/config\", configHandler)\n</code></pre>"},{"location":"go/middleware/echo/#options","title":"Options","text":"<pre><code>echox402.PaymentRequired(echox402.PaymentRequiredOptions{\n    Amount:         \"0.10\",                 // Required: payment amount\n    PaymentAddress: \"override_address\",     // Optional: override global\n    TokenMint:      \"override_mint\",        // Optional: override global\n    Network:        \"solana-mainnet\",       // Optional: override global\n    Description:    \"Premium data access\", // Optional: human-readable\n    ExpiresIn:      300,                    // Optional: seconds\n    AutoVerify:     true,                   // Optional: verify on-chain\n})\n</code></pre>"},{"location":"go/middleware/echo/#accessing-payment-details","title":"Accessing Payment Details","text":"<p>Use <code>GetPaymentAuthorization()</code> in your handler:</p> <pre><code>func myHandler(c echo.Context) error {\n    auth := echox402.GetPaymentAuthorization(c)\n    if auth != nil {\n        c.Logger().Infof(\"Payment: %s USDC\", auth.ActualAmount)\n    }\n\n    return c.JSON(http.StatusOK, data)\n}\n\ne.GET(\"/api/data\", myHandler, echox402.PaymentRequired(echox402.PaymentRequiredOptions{\n    Amount: \"0.10\",\n}))\n</code></pre>"},{"location":"go/middleware/echo/#paymentauthorization-fields","title":"PaymentAuthorization Fields","text":"<pre><code>type PaymentAuthorization struct {\n    PaymentID       string    // From payment request\n    ActualAmount    string    // Amount paid\n    PaymentAddress  string    // Recipient wallet\n    AssetAddress    string    // Token mint\n    Network         string    // Blockchain network\n    Timestamp       time.Time // When authorized\n    Signature       string    // Transaction signature\n    PublicKey       string    // Payer's wallet\n    TransactionHash string    // On-chain tx hash\n}\n</code></pre>"},{"location":"go/middleware/echo/#patterns","title":"Patterns","text":""},{"location":"go/middleware/echo/#multiple-pricing-tiers","title":"Multiple Pricing Tiers","text":"<pre><code>// Free tier\ne.GET(\"/api/free\", freeHandler)\n\n// Basic tier ($0.05)\ne.GET(\"/api/basic\", basicHandler, echox402.PaymentRequired(echox402.PaymentRequiredOptions{\n    Amount: \"0.05\",\n}))\n\n// Standard tier ($0.10)\ne.GET(\"/api/standard\", standardHandler, echox402.PaymentRequired(echox402.PaymentRequiredOptions{\n    Amount: \"0.10\",\n}))\n\n// Premium tier ($1.00)\ne.GET(\"/api/premium\", premiumHandler, echox402.PaymentRequired(echox402.PaymentRequiredOptions{\n    Amount: \"1.00\",\n}))\n</code></pre>"},{"location":"go/middleware/echo/#route-groups-with-payment","title":"Route Groups with Payment","text":"<pre><code>// Basic API group (free)\napi := e.Group(\"/api\")\napi.GET(\"/public\", publicHandler)\napi.GET(\"/data\", dataHandler)\n\n// Premium API group ($0.10)\npremium := e.Group(\"/api/premium\", echox402.PaymentRequired(echox402.PaymentRequiredOptions{\n    Amount: \"0.10\",\n}))\npremium.GET(\"/data\", premiumDataHandler)\npremium.POST(\"/process\", processHandler)\n\n// Enterprise group ($5.00)\nenterprise := e.Group(\"/api/enterprise\", echox402.PaymentRequired(echox402.PaymentRequiredOptions{\n    Amount: \"5.00\",\n}))\nenterprise.GET(\"/analytics\", analyticsHandler)\nenterprise.GET(\"/export\", exportHandler)\n</code></pre>"},{"location":"go/middleware/echo/#dynamic-pricing","title":"Dynamic Pricing","text":"<pre><code>func dynamicPricingHandler(c echo.Context) error {\n    // Determine price based on request\n    tier := c.QueryParam(\"tier\")\n    var price string\n\n    switch tier {\n    case \"basic\":\n        price = \"0.05\"\n    case \"standard\":\n        price = \"0.10\"\n    case \"premium\":\n        price = \"1.00\"\n    default:\n        price = \"0.05\"\n    }\n\n    // Would need to apply middleware with dynamic amount\n    // This shows how you'd handle it in the handler\n    auth := echox402.GetPaymentAuthorization(c)\n    if auth != nil {\n        c.Logger().Infof(\"Tier: %s, Price: %s\", tier, price)\n    }\n\n    return c.JSON(http.StatusOK, map[string]string{\"tier\": tier})\n}\n\n// For dynamic pricing, apply appropriate middleware:\ne.GET(\"/api/data\", dynamicPricingHandler,\n    echox402.PaymentRequired(echox402.PaymentRequiredOptions{\n        Amount: \"0.10\",  // Use highest expected amount\n    }))\n</code></pre>"},{"location":"go/middleware/echo/#logging-and-analytics","title":"Logging and Analytics","text":"<pre><code>func analyticsHandler(c echo.Context) error {\n    auth := echox402.GetPaymentAuthorization(c)\n    if auth != nil {\n        // Log payment for analytics\n        logPayment(PaymentLog{\n            PaymentID:    auth.PaymentID,\n            Amount:       auth.ActualAmount,\n            Payer:        auth.PublicKey,\n            Endpoint:     c.Request().URL.Path,\n            Timestamp:    auth.Timestamp,\n            Transaction:  auth.TransactionHash,\n        })\n    }\n\n    return c.JSON(http.StatusOK, analyticsData)\n}\n\ne.GET(\"/api/analytics\", analyticsHandler, echox402.PaymentRequired(echox402.PaymentRequiredOptions{\n    Amount: \"0.50\",\n}))\n</code></pre>"},{"location":"go/middleware/echo/#rate-limiting-by-payment","title":"Rate Limiting by Payment","text":"<pre><code>func rateLimitedByPayment(c echo.Context) error {\n    auth := echox402.GetPaymentAuthorization(c)\n    if auth != nil {\n        amount, _ := strconv.ParseFloat(auth.ActualAmount, 64)\n        // Allow 100 requests per $1 paid\n        requestsAllowed := int(amount * 100)\n        c.Set(\"requests_allowed\", requestsAllowed)\n    }\n\n    return c.JSON(http.StatusOK, data)\n}\n\ne.GET(\"/api/data\", rateLimitedByPayment, echox402.PaymentRequired(echox402.PaymentRequiredOptions{\n    Amount: \"0.10\",\n}))\n</code></pre>"},{"location":"go/middleware/echo/#jwt-with-payment","title":"JWT with Payment","text":"<pre><code>import \"github.com/golang-jwt/jwt\"\n\nfunc tokenWithPayment(c echo.Context) error {\n    auth := echox402.GetPaymentAuthorization(c)\n\n    claims := jwt.MapClaims{\n        \"payment_id\": auth.PaymentID,\n        \"payer\":      auth.PublicKey,\n        \"amount\":     auth.ActualAmount,\n        \"exp\":        time.Now().Add(24 * time.Hour).Unix(),\n    }\n\n    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\n    t, _ := token.SignedString([]byte(\"secret\"))\n\n    return c.JSON(http.StatusOK, map[string]string{\"token\": t})\n}\n\ne.GET(\"/api/token\", tokenWithPayment, echox402.PaymentRequired(echox402.PaymentRequiredOptions{\n    Amount: \"0.10\",\n}))\n</code></pre>"},{"location":"go/middleware/echo/#middleware-composition","title":"Middleware Composition","text":""},{"location":"go/middleware/echo/#custom-middleware-payment","title":"Custom Middleware + Payment","text":"<pre><code>func customMiddleware() echo.MiddlewareFunc {\n    return func(next echo.HandlerFunc) echo.HandlerFunc {\n        return func(c echo.Context) error {\n            // Custom logic before\n            c.Set(\"request_id\", uuid.New().String())\n\n            err := next(c)\n\n            // Custom logic after\n            return err\n        }\n    }\n}\n\ne.GET(\"/api/data\", handler,\n    customMiddleware(),\n    echox402.PaymentRequired(echox402.PaymentRequiredOptions{\n        Amount: \"0.10\",\n    }))\n</code></pre>"},{"location":"go/middleware/echo/#logging-middleware","title":"Logging Middleware","text":"<pre><code>e.Use(middleware.LoggerWithConfig(middleware.LoggerConfig{\n    Format: \"${time_rfc3339} ${method} ${uri} ${status}\\n\",\n}))\n\ne.GET(\"/api/data\", handler, echox402.PaymentRequired(echox402.PaymentRequiredOptions{\n    Amount: \"0.10\",\n}))\n</code></pre>"},{"location":"go/middleware/echo/#error-handling","title":"Error Handling","text":"<p>The middleware automatically handles errors:</p> <ul> <li>No payment header: Returns 402 with PaymentRequest</li> <li>Invalid payment: Returns 400 Bad Request</li> <li>Verification failed: Returns 403 Forbidden</li> <li>Amount insufficient: Returns 403 Forbidden</li> <li>Address mismatch: Returns 403 Forbidden</li> </ul> <p>Your handler won't be called if payment fails.</p>"},{"location":"go/middleware/echo/#configuration-override","title":"Configuration Override","text":""},{"location":"go/middleware/echo/#per-route-override","title":"Per-Route Override","text":"<pre><code>echox402.InitX402(&amp;echox402.Config{\n    PaymentAddress: \"default_address\",\n    TokenMint:      \"default_mint\",\n})\n\n// Override for specific route\ne.GET(\"/premium\",\n    handler,\n    echox402.PaymentRequired(echox402.PaymentRequiredOptions{\n        Amount:         \"0.10\",\n        PaymentAddress: \"different_address\",\n    }))\n</code></pre>"},{"location":"go/middleware/echo/#environment-based-configuration","title":"Environment-Based Configuration","text":"<pre><code>config := &amp;echox402.Config{\n    PaymentAddress: os.Getenv(\"X402_PAYMENT_ADDRESS\"),\n    TokenMint:      os.Getenv(\"X402_TOKEN_MINT\"),\n}\n\nif os.Getenv(\"ENVIRONMENT\") == \"production\" {\n    config.Network = \"solana-mainnet\"\n    config.RPCURL = \"https://api.mainnet-beta.solana.com\"\n    config.AutoVerify = true\n} else {\n    config.Network = \"solana-devnet\"\n    config.RPCURL = \"https://api.devnet.solana.com\"\n    config.AutoVerify = false\n}\n\nechox402.InitX402(config)\n</code></pre>"},{"location":"go/middleware/echo/#production-setup","title":"Production Setup","text":""},{"location":"go/middleware/echo/#configuration_1","title":"Configuration","text":"<pre><code># Environment variables\nX402_PAYMENT_ADDRESS=\"YOUR_MAINNET_WALLET\"\nX402_TOKEN_MINT=\"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\"\nX402_NETWORK=\"solana-mainnet\"\nX402_RPC_URL=\"https://api.mainnet-beta.solana.com\"\n</code></pre>"},{"location":"go/middleware/echo/#https","title":"HTTPS","text":"<pre><code>e.StartTLS(\":443\", \"cert.pem\", \"key.pem\")\n</code></pre>"},{"location":"go/middleware/echo/#graceful-shutdown","title":"Graceful Shutdown","text":"<pre><code>e.Use(middleware.Logger())\ne.Use(middleware.Recover())\n\ngo func() {\n    if err := e.Start(\":8080\"); err != nil {\n        e.Logger.Info(\"shutting down:\", err)\n    }\n}()\n\nquit := make(chan os.Signal, 1)\nsignal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)\n&lt;-quit\n\nctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\ndefer cancel()\nif err := e.Shutdown(ctx); err != nil {\n    e.Logger.Fatal(err)\n}\n</code></pre>"},{"location":"go/middleware/echo/#testing","title":"Testing","text":""},{"location":"go/middleware/echo/#unit-test","title":"Unit Test","text":"<pre><code>func TestPremiumHandler(t *testing.T) {\n    e := echo.New()\n\n    echox402.InitX402(&amp;echox402.Config{\n        PaymentAddress: \"test_address\",\n        TokenMint:      \"test_mint\",\n    })\n\n    e.GET(\"/api/premium\", premiumHandler, echox402.PaymentRequired(echox402.PaymentRequiredOptions{\n        Amount: \"0.10\",\n    }))\n\n    req := httptest.NewRequest(echo.GET, \"/api/premium\", nil)\n    rec := httptest.NewRecorder()\n    c := e.NewContext(req, rec)\n\n    // Should return 402 without payment\n    assert.Equal(t, http.StatusPaymentRequired, rec.Code)\n}\n</code></pre>"},{"location":"go/middleware/echo/#troubleshooting","title":"Troubleshooting","text":""},{"location":"go/middleware/echo/#x402-not-initialized","title":"\"X402 not initialized\"","text":"<p>Solution: Call <code>InitX402()</code> before defining routes.</p> <pre><code>echox402.InitX402(&amp;echox402.Config{...})\ne := echo.New()\ne.GET(\"/api\", handler)\n</code></pre>"},{"location":"go/middleware/echo/#payment-not-recognized","title":"Payment not recognized","text":"<p>Solution: Ensure middleware is in correct position.</p> <pre><code>// Correct: middleware last\ne.GET(\"/api/data\", handler, echox402.PaymentRequired(opts))\n\n// Incorrect: middleware first\ne.GET(\"/api/data\", echox402.PaymentRequired(opts), handler)\n</code></pre>"},{"location":"go/middleware/echo/#see-also","title":"See Also","text":"<ul> <li>net/http Middleware - Alternative for standard library</li> <li>Server Quick Start</li> <li>Core Library</li> <li>Error Reference</li> </ul>"},{"location":"go/middleware/nethttp/","title":"net/http Middleware","text":"<p>Server-side X402 payment handling for Go's standard <code>net/http</code> package.</p>"},{"location":"go/middleware/nethttp/#overview","title":"Overview","text":"<p>The <code>openlibx402-nethttp</code> package provides middleware to require payments for HTTP endpoints using the standard library.</p>"},{"location":"go/middleware/nethttp/#installation","title":"Installation","text":"<pre><code>go get github.com/openlibx402/go/openlibx402-nethttp\n</code></pre>"},{"location":"go/middleware/nethttp/#quick-start","title":"Quick Start","text":"<pre><code>package main\n\nimport (\n    \"encoding/json\"\n    \"net/http\"\n    \"os\"\n\n    nethttp \"github.com/openlibx402/go/openlibx402-nethttp\"\n)\n\nfunc main() {\n    // Initialize global configuration\n    nethttp.InitX402(&amp;nethttp.Config{\n        PaymentAddress: os.Getenv(\"X402_PAYMENT_ADDRESS\"),\n        TokenMint:      os.Getenv(\"X402_TOKEN_MINT\"),\n        Network:        \"solana-devnet\",\n        AutoVerify:     true,\n    })\n\n    // Free endpoint\n    http.HandleFunc(\"/api/free\", freeHandler)\n\n    // Protected endpoint\n    http.Handle(\"/api/premium\", nethttp.PaymentRequired(nethttp.PaymentRequiredOptions{\n        Amount: \"0.10\",\n    })(http.HandlerFunc(premiumHandler)))\n\n    http.ListenAndServe(\":8080\", nil)\n}\n\nfunc freeHandler(w http.ResponseWriter, r *http.Request) {\n    json.NewEncoder(w).Encode(map[string]string{\"data\": \"free\"})\n}\n\nfunc premiumHandler(w http.ResponseWriter, r *http.Request) {\n    json.NewEncoder(w).Encode(map[string]string{\"data\": \"premium\"})\n}\n</code></pre>"},{"location":"go/middleware/nethttp/#configuration","title":"Configuration","text":""},{"location":"go/middleware/nethttp/#initx402","title":"InitX402()","text":"<p>Initialize global X402 configuration. Call once at startup.</p> <pre><code>nethttp.InitX402(&amp;nethttp.Config{\n    PaymentAddress: \"YOUR_SOLANA_WALLET\",      // Required\n    TokenMint:      \"USDC_MINT_ADDRESS\",       // Required\n    Network:        \"solana-devnet\",           // Optional: default shown\n    RPCURL:         \"https://api.devnet...\",   // Optional\n    AutoVerify:     true,                      // Optional: default shown\n})\n</code></pre>"},{"location":"go/middleware/nethttp/#config-fields","title":"Config Fields","text":"Field Type Required Default Description PaymentAddress string Yes - Wallet receiving payments TokenMint string Yes - SPL token mint address Network string No \"solana-devnet\" Solana network RPCURL string No Auto RPC endpoint AutoVerify bool No false Verify payments on-chain"},{"location":"go/middleware/nethttp/#middleware","title":"Middleware","text":""},{"location":"go/middleware/nethttp/#paymentrequired","title":"PaymentRequired()","text":"<p>Add payment requirement to endpoints.</p> <pre><code>http.Handle(\"/endpoint\", nethttp.PaymentRequired(nethttp.PaymentRequiredOptions{\n    Amount: \"0.10\",\n})(handler))\n</code></pre>"},{"location":"go/middleware/nethttp/#options","title":"Options","text":"<pre><code>nethttp.PaymentRequired(nethttp.PaymentRequiredOptions{\n    Amount:         \"0.10\",                 // Required: payment amount\n    PaymentAddress: \"override_address\",     // Optional: override global\n    TokenMint:      \"override_mint\",        // Optional: override global\n    Network:        \"solana-mainnet\",       // Optional: override global\n    Description:    \"Premium data access\", // Optional: human-readable\n    ExpiresIn:      300,                    // Optional: seconds\n    AutoVerify:     true,                   // Optional: verify on-chain\n})\n</code></pre>"},{"location":"go/middleware/nethttp/#accessing-payment-details","title":"Accessing Payment Details","text":"<p>Use <code>GetPaymentAuthorization()</code> in your handler:</p> <pre><code>func myHandler(w http.ResponseWriter, r *http.Request) {\n    auth := nethttp.GetPaymentAuthorization(r)\n    if auth != nil {\n        log.Printf(\"Payment ID: %s\", auth.PaymentID)\n        log.Printf(\"Amount: %s\", auth.ActualAmount)\n        log.Printf(\"Payer: %s\", auth.PublicKey)\n    }\n\n    // Serve content\n    json.NewEncoder(w).Encode(data)\n}\n</code></pre>"},{"location":"go/middleware/nethttp/#paymentauthorization-fields","title":"PaymentAuthorization Fields","text":"<pre><code>type PaymentAuthorization struct {\n    PaymentID       string    // From payment request\n    ActualAmount    string    // Amount paid\n    PaymentAddress  string    // Recipient wallet\n    AssetAddress    string    // Token mint\n    Network         string    // Blockchain network\n    Timestamp       time.Time // When authorized\n    Signature       string    // Transaction signature\n    PublicKey       string    // Payer's wallet\n    TransactionHash string    // On-chain tx hash\n}\n</code></pre>"},{"location":"go/middleware/nethttp/#patterns","title":"Patterns","text":""},{"location":"go/middleware/nethttp/#multiple-pricing-tiers","title":"Multiple Pricing Tiers","text":"<pre><code>// Free tier\nhttp.HandleFunc(\"/api/free\", freeHandler)\n\n// Basic tier ($0.05)\nhttp.Handle(\"/api/basic\",\n    nethttp.PaymentRequired(nethttp.PaymentRequiredOptions{\n        Amount: \"0.05\",\n    })(http.HandlerFunc(basicHandler)))\n\n// Standard tier ($0.10)\nhttp.Handle(\"/api/standard\",\n    nethttp.PaymentRequired(nethttp.PaymentRequiredOptions{\n        Amount: \"0.10\",\n    })(http.HandlerFunc(standardHandler)))\n\n// Premium tier ($1.00)\nhttp.Handle(\"/api/premium\",\n    nethttp.PaymentRequired(nethttp.PaymentRequiredOptions{\n        Amount: \"1.00\",\n    })(http.HandlerFunc(premiumHandler)))\n</code></pre>"},{"location":"go/middleware/nethttp/#different-token-per-endpoint","title":"Different Token Per Endpoint","text":"<pre><code>// USDC endpoint\nhttp.Handle(\"/api/usdc\",\n    nethttp.PaymentRequired(nethttp.PaymentRequiredOptions{\n        Amount: \"0.10\",\n        TokenMint: \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\",\n    })(handler))\n\n// Custom token endpoint\nhttp.Handle(\"/api/custom\",\n    nethttp.PaymentRequired(nethttp.PaymentRequiredOptions{\n        Amount: \"100.00\",\n        TokenMint: \"YOUR_CUSTOM_TOKEN_MINT\",\n    })(handler))\n</code></pre>"},{"location":"go/middleware/nethttp/#logging-payments","title":"Logging Payments","text":"<pre><code>func loggedPaymentHandler(w http.ResponseWriter, r *http.Request) {\n    auth := nethttp.GetPaymentAuthorization(r)\n    if auth != nil {\n        log.Printf(\"[PAYMENT] %s paid %s USDC (TX: %s)\",\n            auth.PublicKey[:8],\n            auth.ActualAmount,\n            auth.TransactionHash[:8])\n    }\n\n    json.NewEncoder(w).Encode(data)\n}\n\nhttp.Handle(\"/api/logged\",\n    nethttp.PaymentRequired(nethttp.PaymentRequiredOptions{\n        Amount: \"0.10\",\n    })(http.HandlerFunc(loggedPaymentHandler)))\n</code></pre>"},{"location":"go/middleware/nethttp/#custom-handler-wrapper","title":"Custom Handler Wrapper","text":"<pre><code>func withPayment(amount string, handler http.HandlerFunc) http.Handler {\n    return nethttp.PaymentRequired(nethttp.PaymentRequiredOptions{\n        Amount: amount,\n    })(handler)\n}\n\n// Usage\nhttp.Handle(\"/api/data\", withPayment(\"0.10\", myDataHandler))\nhttp.Handle(\"/api/export\", withPayment(\"1.00\", myExportHandler))\n</code></pre>"},{"location":"go/middleware/nethttp/#conditional-payment","title":"Conditional Payment","text":"<pre><code>func conditionalHandler(w http.ResponseWriter, r *http.Request) {\n    // Get query parameter\n    tier := r.URL.Query().Get(\"tier\")\n\n    // Determine if payment needed\n    if tier != \"free\" &amp;&amp; tier != \"\" {\n        // Payment was required before reaching here\n        // Middleware already handled it\n        auth := nethttp.GetPaymentAuthorization(r)\n        if auth == nil {\n            http.Error(w, \"Payment required\", http.StatusForbidden)\n            return\n        }\n    }\n\n    json.NewEncoder(w).Encode(data)\n}\n\n// Note: For conditional payment, you may need custom logic\n// or use explicit payment in your handler\n</code></pre>"},{"location":"go/middleware/nethttp/#request-metadata","title":"Request Metadata","text":"<pre><code>func trackingHandler(w http.ResponseWriter, r *http.Request) {\n    auth := nethttp.GetPaymentAuthorization(r)\n\n    // Log request details\n    log.Printf(\"Request: %s %s\", r.Method, r.URL.Path)\n    log.Printf(\"Payer: %s\", auth.PublicKey)\n    log.Printf(\"Amount: %s\", auth.ActualAmount)\n\n    // Could update analytics, billing, etc.\n    updateAnalytics(r.URL.Path, auth.PublicKey, auth.ActualAmount)\n\n    json.NewEncoder(w).Encode(data)\n}\n\nhttp.Handle(\"/api/tracked\",\n    nethttp.PaymentRequired(nethttp.PaymentRequiredOptions{\n        Amount: \"0.10\",\n    })(http.HandlerFunc(trackingHandler)))\n</code></pre>"},{"location":"go/middleware/nethttp/#error-handling","title":"Error Handling","text":"<p>The middleware automatically handles errors:</p> <ul> <li>No payment header: Returns 402 with PaymentRequest</li> <li>Invalid payment: Returns 400 Bad Request</li> <li>Verification failed: Returns 403 Forbidden</li> <li>Amount insufficient: Returns 403 Forbidden</li> <li>Address mismatch: Returns 403 Forbidden</li> </ul> <p>Your handler won't be called if payment fails.</p>"},{"location":"go/middleware/nethttp/#configuration-override","title":"Configuration Override","text":""},{"location":"go/middleware/nethttp/#per-handler-override","title":"Per-Handler Override","text":"<pre><code>nethttp.InitX402(&amp;nethttp.Config{\n    PaymentAddress: \"default_address\",\n    TokenMint:      \"default_mint\",\n})\n\n// Override for specific endpoint\nhttp.Handle(\"/api/premium\",\n    nethttp.PaymentRequired(nethttp.PaymentRequiredOptions{\n        Amount:         \"0.10\",\n        PaymentAddress: \"different_address\",\n        TokenMint:      \"different_mint\",\n    })(handler))\n</code></pre>"},{"location":"go/middleware/nethttp/#environment-based-configuration","title":"Environment-Based Configuration","text":"<pre><code>config := &amp;nethttp.Config{\n    PaymentAddress: os.Getenv(\"X402_PAYMENT_ADDRESS\"),\n    TokenMint:      os.Getenv(\"X402_TOKEN_MINT\"),\n}\n\nif os.Getenv(\"X402_MAINNET\") == \"true\" {\n    config.Network = \"solana-mainnet\"\n    config.RPCURL = \"https://api.mainnet-beta.solana.com\"\n} else {\n    config.Network = \"solana-devnet\"\n    config.RPCURL = \"https://api.devnet.solana.com\"\n}\n\nnethttp.InitX402(config)\n</code></pre>"},{"location":"go/middleware/nethttp/#production-setup","title":"Production Setup","text":""},{"location":"go/middleware/nethttp/#configuration_1","title":"Configuration","text":"<pre><code># .env or environment variables\nX402_PAYMENT_ADDRESS=\"YOUR_MAINNET_WALLET\"\nX402_TOKEN_MINT=\"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\"\nX402_NETWORK=\"solana-mainnet\"\nX402_RPC_URL=\"https://api.mainnet-beta.solana.com\"\nPORT=443\n</code></pre>"},{"location":"go/middleware/nethttp/#ssltls","title":"SSL/TLS","text":"<pre><code>http.ListenAndServeTLS(\":443\", \"cert.pem\", \"key.pem\", nil)\n</code></pre>"},{"location":"go/middleware/nethttp/#rate-limiting","title":"Rate Limiting","text":"<pre><code>import \"golang.org/x/time/rate\"\n\nvar limiter = rate.NewLimiter(100, 10) // 100 req/s, burst 10\n\nfunc rateLimited(handler http.HandlerFunc) http.HandlerFunc {\n    return func(w http.ResponseWriter, r *http.Request) {\n        if !limiter.Allow() {\n            http.Error(w, \"Rate limited\", http.StatusTooManyRequests)\n            return\n        }\n        handler(w, r)\n    }\n}\n\nhttp.Handle(\"/api/data\",\n    rateLimited(nethttp.PaymentRequired(opts)(handler)))\n</code></pre>"},{"location":"go/middleware/nethttp/#testing","title":"Testing","text":""},{"location":"go/middleware/nethttp/#mock-payment","title":"Mock Payment","text":"<p>For testing without real payments:</p> <pre><code>func testHandler(t *testing.T) {\n    // In test, you can mock the middleware\n    // Or use devnet with test tokens\n    rec := httptest.NewRecorder()\n    req := httptest.NewRequest(\"GET\", \"/api/premium\", nil)\n\n    // Handler will return 402 in test without payment auth\n    handler(rec, req)\n    assert.Equal(t, http.StatusPaymentRequired, rec.Code)\n}\n</code></pre>"},{"location":"go/middleware/nethttp/#troubleshooting","title":"Troubleshooting","text":""},{"location":"go/middleware/nethttp/#x402-not-initialized-error","title":"\"X402 not initialized\" error","text":"<pre><code>Error: X402 not initialized. Call InitX402() first.\n</code></pre> <p>Solution: Call <code>InitX402()</code> before defining routes.</p> <pre><code>nethttp.InitX402(&amp;nethttp.Config{...})\nhttp.Handle(\"/api\", myHandler)\n</code></pre>"},{"location":"go/middleware/nethttp/#paymentaddress-and-tokenmint-must-be-configured","title":"\"paymentAddress and tokenMint must be configured\"","text":"<p>Solution: Set environment variables or pass to <code>InitX402()</code>.</p> <pre><code>export X402_PAYMENT_ADDRESS=\"YOUR_ADDRESS\"\nexport X402_TOKEN_MINT=\"YOUR_MINT\"\n</code></pre>"},{"location":"go/middleware/nethttp/#payment-verification-failures","title":"Payment verification failures","text":"<p>Solution: Check RPC endpoint and network configuration.</p> <pre><code>config := nethttp.Config{\n    Network: \"solana-devnet\",\n    RPCURL:  \"https://api.devnet.solana.com\",\n    AutoVerify: false,  // Disable if RPC is slow\n}\n</code></pre>"},{"location":"go/middleware/nethttp/#see-also","title":"See Also","text":"<ul> <li>Echo Middleware - Alternative framework</li> <li>Server Quick Start</li> <li>Core Library</li> <li>Error Reference</li> </ul>"},{"location":"go/reference/api-reference/","title":"API Reference","text":"<p>Complete API reference for all X402 Go packages.</p>"},{"location":"go/reference/api-reference/#core-package-openlibx402-core","title":"Core Package (<code>openlibx402-core</code>)","text":""},{"location":"go/reference/api-reference/#paymentrequest","title":"PaymentRequest","text":"<p>Represents a 402 payment request from a server.</p>"},{"location":"go/reference/api-reference/#structure","title":"Structure","text":"<pre><code>type PaymentRequest struct {\n    MaxAmountRequired string\n    AssetType         string\n    AssetAddress      string\n    PaymentAddress    string\n    Network           string\n    ExpiresAt         time.Time\n    Nonce             string\n    PaymentID         string\n    Resource          string\n    Description       string\n}\n</code></pre>"},{"location":"go/reference/api-reference/#methods","title":"Methods","text":"Method Signature Returns Description <code>IsExpired()</code> <code>IsExpired() bool</code> <code>bool</code> Check if payment request has expired <code>ToJSON()</code> <code>ToJSON() (string, error)</code> <code>(string, error)</code> Convert to JSON string"},{"location":"go/reference/api-reference/#functions","title":"Functions","text":"Function Signature Returns Description <code>PaymentRequestFromJSON()</code> <code>PaymentRequestFromJSON(jsonStr string) (*PaymentRequest, error)</code> <code>(*PaymentRequest, error)</code> Parse from JSON string"},{"location":"go/reference/api-reference/#paymentauthorization","title":"PaymentAuthorization","text":"<p>Represents a signed payment authorization for retry requests.</p>"},{"location":"go/reference/api-reference/#structure_1","title":"Structure","text":"<pre><code>type PaymentAuthorization struct {\n    PaymentID       string\n    ActualAmount    string\n    PaymentAddress  string\n    AssetAddress    string\n    Network         string\n    Timestamp       time.Time\n    Signature       string\n    PublicKey       string\n    TransactionHash string\n}\n</code></pre>"},{"location":"go/reference/api-reference/#methods_1","title":"Methods","text":"Method Signature Returns Description <code>ToHeaderValue()</code> <code>ToHeaderValue() (string, error)</code> <code>(string, error)</code> Encode as base64 JSON for HTTP header <code>ToJSON()</code> <code>ToJSON() (string, error)</code> <code>(string, error)</code> Convert to JSON string"},{"location":"go/reference/api-reference/#functions_1","title":"Functions","text":"Function Signature Returns Description <code>PaymentAuthorizationFromHeader()</code> <code>PaymentAuthorizationFromHeader(headerValue string) (*PaymentAuthorization, error)</code> <code>(*PaymentAuthorization, error)</code> Parse from HTTP header"},{"location":"go/reference/api-reference/#solanapaymentprocessor","title":"SolanaPaymentProcessor","text":"<p>Handles Solana blockchain operations.</p>"},{"location":"go/reference/api-reference/#constructor","title":"Constructor","text":"<pre><code>func NewSolanaPaymentProcessor(\n    rpcURL string,\n    keypair *solana.PrivateKey,\n) *SolanaPaymentProcessor\n</code></pre>"},{"location":"go/reference/api-reference/#methods_2","title":"Methods","text":"Method Signature Returns Description <code>CreatePaymentTransaction()</code> <code>CreatePaymentTransaction(ctx context.Context, paymentReq *PaymentRequest, amount string, keypair solana.PrivateKey) (*solana.Transaction, error)</code> <code>(*solana.Transaction, error)</code> Create payment transaction <code>SignAndSendTransaction()</code> <code>SignAndSendTransaction(ctx context.Context, tx *solana.Transaction, keypair solana.PrivateKey) (string, error)</code> <code>(string, error)</code> Sign and broadcast transaction <code>VerifyTransaction()</code> <code>VerifyTransaction(ctx context.Context, txHash string, recipient string, amount string, tokenMint string) (bool, error)</code> <code>(bool, error)</code> Verify transaction on-chain <code>GetTokenBalance()</code> <code>GetTokenBalance(ctx context.Context, walletAddress string, tokenMint string) (float64, error)</code> <code>(float64, error)</code> Get SPL token balance <code>Close()</code> <code>Close()</code> - Close processor and cleanup resources"},{"location":"go/reference/api-reference/#functions_2","title":"Functions","text":"Function Signature Returns Description <code>GetDefaultRPCURL()</code> <code>GetDefaultRPCURL(network string) string</code> <code>string</code> Get default RPC URL for network"},{"location":"go/reference/api-reference/#error-types","title":"Error Types","text":""},{"location":"go/reference/api-reference/#x402error","title":"X402Error","text":"<p>Base error type.</p> <pre><code>type X402Error struct {\n    Message string\n    Code    string\n    Details map[string]interface{}\n}\n</code></pre>"},{"location":"go/reference/api-reference/#paymentrequirederror","title":"PaymentRequiredError","text":"<p>Raised when 402 response is received.</p> <pre><code>func NewPaymentRequiredError(paymentReq *PaymentRequest, message string) error\n</code></pre>"},{"location":"go/reference/api-reference/#paymentexpirederror","title":"PaymentExpiredError","text":"<p>Payment request has expired.</p> <pre><code>func NewPaymentExpiredError(paymentReq *PaymentRequest, message string) error\n</code></pre>"},{"location":"go/reference/api-reference/#insufficientfundserror","title":"InsufficientFundsError","text":"<p>Wallet lacks sufficient funds.</p> <pre><code>func NewInsufficientFundsError(required string, available string) error\n</code></pre>"},{"location":"go/reference/api-reference/#paymentverificationerror","title":"PaymentVerificationError","text":"<p>Payment verification failed.</p> <pre><code>func NewPaymentVerificationError(message string) error\n</code></pre>"},{"location":"go/reference/api-reference/#transactionbroadcasterror","title":"TransactionBroadcastError","text":"<p>Failed to broadcast transaction.</p> <pre><code>func NewTransactionBroadcastError(message string) error\n</code></pre>"},{"location":"go/reference/api-reference/#invalidpaymentrequesterror","title":"InvalidPaymentRequestError","text":"<p>Invalid payment request format.</p> <pre><code>func NewInvalidPaymentRequestError(message string) error\n</code></pre>"},{"location":"go/reference/api-reference/#client-package-openlibx402-client","title":"Client Package (<code>openlibx402-client</code>)","text":""},{"location":"go/reference/api-reference/#x402client-explicit-mode","title":"X402Client (Explicit Mode)","text":"<p>Manual payment control HTTP client.</p>"},{"location":"go/reference/api-reference/#constructor_1","title":"Constructor","text":"<pre><code>func NewX402Client(\n    walletKeypair solana.PrivateKey,\n    rpcURL string,\n    httpClient *http.Client,\n    allowLocal bool,\n) *X402Client\n</code></pre>"},{"location":"go/reference/api-reference/#methods_3","title":"Methods","text":"Method Signature Returns Description <code>Get()</code> <code>Get(ctx context.Context, url string, auth *core.PaymentAuthorization) (*http.Response, error)</code> <code>(*http.Response, error)</code> Execute GET request <code>Post()</code> <code>Post(ctx context.Context, url string, body []byte, auth *core.PaymentAuthorization) (*http.Response, error)</code> <code>(*http.Response, error)</code> Execute POST request <code>Put()</code> <code>Put(ctx context.Context, url string, body []byte, auth *core.PaymentAuthorization) (*http.Response, error)</code> <code>(*http.Response, error)</code> Execute PUT request <code>Delete()</code> <code>Delete(ctx context.Context, url string, auth *core.PaymentAuthorization) (*http.Response, error)</code> <code>(*http.Response, error)</code> Execute DELETE request <code>Do()</code> <code>Do(ctx context.Context, req *http.Request, auth *core.PaymentAuthorization) (*http.Response, error)</code> <code>(*http.Response, error)</code> Execute any HTTP request <code>PaymentRequired()</code> <code>PaymentRequired(resp *http.Response) bool</code> <code>bool</code> Check if response is 402 Payment Required <code>ParsePaymentRequest()</code> <code>ParsePaymentRequest(resp *http.Response) (*core.PaymentRequest, error)</code> <code>(*core.PaymentRequest, error)</code> Parse PaymentRequest from 402 response <code>CreatePayment()</code> <code>CreatePayment(ctx context.Context, paymentReq *core.PaymentRequest, customAmount string) (*core.PaymentAuthorization, error)</code> <code>(*core.PaymentAuthorization, error)</code> Create and broadcast payment <code>Close()</code> <code>Close()</code> - Close client and cleanup"},{"location":"go/reference/api-reference/#x402autoclient-automatic-mode","title":"X402AutoClient (Automatic Mode)","text":"<p>Automatic payment handling HTTP client.</p>"},{"location":"go/reference/api-reference/#constructor_2","title":"Constructor","text":"<pre><code>func NewAutoClient(\n    walletKeypair solana.PrivateKey,\n    rpcURL string,\n    options *AutoClientOptions,\n) *X402AutoClient\n</code></pre>"},{"location":"go/reference/api-reference/#options","title":"Options","text":"<pre><code>type AutoClientOptions struct {\n    MaxPaymentAmount string // e.g., \"10.0\"\n    AutoRetry        bool\n    AllowLocal       bool\n}\n</code></pre>"},{"location":"go/reference/api-reference/#methods_4","title":"Methods","text":"Method Signature Returns Description <code>Get()</code> <code>Get(ctx context.Context, url string) (*http.Response, error)</code> <code>(*http.Response, error)</code> GET (auto-pays if needed) <code>Post()</code> <code>Post(ctx context.Context, url string, body []byte) (*http.Response, error)</code> <code>(*http.Response, error)</code> POST (auto-pays if needed) <code>Put()</code> <code>Put(ctx context.Context, url string, body []byte) (*http.Response, error)</code> <code>(*http.Response, error)</code> PUT (auto-pays if needed) <code>Delete()</code> <code>Delete(ctx context.Context, url string) (*http.Response, error)</code> <code>(*http.Response, error)</code> DELETE (auto-pays if needed) <code>Close()</code> <code>Close()</code> - Close client and cleanup"},{"location":"go/reference/api-reference/#nethttp-middleware-openlibx402-nethttp","title":"net/http Middleware (<code>openlibx402-nethttp</code>)","text":""},{"location":"go/reference/api-reference/#initialization","title":"Initialization","text":"<pre><code>func InitX402(config *Config)\n</code></pre>"},{"location":"go/reference/api-reference/#config","title":"Config","text":"<pre><code>type Config struct {\n    PaymentAddress string // Required\n    TokenMint      string // Required\n    Network        string // Optional, default: \"solana-devnet\"\n    RPCURL         string // Optional\n    AutoVerify     bool   // Optional, default: false\n}\n</code></pre>"},{"location":"go/reference/api-reference/#middleware","title":"Middleware","text":"<pre><code>func PaymentRequired(options PaymentRequiredOptions) func(http.Handler) http.Handler\n</code></pre>"},{"location":"go/reference/api-reference/#paymentrequiredoptions","title":"PaymentRequiredOptions","text":"<pre><code>type PaymentRequiredOptions struct {\n    Amount         string // Required\n    PaymentAddress string // Optional\n    TokenMint      string // Optional\n    Network        string // Optional\n    Description    string // Optional\n    ExpiresIn      int    // Optional, default: 300 seconds\n    AutoVerify     bool   // Optional\n}\n</code></pre>"},{"location":"go/reference/api-reference/#helper-functions","title":"Helper Functions","text":"<pre><code>// Get payment authorization from request\nfunc GetPaymentAuthorization(r *http.Request) *core.PaymentAuthorization\n</code></pre>"},{"location":"go/reference/api-reference/#echo-middleware-openlibx402-echo","title":"Echo Middleware (<code>openlibx402-echo</code>)","text":""},{"location":"go/reference/api-reference/#initialization_1","title":"Initialization","text":"<pre><code>func InitX402(config *Config)\n</code></pre>"},{"location":"go/reference/api-reference/#config_1","title":"Config","text":"<pre><code>type Config struct {\n    PaymentAddress string // Required\n    TokenMint      string // Required\n    Network        string // Optional, default: \"solana-devnet\"\n    RPCURL         string // Optional\n    AutoVerify     bool   // Optional, default: false\n}\n</code></pre>"},{"location":"go/reference/api-reference/#middleware_1","title":"Middleware","text":"<pre><code>func PaymentRequired(options PaymentRequiredOptions) echo.MiddlewareFunc\n</code></pre>"},{"location":"go/reference/api-reference/#paymentrequiredoptions_1","title":"PaymentRequiredOptions","text":"<pre><code>type PaymentRequiredOptions struct {\n    Amount         string // Required\n    PaymentAddress string // Optional\n    TokenMint      string // Optional\n    Network        string // Optional\n    Description    string // Optional\n    ExpiresIn      int    // Optional, default: 300 seconds\n    AutoVerify     bool   // Optional\n}\n</code></pre>"},{"location":"go/reference/api-reference/#helper-functions_1","title":"Helper Functions","text":"<pre><code>// Get payment authorization from Echo context\nfunc GetPaymentAuthorization(c echo.Context) *core.PaymentAuthorization\n</code></pre>"},{"location":"go/reference/api-reference/#http-headers","title":"HTTP Headers","text":""},{"location":"go/reference/api-reference/#request-headers","title":"Request Headers","text":""},{"location":"go/reference/api-reference/#x-payment-authorization","title":"X-Payment-Authorization","text":"<p>Payment authorization header included in requests after 402 response.</p> <pre><code>X-Payment-Authorization: &lt;base64-encoded-json&gt;\n</code></pre> <p>Format: <pre><code>{\n  \"payment_id\": \"...\",\n  \"actual_amount\": \"0.10\",\n  \"payment_address\": \"...\",\n  \"asset_address\": \"...\",\n  \"network\": \"solana-devnet\",\n  \"timestamp\": \"2024-01-01T00:00:00Z\",\n  \"signature\": \"...\",\n  \"public_key\": \"...\",\n  \"transaction_hash\": \"...\"\n}\n</code></pre></p>"},{"location":"go/reference/api-reference/#response-headers","title":"Response Headers","text":""},{"location":"go/reference/api-reference/#402-payment-required","title":"402 Payment Required","text":"<p>Status code: <code>402</code></p> <p>Response body (JSON): <pre><code>{\n  \"max_amount_required\": \"0.10\",\n  \"asset_type\": \"SPL\",\n  \"asset_address\": \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\",\n  \"payment_address\": \"YOUR_WALLET_ADDRESS\",\n  \"network\": \"solana-devnet\",\n  \"expires_at\": \"2025-01-01T00:05:00Z\",\n  \"nonce\": \"abc123...\",\n  \"payment_id\": \"def456...\",\n  \"resource\": \"/api/endpoint\",\n  \"description\": \"Endpoint description\"\n}\n</code></pre></p>"},{"location":"go/reference/api-reference/#error-codes","title":"Error Codes","text":""},{"location":"go/reference/api-reference/#payment-required-402","title":"Payment Required (402)","text":"<pre><code>Code: PAYMENT_REQUIRED\nHTTP Status: 402\nRetry: Yes\nUser Action: Make payment and retry with authorization header\n</code></pre>"},{"location":"go/reference/api-reference/#payment-expired","title":"Payment Expired","text":"<pre><code>Code: PAYMENT_EXPIRED\nHTTP Status: 402 or 400\nRetry: Yes\nUser Action: Request new payment\n</code></pre>"},{"location":"go/reference/api-reference/#insufficient-funds","title":"Insufficient Funds","text":"<pre><code>Code: INSUFFICIENT_FUNDS\nHTTP Status: 400\nRetry: No\nUser Action: Add funds to wallet\n</code></pre>"},{"location":"go/reference/api-reference/#payment-verification-failed","title":"Payment Verification Failed","text":"<pre><code>Code: PAYMENT_VERIFICATION_FAILED\nHTTP Status: 403\nRetry: Yes\nUser Action: Retry or contact support\n</code></pre>"},{"location":"go/reference/api-reference/#transaction-broadcast-failed","title":"Transaction Broadcast Failed","text":"<pre><code>Code: TRANSACTION_BROADCAST_FAILED\nHTTP Status: 500\nRetry: Yes\nUser Action: Check network connectivity and retry\n</code></pre>"},{"location":"go/reference/api-reference/#invalid-payment-request","title":"Invalid Payment Request","text":"<pre><code>Code: INVALID_PAYMENT_REQUEST\nHTTP Status: 400\nRetry: No\nUser Action: Contact API provider\n</code></pre>"},{"location":"go/reference/api-reference/#constants-and-defaults","title":"Constants and Defaults","text":""},{"location":"go/reference/api-reference/#solana-networks","title":"Solana Networks","text":"<pre><code>const (\n    NetworkDevnet   = \"solana-devnet\"\n    NetworkTestnet  = \"solana-testnet\"\n    NetworkMainnet  = \"solana-mainnet\"\n)\n</code></pre>"},{"location":"go/reference/api-reference/#default-rpc-endpoints","title":"Default RPC Endpoints","text":"Network URL devnet <code>https://api.devnet.solana.com</code> testnet <code>https://api.testnet.solana.com</code> mainnet <code>https://api.mainnet-beta.solana.com</code>"},{"location":"go/reference/api-reference/#default-values","title":"Default Values","text":"<pre><code>const (\n    DefaultNetwork         = \"solana-devnet\"\n    DefaultExpiresIn       = 300  // seconds\n    DefaultMaxPaymentLimit = \"10.0\"\n)\n</code></pre>"},{"location":"go/reference/api-reference/#type-aliases","title":"Type Aliases","text":"<pre><code>// Solana types\ntype Address = string        // Base58-encoded wallet address\ntype Signature = string      // Solana transaction signature\ntype TokenMint = string      // SPL token mint address\ntype Amount = string         // Token amount as decimal string\n</code></pre>"},{"location":"go/reference/api-reference/#common-patterns","title":"Common Patterns","text":""},{"location":"go/reference/api-reference/#create-client","title":"Create Client","text":"<p>Explicit Mode: <pre><code>client := client.NewX402Client(keypair, \"\", nil, false)\ndefer client.Close()\n</code></pre></p> <p>Automatic Mode: <pre><code>client := client.NewAutoClient(keypair, \"\", &amp;client.AutoClientOptions{\n    MaxPaymentAmount: \"10.0\",\n})\ndefer client.Close()\n</code></pre></p>"},{"location":"go/reference/api-reference/#initialize-middleware","title":"Initialize Middleware","text":"<p>net/http: <pre><code>nethttp.InitX402(&amp;nethttp.Config{\n    PaymentAddress: os.Getenv(\"X402_PAYMENT_ADDRESS\"),\n    TokenMint:      os.Getenv(\"X402_TOKEN_MINT\"),\n})\n</code></pre></p> <p>Echo: <pre><code>echox402.InitX402(&amp;echox402.Config{\n    PaymentAddress: os.Getenv(\"X402_PAYMENT_ADDRESS\"),\n    TokenMint:      os.Getenv(\"X402_TOKEN_MINT\"),\n})\n</code></pre></p>"},{"location":"go/reference/api-reference/#protect-endpoint","title":"Protect Endpoint","text":"<p>net/http: <pre><code>http.Handle(\"/api/premium\", nethttp.PaymentRequired(nethttp.PaymentRequiredOptions{\n    Amount: \"0.10\",\n})(handler))\n</code></pre></p> <p>Echo: <pre><code>e.GET(\"/api/premium\", handler, echox402.PaymentRequired(echox402.PaymentRequiredOptions{\n    Amount: \"0.10\",\n}))\n</code></pre></p>"},{"location":"go/reference/api-reference/#access-payment-info","title":"Access Payment Info","text":"<p>net/http: <pre><code>auth := nethttp.GetPaymentAuthorization(r)\nif auth != nil {\n    log.Printf(\"Payment: %s\", auth.ActualAmount)\n}\n</code></pre></p> <p>Echo: <pre><code>auth := echox402.GetPaymentAuthorization(c)\nif auth != nil {\n    log.Printf(\"Payment: %s\", auth.ActualAmount)\n}\n</code></pre></p>"},{"location":"go/reference/api-reference/#see-also","title":"See Also","text":"<ul> <li>Core Library Documentation</li> <li>Client Library Documentation</li> <li>net/http Middleware</li> <li>Echo Middleware</li> </ul>"},{"location":"go/reference/configuration/","title":"Configuration Reference","text":"<p>Complete guide to configuring X402 for different use cases and environments.</p>"},{"location":"go/reference/configuration/#environment-variables","title":"Environment Variables","text":""},{"location":"go/reference/configuration/#core-configuration","title":"Core Configuration","text":""},{"location":"go/reference/configuration/#x402_payment_address-required","title":"X402_PAYMENT_ADDRESS (Required)","text":"<p>The Solana wallet address that receives payments.</p> <pre><code>export X402_PAYMENT_ADDRESS=\"YOUR_SOLANA_WALLET_ADDRESS\"\n</code></pre> <p>Format: Base58-encoded Solana wallet address Example: <code>EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v</code> Used by: Server middleware</p>"},{"location":"go/reference/configuration/#x402_token_mint-required","title":"X402_TOKEN_MINT (Required)","text":"<p>The SPL token mint address for payments.</p> <pre><code>export X402_TOKEN_MINT=\"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\"\n</code></pre> <p>Format: Base58-encoded token mint address Example (USDC devnet): <code>EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v</code> Example (USDC mainnet): <code>EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v</code> Used by: Server middleware, payment processor</p>"},{"location":"go/reference/configuration/#network-configuration","title":"Network Configuration","text":""},{"location":"go/reference/configuration/#x402_network-optional","title":"X402_NETWORK (Optional)","text":"<p>Solana network to use.</p> <pre><code>export X402_NETWORK=\"solana-devnet\"  # Development\nexport X402_NETWORK=\"solana-testnet\"  # Testing\nexport X402_NETWORK=\"solana-mainnet\"  # Production\n</code></pre> <p>Default: <code>solana-devnet</code> Valid values: <code>solana-devnet</code>, <code>solana-testnet</code>, <code>solana-mainnet</code> Used by: Core processor, all clients</p>"},{"location":"go/reference/configuration/#x402_rpc_url-optional","title":"X402_RPC_URL (Optional)","text":"<p>Custom Solana RPC endpoint.</p> <pre><code># Use default for network\n# Omit to use automatic endpoint\n\n# Or specify custom endpoint\nexport X402_RPC_URL=\"https://api.devnet.solana.com\"\nexport X402_RPC_URL=\"https://api.testnet.solana.com\"\nexport X402_RPC_URL=\"https://api.mainnet-beta.solana.com\"\n\n# Or use custom RPC service\nexport X402_RPC_URL=\"https://your-custom-rpc.com\"\n</code></pre> <p>Default: Auto-selected based on network Used by: Core processor, payment verification</p>"},{"location":"go/reference/configuration/#client-configuration","title":"Client Configuration","text":""},{"location":"go/reference/configuration/#x402_private_key-client-only","title":"X402_PRIVATE_KEY (Client Only)","text":"<p>Base58-encoded wallet private key for client.</p> <pre><code>export X402_PRIVATE_KEY=\"your-base58-private-key\"\n</code></pre> <p>Format: Base58-encoded Solana private key Security: Store in secure environment variable, never hardcode Used by: Client library</p>"},{"location":"go/reference/configuration/#x402_max_payment-optional","title":"X402_MAX_PAYMENT (Optional)","text":"<p>Maximum amount to pay per transaction (safety limit).</p> <pre><code>export X402_MAX_PAYMENT=\"10.0\"  # Maximum 10 USDC\n</code></pre> <p>Default: <code>10.0</code> (if using AutoClient with no options) Format: Decimal string representing token units Used by: AutoClient for payment limits</p>"},{"location":"go/reference/configuration/#server-configuration","title":"Server Configuration","text":""},{"location":"go/reference/configuration/#port-optional","title":"PORT (Optional)","text":"<p>Server listening port.</p> <pre><code>export PORT=\"8080\"  # Default for development\nexport PORT=\"443\"   # HTTPS in production\n</code></pre> <p>Default: <code>8080</code> Used by: Example servers</p>"},{"location":"go/reference/configuration/#middleware-configuration","title":"Middleware Configuration","text":""},{"location":"go/reference/configuration/#nethttp-middleware","title":"net/http Middleware","text":""},{"location":"go/reference/configuration/#initx402-config-structure","title":"InitX402() Config Structure","text":"<pre><code>type Config struct {\n    PaymentAddress string // Required\n    TokenMint      string // Required\n    Network        string // Optional, default: \"solana-devnet\"\n    RPCURL         string // Optional\n    AutoVerify     bool   // Optional, default: false\n}\n</code></pre> <p>Example: <pre><code>nethttp.InitX402(&amp;nethttp.Config{\n    PaymentAddress: os.Getenv(\"X402_PAYMENT_ADDRESS\"),\n    TokenMint:      os.Getenv(\"X402_TOKEN_MINT\"),\n    Network:        \"solana-devnet\",\n    RPCURL:         \"https://api.devnet.solana.com\",\n    AutoVerify:     true,\n})\n</code></pre></p>"},{"location":"go/reference/configuration/#echo-middleware","title":"Echo Middleware","text":""},{"location":"go/reference/configuration/#initx402-config-structure_1","title":"InitX402() Config Structure","text":"<pre><code>type Config struct {\n    PaymentAddress string // Required\n    TokenMint      string // Required\n    Network        string // Optional, default: \"solana-devnet\"\n    RPCURL         string // Optional\n    AutoVerify     bool   // Optional, default: false\n}\n</code></pre> <p>Example: <pre><code>echox402.InitX402(&amp;echox402.Config{\n    PaymentAddress: os.Getenv(\"X402_PAYMENT_ADDRESS\"),\n    TokenMint:      os.Getenv(\"X402_TOKEN_MINT\"),\n    Network:        \"solana-devnet\",\n    AutoVerify:     true,\n})\n</code></pre></p>"},{"location":"go/reference/configuration/#paymentrequired-options","title":"PaymentRequired Options","text":""},{"location":"go/reference/configuration/#nethttp-paymentrequiredoptions","title":"net/http PaymentRequiredOptions","text":"<pre><code>type PaymentRequiredOptions struct {\n    Amount         string // Required\n    PaymentAddress string // Optional: override global\n    TokenMint      string // Optional: override global\n    Network        string // Optional: override global\n    Description    string // Optional\n    ExpiresIn      int    // Optional, default: 300 seconds\n    AutoVerify     bool   // Optional: override global\n}\n</code></pre> <p>Example: <pre><code>nethttp.PaymentRequired(nethttp.PaymentRequiredOptions{\n    Amount:      \"0.10\",\n    Description: \"Premium data access\",\n    ExpiresIn:   600,  // 10 minutes\n    AutoVerify:  true,\n})\n</code></pre></p>"},{"location":"go/reference/configuration/#echo-paymentrequiredoptions","title":"Echo PaymentRequiredOptions","text":"<pre><code>type PaymentRequiredOptions struct {\n    Amount         string // Required\n    PaymentAddress string // Optional: override global\n    TokenMint      string // Optional: override global\n    Network        string // Optional: override global\n    Description    string // Optional\n    ExpiresIn      int    // Optional, default: 300 seconds\n    AutoVerify     bool   // Optional: override global\n}\n</code></pre> <p>Example: <pre><code>echox402.PaymentRequired(echox402.PaymentRequiredOptions{\n    Amount:      \"0.10\",\n    Description: \"Premium data access\",\n    ExpiresIn:   600,\n    AutoVerify:  true,\n})\n</code></pre></p>"},{"location":"go/reference/configuration/#client-configuration_1","title":"Client Configuration","text":""},{"location":"go/reference/configuration/#x402client-options","title":"X402Client Options","text":"<pre><code>func NewX402Client(\n    walletKeypair solana.PrivateKey,\n    rpcURL string,\n    httpClient *http.Client,\n    allowLocal bool,\n) *X402Client\n</code></pre> <p>Parameters: - <code>walletKeypair</code>: Solana private key for signing payments - <code>rpcURL</code>: Custom RPC URL (empty string for default) - <code>httpClient</code>: Custom HTTP client (nil for default) - <code>allowLocal</code>: Allow localhost URLs (for development only)</p> <p>Example: <pre><code>client := client.NewX402Client(\n    walletKeypair,\n    \"https://api.devnet.solana.com\",\n    nil,\n    false,\n)\n</code></pre></p>"},{"location":"go/reference/configuration/#x402autoclient-options","title":"X402AutoClient Options","text":"<pre><code>type AutoClientOptions struct {\n    MaxPaymentAmount string // e.g., \"10.0\"\n    AutoRetry        bool\n    AllowLocal       bool\n}\n\nfunc NewAutoClient(\n    walletKeypair solana.PrivateKey,\n    rpcURL string,\n    options *AutoClientOptions,\n) *X402AutoClient\n</code></pre> <p>Example: <pre><code>client := client.NewAutoClient(\n    walletKeypair,\n    \"https://api.devnet.solana.com\",\n    &amp;client.AutoClientOptions{\n        MaxPaymentAmount: \"10.0\",\n        AutoRetry:        true,\n        AllowLocal:       false,\n    },\n)\n</code></pre></p>"},{"location":"go/reference/configuration/#environment-based-configuration","title":"Environment-Based Configuration","text":""},{"location":"go/reference/configuration/#development-setup","title":"Development Setup","text":"<pre><code># .env.development\nX402_PAYMENT_ADDRESS=\"YOUR_DEVNET_WALLET\"\nX402_TOKEN_MINT=\"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\"\nX402_NETWORK=\"solana-devnet\"\nX402_RPC_URL=\"https://api.devnet.solana.com\"\nPORT=8080\nX402_MAX_PAYMENT=\"10.0\"\n</code></pre> <p>Go Code: <pre><code>if os.Getenv(\"ENVIRONMENT\") == \"\" || os.Getenv(\"ENVIRONMENT\") == \"development\" {\n    nethttp.InitX402(&amp;nethttp.Config{\n        PaymentAddress: os.Getenv(\"X402_PAYMENT_ADDRESS\"),\n        TokenMint:      os.Getenv(\"X402_TOKEN_MINT\"),\n        Network:        \"solana-devnet\",\n        AutoVerify:     false,  // Skip for faster testing\n    })\n}\n</code></pre></p>"},{"location":"go/reference/configuration/#staging-setup","title":"Staging Setup","text":"<pre><code># .env.staging\nX402_PAYMENT_ADDRESS=\"YOUR_TESTNET_WALLET\"\nX402_TOKEN_MINT=\"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\"\nX402_NETWORK=\"solana-testnet\"\nX402_RPC_URL=\"https://api.testnet.solana.com\"\nPORT=8080\nX402_MAX_PAYMENT=\"100.0\"\n</code></pre> <p>Go Code: <pre><code>if os.Getenv(\"ENVIRONMENT\") == \"staging\" {\n    nethttp.InitX402(&amp;nethttp.Config{\n        PaymentAddress: os.Getenv(\"X402_PAYMENT_ADDRESS\"),\n        TokenMint:      os.Getenv(\"X402_TOKEN_MINT\"),\n        Network:        \"solana-testnet\",\n        AutoVerify:     true,\n    })\n}\n</code></pre></p>"},{"location":"go/reference/configuration/#production-setup","title":"Production Setup","text":"<pre><code># .env.production\nX402_PAYMENT_ADDRESS=\"YOUR_MAINNET_WALLET\"\nX402_TOKEN_MINT=\"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\"\nX402_NETWORK=\"solana-mainnet\"\nX402_RPC_URL=\"https://api.mainnet-beta.solana.com\"\nPORT=443\nX402_MAX_PAYMENT=\"50.0\"\n</code></pre> <p>Go Code: <pre><code>if os.Getenv(\"ENVIRONMENT\") == \"production\" {\n    nethttp.InitX402(&amp;nethttp.Config{\n        PaymentAddress: os.Getenv(\"X402_PAYMENT_ADDRESS\"),\n        TokenMint:      os.Getenv(\"X402_TOKEN_MINT\"),\n        Network:        \"solana-mainnet\",\n        RPCURL:         os.Getenv(\"X402_RPC_URL\"),\n        AutoVerify:     true,\n    })\n}\n</code></pre></p>"},{"location":"go/reference/configuration/#configuration-patterns","title":"Configuration Patterns","text":""},{"location":"go/reference/configuration/#global-configuration-recommended","title":"Global Configuration (Recommended)","text":"<p>Initialize once at startup, use everywhere:</p> <pre><code>func init() {\n    nethttp.InitX402(&amp;nethttp.Config{\n        PaymentAddress: os.Getenv(\"X402_PAYMENT_ADDRESS\"),\n        TokenMint:      os.Getenv(\"X402_TOKEN_MINT\"),\n    })\n}\n\nfunc main() {\n    // Uses global configuration\n    http.Handle(\"/api/premium\", nethttp.PaymentRequired(opts)(handler))\n}\n</code></pre>"},{"location":"go/reference/configuration/#per-route-configuration","title":"Per-Route Configuration","text":"<p>Override defaults for specific routes:</p> <pre><code>nethttp.InitX402(&amp;nethttp.Config{\n    PaymentAddress: \"default_wallet\",\n    TokenMint:      \"default_mint\",\n})\n\n// Override for specific route\nhttp.Handle(\"/api/partner\", nethttp.PaymentRequired(nethttp.PaymentRequiredOptions{\n    Amount:         \"0.10\",\n    PaymentAddress: \"partner_wallet\",  // Different recipient\n})(handler))\n</code></pre>"},{"location":"go/reference/configuration/#configuration-from-file","title":"Configuration from File","text":"<p>Load configuration from external file:</p> <pre><code>type AppConfig struct {\n    Payment struct {\n        Address string `json:\"address\"`\n        Mint    string `json:\"mint\"`\n        Network string `json:\"network\"`\n    } `json:\"payment\"`\n    Server struct {\n        Port string `json:\"port\"`\n    } `json:\"server\"`\n}\n\nfunc loadConfig(path string) (*AppConfig, error) {\n    data, err := ioutil.ReadFile(path)\n    if err != nil {\n        return nil, err\n    }\n    var config AppConfig\n    err = json.Unmarshal(data, &amp;config)\n    return &amp;config, err\n}\n\nfunc main() {\n    config, _ := loadConfig(\"config.json\")\n    nethttp.InitX402(&amp;nethttp.Config{\n        PaymentAddress: config.Payment.Address,\n        TokenMint:      config.Payment.Mint,\n        Network:        config.Payment.Network,\n    })\n}\n</code></pre> <p>config.json: <pre><code>{\n  \"payment\": {\n    \"address\": \"YOUR_WALLET_ADDRESS\",\n    \"mint\": \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\",\n    \"network\": \"solana-devnet\"\n  },\n  \"server\": {\n    \"port\": \"8080\"\n  }\n}\n</code></pre></p>"},{"location":"go/reference/configuration/#advanced-configuration","title":"Advanced Configuration","text":""},{"location":"go/reference/configuration/#dynamic-pricing","title":"Dynamic Pricing","text":"<p>Configure pricing based on request parameters:</p> <pre><code>func getPricing(tier string) string {\n    pricing := map[string]string{\n        \"basic\":    \"0.05\",\n        \"standard\": \"0.10\",\n        \"premium\":  \"0.50\",\n        \"enterprise\": \"5.00\",\n    }\n    if price, ok := pricing[tier]; ok {\n        return price\n    }\n    return \"0.05\"  // Default\n}\n\ne.GET(\"/api/data/:tier\", handler, echox402.PaymentRequired(\n    echox402.PaymentRequiredOptions{\n        Amount: \"0.10\",  // Adjusted dynamically in handler\n    },\n))\n</code></pre>"},{"location":"go/reference/configuration/#multi-tenant-configuration","title":"Multi-Tenant Configuration","text":"<p>Configure per tenant:</p> <pre><code>type TenantConfig struct {\n    PaymentAddress string\n    TokenMint      string\n    PaymentAmount  string\n}\n\nvar tenantConfigs = map[string]*TenantConfig{\n    \"tenant1\": {\n        PaymentAddress: \"wallet_1\",\n        TokenMint:      \"mint_1\",\n        PaymentAmount:  \"0.10\",\n    },\n    \"tenant2\": {\n        PaymentAddress: \"wallet_2\",\n        TokenMint:      \"mint_2\",\n        PaymentAmount:  \"0.20\",\n    },\n}\n\nfunc tenantMiddleware(tenantID string) nethttp.PaymentRequiredOptions {\n    config := tenantConfigs[tenantID]\n    return nethttp.PaymentRequiredOptions{\n        Amount:         config.PaymentAmount,\n        PaymentAddress: config.PaymentAddress,\n        TokenMint:      config.TokenMint,\n    }\n}\n</code></pre>"},{"location":"go/reference/configuration/#regional-configuration","title":"Regional Configuration","text":"<p>Configure based on region:</p> <pre><code>func getRegionalConfig(region string) *nethttp.Config {\n    configs := map[string]*nethttp.Config{\n        \"us\": {\n            PaymentAddress: \"us_wallet\",\n            TokenMint:      \"us_mint\",\n            Network:        \"solana-mainnet\",\n        },\n        \"eu\": {\n            PaymentAddress: \"eu_wallet\",\n            TokenMint:      \"eu_mint\",\n            Network:        \"solana-mainnet\",\n        },\n    }\n    return configs[region]\n}\n</code></pre>"},{"location":"go/reference/configuration/#security-best-practices","title":"Security Best Practices","text":""},{"location":"go/reference/configuration/#do","title":"\u2705 Do","text":"<pre><code>// Use environment variables\npaymentAddress := os.Getenv(\"X402_PAYMENT_ADDRESS\")\n\n// Keep private keys secure\nprivateKeyBytes := base58.Decode(os.Getenv(\"X402_PRIVATE_KEY\"))\nkeypair := solana.PrivateKey(privateKeyBytes)\n\n// Use HTTPS in production\ne.StartTLS(\":443\", \"cert.pem\", \"key.pem\")\n\n// Enable payment verification\nnethttp.InitX402(&amp;nethttp.Config{\n    AutoVerify: true,\n})\n\n// Use allowLocal=false in production\nclient := client.NewAutoClient(keypair, \"\", &amp;client.AutoClientOptions{\n    AllowLocal: false,\n})\n\n// Set payment limits\nclient := client.NewAutoClient(keypair, \"\", &amp;client.AutoClientOptions{\n    MaxPaymentAmount: \"10.0\",\n})\n</code></pre>"},{"location":"go/reference/configuration/#dont","title":"\u274c Don't","text":"<pre><code>// Don't hardcode secrets\nconfig := nethttp.Config{\n    PaymentAddress: \"actual_wallet_address\",\n    TokenMint:      \"actual_token\",\n}\n\n// Don't store private keys in code\nkeypair := solana.PrivateKey([]byte(\"my_secret_key\"))\n\n// Don't use HTTP in production\nhttp.ListenAndServe(\":8080\", nil)\n\n// Don't disable payment verification\nnethttp.InitX402(&amp;nethttp.Config{\n    AutoVerify: false,  // Bad for production\n})\n\n// Don't allow local in production\nclient := client.NewAutoClient(keypair, \"\", &amp;client.AutoClientOptions{\n    AllowLocal: true,  // Only for dev!\n})\n\n// Don't set unlimited payment amounts\nclient := client.NewAutoClient(keypair, \"\", nil)\n</code></pre>"},{"location":"go/reference/configuration/#troubleshooting-configuration","title":"Troubleshooting Configuration","text":""},{"location":"go/reference/configuration/#issue-x402-not-initialized","title":"Issue: \"X402 not initialized\"","text":"<p>Solution: <pre><code>// Call InitX402() before defining routes\nnethttp.InitX402(&amp;nethttp.Config{...})\nhttp.Handle(\"/api\", handler)\n</code></pre></p>"},{"location":"go/reference/configuration/#issue-paymentaddress-and-tokenmint-must-be-configured","title":"Issue: \"paymentAddress and tokenMint must be configured\"","text":"<p>Solution: <pre><code># Set environment variables\nexport X402_PAYMENT_ADDRESS=\"YOUR_ADDRESS\"\nexport X402_TOKEN_MINT=\"YOUR_MINT\"\n\n# Or pass to InitX402()\nnethttp.InitX402(&amp;nethttp.Config{\n    PaymentAddress: \"YOUR_ADDRESS\",\n    TokenMint:      \"YOUR_MINT\",\n})\n</code></pre></p>"},{"location":"go/reference/configuration/#issue-payment-verification-always-fails","title":"Issue: \"Payment verification always fails\"","text":"<p>Solution: <pre><code>// Check RPC endpoint\nnethttp.InitX402(&amp;nethttp.Config{\n    RPCURL: \"https://api.devnet.solana.com\",\n    AutoVerify: true,\n})\n\n// Or disable for development\nnethttp.InitX402(&amp;nethttp.Config{\n    AutoVerify: false,\n})\n</code></pre></p>"},{"location":"go/reference/configuration/#default-values","title":"Default Values","text":"<pre><code>const (\n    DefaultNetwork         = \"solana-devnet\"\n    DefaultExpiresIn       = 300  // seconds (5 minutes)\n    DefaultMaxPaymentLimit = \"10.0\"  // USDC\n)\n</code></pre>"},{"location":"go/reference/configuration/#supported-networks","title":"Supported Networks","text":"Network RPC URL Use Case <code>solana-devnet</code> https://api.devnet.solana.com Development/Testing <code>solana-testnet</code> https://api.testnet.solana.com Staging <code>solana-mainnet</code> https://api.mainnet-beta.solana.com Production"},{"location":"go/reference/configuration/#token-addresses","title":"Token Addresses","text":""},{"location":"go/reference/configuration/#usdc-recommended","title":"USDC (Recommended)","text":"Network Address devnet EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v mainnet EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"},{"location":"go/reference/configuration/#other-tokens","title":"Other Tokens","text":"<p>Use your custom token mint address in configuration.</p>"},{"location":"go/reference/configuration/#see-also","title":"See Also","text":"<ul> <li>Getting Started</li> <li>API Reference</li> <li>Environment Variables Overview</li> </ul>"},{"location":"go/reference/errors/","title":"Error Reference","text":"<p>Complete guide to X402 errors, error codes, and error handling patterns.</p>"},{"location":"go/reference/errors/#error-types","title":"Error Types","text":""},{"location":"go/reference/errors/#x402error-base-type","title":"X402Error (Base Type)","text":"<p>The base error type for all X402 errors.</p> <pre><code>type X402Error struct {\n    Message string\n    Code    string\n    Details map[string]interface{}\n}\n\nfunc (e *X402Error) Error() string\n</code></pre>"},{"location":"go/reference/errors/#example","title":"Example","text":"<pre><code>resp, err := client.Get(ctx, url, nil)\nif err != nil {\n    if x402Err, ok := err.(*core.X402Error); ok {\n        log.Printf(\"Error Code: %s\", x402Err.Code)\n        log.Printf(\"Error Message: %s\", x402Err.Message)\n        log.Printf(\"Details: %v\", x402Err.Details)\n    }\n}\n</code></pre>"},{"location":"go/reference/errors/#paymentrequirederror","title":"PaymentRequiredError","text":"<p>Raised when a server responds with HTTP 402 Payment Required.</p> <pre><code>type PaymentRequiredError struct {\n    X402Error\n    PaymentRequest *PaymentRequest\n}\n\nfunc NewPaymentRequiredError(paymentReq *PaymentRequest, message string) error\n</code></pre>"},{"location":"go/reference/errors/#error-code","title":"Error Code","text":"<pre><code>PAYMENT_REQUIRED\n</code></pre>"},{"location":"go/reference/errors/#http-status","title":"HTTP Status","text":"<pre><code>402 Payment Required\n</code></pre>"},{"location":"go/reference/errors/#causes","title":"Causes","text":"<ul> <li>Endpoint requires payment but no authorization header provided</li> <li>Payment authorization missing or invalid</li> <li>First request to paid endpoint</li> </ul>"},{"location":"go/reference/errors/#user-action","title":"User Action","text":"<ul> <li>Make payment using client</li> <li>Include payment authorization in retry request</li> </ul>"},{"location":"go/reference/errors/#example_1","title":"Example","text":"<pre><code>resp, err := client.Get(ctx, url, nil)\nif err != nil {\n    if x402Err, ok := err.(*core.PaymentRequiredError); ok {\n        log.Printf(\"Amount Required: %s\", x402Err.PaymentRequest.MaxAmountRequired)\n        log.Printf(\"Recipient: %s\", x402Err.PaymentRequest.PaymentAddress)\n\n        // Create payment\n        auth, _ := client.CreatePayment(ctx, x402Err.PaymentRequest, \"\")\n\n        // Retry with payment\n        resp, _ = client.Get(ctx, url, auth)\n    }\n}\n</code></pre>"},{"location":"go/reference/errors/#paymentexpirederror","title":"PaymentExpiredError","text":"<p>Raised when a payment request has expired.</p> <pre><code>type PaymentExpiredError struct {\n    X402Error\n    PaymentRequest *PaymentRequest\n}\n\nfunc NewPaymentExpiredError(paymentReq *PaymentRequest, message string) error\n</code></pre>"},{"location":"go/reference/errors/#error-code_1","title":"Error Code","text":"<pre><code>PAYMENT_EXPIRED\n</code></pre>"},{"location":"go/reference/errors/#http-status_1","title":"HTTP Status","text":"<pre><code>402 Payment Required (during validation)\n</code></pre>"},{"location":"go/reference/errors/#causes_1","title":"Causes","text":"<ul> <li>Payment request timestamp has passed expiration time</li> <li>Server took too long to process payment</li> <li>Default expiration is 5 minutes (300 seconds)</li> </ul>"},{"location":"go/reference/errors/#user-action_1","title":"User Action","text":"<ul> <li>Request new payment from server</li> <li>Reduce payment processing time</li> <li>Check system clock accuracy</li> </ul>"},{"location":"go/reference/errors/#example_2","title":"Example","text":"<pre><code>paymentReq, err := client.ParsePaymentRequest(resp)\nif err != nil {\n    log.Fatal(err)\n}\n\nif paymentReq.IsExpired() {\n    log.Println(\"Payment request expired\")\n    // Request new payment\n    resp, _ = client.Get(ctx, url, nil)\n    paymentReq, _ = client.ParsePaymentRequest(resp)\n}\n</code></pre>"},{"location":"go/reference/errors/#prevention","title":"Prevention","text":"<pre><code>// Check expiration before creating payment\nif paymentReq.IsExpired() {\n    return core.NewPaymentExpiredError(paymentReq, \"\")\n}\n\n// Request with longer expiration\nnethttp.PaymentRequired(nethttp.PaymentRequiredOptions{\n    Amount:   \"0.10\",\n    ExpiresIn: 600,  // 10 minutes\n})\n</code></pre>"},{"location":"go/reference/errors/#insufficientfundserror","title":"InsufficientFundsError","text":"<p>Raised when wallet lacks sufficient token balance.</p> <pre><code>type InsufficientFundsError struct {\n    X402Error\n    RequiredAmount  string\n    AvailableAmount string\n}\n\nfunc NewInsufficientFundsError(required string, available string) error\n</code></pre>"},{"location":"go/reference/errors/#error-code_2","title":"Error Code","text":"<pre><code>INSUFFICIENT_FUNDS\n</code></pre>"},{"location":"go/reference/errors/#http-status_2","title":"HTTP Status","text":"<pre><code>400 Bad Request\n</code></pre>"},{"location":"go/reference/errors/#causes_2","title":"Causes","text":"<ul> <li>Wallet balance is less than payment amount</li> <li>Token account doesn't exist</li> <li>Token account is empty</li> </ul>"},{"location":"go/reference/errors/#user-action_2","title":"User Action","text":"<ul> <li>Add funds to wallet</li> <li>Use different wallet with sufficient balance</li> <li>Request smaller payment amount (if allowed)</li> </ul>"},{"location":"go/reference/errors/#example_3","title":"Example","text":"<pre><code>resp, err := client.Get(ctx, url, nil)\nif err != nil {\n    if insuffErr, ok := err.(*core.InsufficientFundsError); ok {\n        log.Printf(\"Required: %s\", insuffErr.RequiredAmount)\n        log.Printf(\"Available: %s\", insuffErr.AvailableAmount)\n        log.Println(\"Please add more funds to your wallet\")\n    }\n}\n</code></pre>"},{"location":"go/reference/errors/#prevention_1","title":"Prevention","text":"<pre><code>// Check balance before payment\nprocessor := core.NewSolanaPaymentProcessor(rpcURL, nil)\ndefer processor.Close()\n\nbalance, err := processor.GetTokenBalance(ctx, walletAddress, tokenMint)\nif err != nil {\n    log.Fatal(err)\n}\n\namount, _ := strconv.ParseFloat(paymentReq.MaxAmountRequired, 64)\nif balance &lt; amount {\n    return core.NewInsufficientFundsError(\n        paymentReq.MaxAmountRequired,\n        fmt.Sprintf(\"%.2f\", balance),\n    )\n}\n</code></pre>"},{"location":"go/reference/errors/#paymentverificationerror","title":"PaymentVerificationError","text":"<p>Raised when payment verification fails.</p> <pre><code>type PaymentVerificationError struct {\n    X402Error\n}\n\nfunc NewPaymentVerificationError(message string) error\n</code></pre>"},{"location":"go/reference/errors/#error-code_3","title":"Error Code","text":"<pre><code>PAYMENT_VERIFICATION_FAILED\n</code></pre>"},{"location":"go/reference/errors/#http-status_3","title":"HTTP Status","text":"<pre><code>403 Forbidden\n</code></pre>"},{"location":"go/reference/errors/#causes_3","title":"Causes","text":"<ul> <li>Transaction not found on-chain</li> <li>Payment amount doesn't match request</li> <li>Recipient address doesn't match</li> <li>Token mint doesn't match</li> <li>Transaction not yet confirmed</li> <li>RPC endpoint is unavailable</li> </ul>"},{"location":"go/reference/errors/#user-action_3","title":"User Action","text":"<ul> <li>Retry the payment (transaction may be confirming)</li> <li>Check network connectivity</li> <li>Verify wallet address and token mint</li> <li>Contact API support if persistent</li> </ul>"},{"location":"go/reference/errors/#example_4","title":"Example","text":"<pre><code>resp, err := client.Get(ctx, url, auth)\nif err != nil {\n    if verifyErr, ok := err.(*core.PaymentVerificationError); ok {\n        log.Printf(\"Verification failed: %s\", verifyErr.Message)\n        log.Println(\"Transaction may still be confirming, retry in a few seconds\")\n\n        // Retry logic\n        time.Sleep(3 * time.Second)\n        resp, _ = client.Get(ctx, url, auth)\n    }\n}\n</code></pre>"},{"location":"go/reference/errors/#prevention_2","title":"Prevention","text":"<pre><code>// Verify before sending request\nverified, err := processor.VerifyTransaction(\n    ctx,\n    txHash,\n    paymentReq.PaymentAddress,\n    amount,\n    paymentReq.AssetAddress,\n)\nif err != nil || !verified {\n    return core.NewPaymentVerificationError(\"verification failed\")\n}\n</code></pre>"},{"location":"go/reference/errors/#transactionbroadcasterror","title":"TransactionBroadcastError","text":"<p>Raised when transaction broadcasting fails.</p> <pre><code>type TransactionBroadcastError struct {\n    X402Error\n}\n\nfunc NewTransactionBroadcastError(message string) error\n</code></pre>"},{"location":"go/reference/errors/#error-code_4","title":"Error Code","text":"<pre><code>TRANSACTION_BROADCAST_FAILED\n</code></pre>"},{"location":"go/reference/errors/#http-status_4","title":"HTTP Status","text":"<pre><code>500 Internal Server Error\n</code></pre>"},{"location":"go/reference/errors/#causes_4","title":"Causes","text":"<ul> <li>Network connectivity issue</li> <li>RPC endpoint is unavailable</li> <li>Solana network congestion</li> <li>Invalid transaction</li> <li>Node is not responding</li> </ul>"},{"location":"go/reference/errors/#user-action_4","title":"User Action","text":"<ul> <li>Retry after a delay</li> <li>Check internet connectivity</li> <li>Verify RPC endpoint</li> <li>Try different RPC endpoint</li> <li>Wait for network to stabilize</li> </ul>"},{"location":"go/reference/errors/#example_5","title":"Example","text":"<pre><code>resp, err := client.Get(ctx, url, nil)\nif err != nil {\n    if broadcastErr, ok := err.(*core.TransactionBroadcastError); ok {\n        log.Printf(\"Broadcast failed: %s\", broadcastErr.Message)\n        log.Println(\"Retrying...\")\n\n        // Exponential backoff retry\n        for attempt := 1; attempt &lt;= 3; attempt++ {\n            time.Sleep(time.Duration(math.Pow(2, float64(attempt-1))) * time.Second)\n            resp, err = client.Get(ctx, url, nil)\n            if err == nil {\n                break\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"go/reference/errors/#invalidpaymentrequesterror","title":"InvalidPaymentRequestError","text":"<p>Raised when payment request format is invalid.</p> <pre><code>type InvalidPaymentRequestError struct {\n    X402Error\n}\n\nfunc NewInvalidPaymentRequestError(message string) error\n</code></pre>"},{"location":"go/reference/errors/#error-code_5","title":"Error Code","text":"<pre><code>INVALID_PAYMENT_REQUEST\n</code></pre>"},{"location":"go/reference/errors/#http-status_5","title":"HTTP Status","text":"<pre><code>400 Bad Request\n</code></pre>"},{"location":"go/reference/errors/#causes_5","title":"Causes","text":"<ul> <li>Missing required fields in payment request</li> <li>Invalid JSON format</li> <li>Malformed payment request structure</li> <li>Server returned unexpected format</li> </ul>"},{"location":"go/reference/errors/#user-action_5","title":"User Action","text":"<ul> <li>Contact API provider</li> <li>Check API documentation</li> <li>Verify server is responding correctly</li> <li>Report issue to API maintainer</li> </ul>"},{"location":"go/reference/errors/#example_6","title":"Example","text":"<pre><code>paymentReq, err := client.ParsePaymentRequest(resp)\nif err != nil {\n    if invalidErr, ok := err.(*core.InvalidPaymentRequestError); ok {\n        log.Printf(\"Invalid payment request: %s\", invalidErr.Message)\n        log.Println(\"Please contact API support\")\n    }\n}\n</code></pre>"},{"location":"go/reference/errors/#error-handling-patterns","title":"Error Handling Patterns","text":""},{"location":"go/reference/errors/#basic-error-handling","title":"Basic Error Handling","text":"<pre><code>resp, err := client.Get(ctx, url, nil)\nif err != nil {\n    log.Printf(\"Error: %v\", err)\n    return err\n}\n</code></pre>"},{"location":"go/reference/errors/#type-based-error-handling","title":"Type-Based Error Handling","text":"<pre><code>resp, err := client.Get(ctx, url, nil)\nif err != nil {\n    switch e := err.(type) {\n    case *core.PaymentRequiredError:\n        log.Println(\"Payment needed\")\n\n    case *core.InsufficientFundsError:\n        log.Printf(\"Need more funds: %s\", e.RequiredAmount)\n\n    case *core.PaymentExpiredError:\n        log.Println(\"Payment request expired, retrying...\")\n\n    case *core.PaymentVerificationError:\n        log.Println(\"Verification failed, retrying...\")\n\n    case *core.TransactionBroadcastError:\n        log.Println(\"Network error, retrying...\")\n\n    default:\n        log.Printf(\"Unknown error: %v\", err)\n    }\n    return err\n}\n</code></pre>"},{"location":"go/reference/errors/#retry-with-exponential-backoff","title":"Retry with Exponential Backoff","text":"<pre><code>func retryWithBackoff(fn func() error, maxAttempts int) error {\n    for attempt := 1; attempt &lt;= maxAttempts; attempt++ {\n        err := fn()\n        if err == nil {\n            return nil\n        }\n\n        // Don't retry for non-retriable errors\n        if x402Err, ok := err.(*core.X402Error); ok {\n            if !shouldRetry(x402Err.Code) {\n                return err\n            }\n        }\n\n        if attempt &lt; maxAttempts {\n            backoff := time.Duration(math.Pow(2, float64(attempt-1))) * time.Second\n            time.Sleep(backoff)\n        }\n    }\n    return fmt.Errorf(\"max retry attempts exceeded\")\n}\n\nfunc shouldRetry(code string) bool {\n    switch code {\n    case \"PAYMENT_EXPIRED\", \"PAYMENT_VERIFICATION_FAILED\", \"TRANSACTION_BROADCAST_FAILED\":\n        return true\n    default:\n        return false\n    }\n}\n</code></pre>"},{"location":"go/reference/errors/#explicit-payment-flow-with-error-handling","title":"Explicit Payment Flow with Error Handling","text":"<pre><code>func paymentFlow(ctx context.Context, client *client.X402Client, url string) (*http.Response, error) {\n    // Step 1: Initial request\n    resp, err := client.Get(ctx, url, nil)\n    if err != nil {\n        return nil, err\n    }\n\n    // Step 2: Check if payment needed\n    if !client.PaymentRequired(resp) {\n        return resp, nil\n    }\n\n    // Step 3: Parse payment request\n    paymentReq, err := client.ParsePaymentRequest(resp)\n    if err != nil {\n        if invalidErr, ok := err.(*core.InvalidPaymentRequestError); ok {\n            return nil, fmt.Errorf(\"invalid payment request: %w\", invalidErr)\n        }\n        return nil, err\n    }\n\n    // Step 4: Check expiration\n    if paymentReq.IsExpired() {\n        return nil, core.NewPaymentExpiredError(paymentReq, \"\")\n    }\n\n    // Step 5: User confirmation (optional)\n    if !userConfirms(paymentReq) {\n        return nil, fmt.Errorf(\"user declined payment\")\n    }\n\n    // Step 6: Create payment\n    auth, err := client.CreatePayment(ctx, paymentReq, \"\")\n    if err != nil {\n        switch e := err.(type) {\n        case *core.InsufficientFundsError:\n            return nil, fmt.Errorf(\"insufficient funds: need %s, have %s\",\n                e.RequiredAmount, e.AvailableAmount)\n        case *core.TransactionBroadcastError:\n            return nil, fmt.Errorf(\"network error: %w\", e)\n        default:\n            return nil, err\n        }\n    }\n\n    // Step 7: Retry with payment\n    resp, err = client.Get(ctx, url, auth)\n    if err != nil {\n        if verifyErr, ok := err.(*core.PaymentVerificationError); ok {\n            // Transaction may still be confirming\n            return nil, fmt.Errorf(\"payment verification failed: %w\", verifyErr)\n        }\n        return nil, err\n    }\n\n    return resp, nil\n}\n</code></pre>"},{"location":"go/reference/errors/#automatic-client-error-handling","title":"Automatic Client Error Handling","text":"<pre><code>func autoClientFlow(ctx context.Context, client *client.X402AutoClient, url string) (*http.Response, error) {\n    resp, err := client.Get(ctx, url)\n    if err != nil {\n        // Auto client handles most cases, but still check for errors\n        if x402Err, ok := err.(*core.X402Error); ok {\n            switch x402Err.Code {\n            case \"INSUFFICIENT_FUNDS\":\n                log.Println(\"Cannot make payment: insufficient funds\")\n            case \"PAYMENT_EXPIRED\":\n                log.Println(\"Payment request expired\")\n            default:\n                log.Printf(\"Payment error: %s\", x402Err.Code)\n            }\n        }\n        return nil, err\n    }\n    return resp, nil\n}\n</code></pre>"},{"location":"go/reference/errors/#middleware-error-handling","title":"Middleware Error Handling","text":""},{"location":"go/reference/errors/#nethttp-middleware-errors","title":"net/http Middleware Errors","text":"<p>The middleware automatically returns appropriate HTTP status codes:</p> <pre><code>// No payment header provided\n// Returns: 402 Payment Required\n\n// Invalid payment format\n// Returns: 400 Bad Request\n\n// Payment verification failed\n// Returns: 403 Forbidden\n\n// Amount insufficient\n// Returns: 403 Forbidden\n\n// Address mismatch\n// Returns: 403 Forbidden\n</code></pre>"},{"location":"go/reference/errors/#echo-middleware-errors","title":"Echo Middleware Errors","text":"<p>Echo middleware follows the same pattern:</p> <pre><code>// Handler won't be called if payment fails\n// Appropriate error response is sent automatically\ne.GET(\"/api/premium\", handler, echox402.PaymentRequired(opts))\n</code></pre>"},{"location":"go/reference/errors/#error-code-reference","title":"Error Code Reference","text":"Code HTTP Status Retriable User Action <code>PAYMENT_REQUIRED</code> 402 Yes Make payment and retry <code>PAYMENT_EXPIRED</code> 402 Yes Request new payment <code>INSUFFICIENT_FUNDS</code> 400 No Add funds to wallet <code>PAYMENT_VERIFICATION_FAILED</code> 403 Yes Retry (wait for confirmation) <code>TRANSACTION_BROADCAST_FAILED</code> 500 Yes Retry or check network <code>INVALID_PAYMENT_REQUEST</code> 400 No Contact API support"},{"location":"go/reference/errors/#common-error-scenarios","title":"Common Error Scenarios","text":""},{"location":"go/reference/errors/#scenario-payment-required-on-first-request","title":"Scenario: \"Payment Required\" on First Request","text":"<p>Symptoms: <pre><code>Error: PAYMENT_REQUIRED\n</code></pre></p> <p>Cause: - Endpoint requires payment, first request doesn't include authorization</p> <p>Solution: <pre><code>if x402Err, ok := err.(*core.PaymentRequiredError); ok {\n    auth, _ := client.CreatePayment(ctx, x402Err.PaymentRequest, \"\")\n    resp, _ = client.Get(ctx, url, auth)\n}\n</code></pre></p>"},{"location":"go/reference/errors/#scenario-insufficient-funds-error","title":"Scenario: \"Insufficient Funds\" Error","text":"<p>Symptoms: <pre><code>Error: INSUFFICIENT_FUNDS\nRequired: 0.10\nAvailable: 0.05\n</code></pre></p> <p>Cause: - Wallet doesn't have enough tokens for payment</p> <p>Solution: <pre><code>// Option 1: Add funds to wallet\n// (Manual: use faucet or transfer tokens)\n\n// Option 2: Use different wallet\nclient := client.NewX402Client(differentKeypair, \"\", nil, false)\n\n// Option 3: Request payment plan (if available)\n// Contact API provider\n</code></pre></p>"},{"location":"go/reference/errors/#scenario-payment-expired-error","title":"Scenario: \"Payment Expired\" Error","text":"<p>Symptoms: <pre><code>Error: PAYMENT_EXPIRED\n</code></pre></p> <p>Cause: - Too much time passed between receiving and processing payment request - Default expiration: 5 minutes</p> <p>Solution: <pre><code>// Request new payment\nresp, _ := client.Get(ctx, url, nil)\npaymentReq, _ := client.ParsePaymentRequest(resp)\n\n// Increase server-side expiration\nechox402.PaymentRequired(echox402.PaymentRequiredOptions{\n    Amount:    \"0.10\",\n    ExpiresIn: 600,  // 10 minutes instead of 5\n})\n</code></pre></p>"},{"location":"go/reference/errors/#scenario-verification-failed-intermittent-error","title":"Scenario: \"Verification Failed\" Intermittent Error","text":"<p>Symptoms: <pre><code>Error: PAYMENT_VERIFICATION_FAILED\n</code></pre></p> <p>Cause: - Transaction is still confirming on-chain - RPC endpoint hasn't received confirmation yet</p> <p>Solution: <pre><code>// Retry after delay\nfor attempt := 1; attempt &lt;= 3; attempt++ {\n    auth, _ := client.CreatePayment(ctx, paymentReq, \"\")\n    resp, err := client.Get(ctx, url, auth)\n    if err == nil {\n        break\n    }\n    time.Sleep(2 * time.Second)\n}\n</code></pre></p>"},{"location":"go/reference/errors/#scenario-network-connectivity-issues","title":"Scenario: Network Connectivity Issues","text":"<p>Symptoms: <pre><code>Error: TRANSACTION_BROADCAST_FAILED\nError: Context deadline exceeded\n</code></pre></p> <p>Cause: - No internet connectivity - RPC endpoint unavailable - Network timeout</p> <p>Solution: <pre><code>// Use exponential backoff with timeout\nctx, cancel := context.WithTimeout(context.Background(), 60*time.Second)\ndefer cancel()\n\n// Retry with exponential backoff\nfor attempt := 1; attempt &lt;= 5; attempt++ {\n    resp, err := client.Get(ctx, url, nil)\n    if err == nil {\n        break\n    }\n    time.Sleep(time.Duration(math.Pow(2, float64(attempt))) * time.Second)\n}\n</code></pre></p>"},{"location":"go/reference/errors/#best-practices","title":"Best Practices","text":""},{"location":"go/reference/errors/#do","title":"\u2705 Do","text":"<pre><code>// Check error types\nswitch e := err.(type) {\ncase *core.InsufficientFundsError:\n    // Handle specific case\n\n// Use context with timeout\nctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)\ndefer cancel()\n\n// Retry retriable errors\nif shouldRetry(err) {\n    resp, _ = client.Get(ctx, url, auth)\n}\n\n// Close client\ndefer client.Close()\n</code></pre>"},{"location":"go/reference/errors/#dont","title":"\u274c Don't","text":"<pre><code>// Don't ignore errors\nclient.Get(ctx, url, nil)\n\n// Don't retry non-retriable errors\nif err != nil {\n    client.Get(ctx, url, nil)  // Infinite loop on INSUFFICIENT_FUNDS\n}\n\n// Don't assume payment succeeded\nauth, _ := client.CreatePayment(ctx, req, \"\")\n\n// Don't forget to close\nclient := client.NewAutoClient(keypair, \"\", nil)\n// Missing: defer client.Close()\n</code></pre>"},{"location":"go/reference/errors/#see-also","title":"See Also","text":"<ul> <li>API Reference</li> <li>Core Library Documentation</li> <li>Client Library Documentation</li> </ul>"},{"location":"packages/python/openlibx402-client/","title":"OpenLibx402 Client","text":"<p>HTTP client library for making X402-enabled API calls with automatic payment handling.</p>"},{"location":"packages/python/openlibx402-client/#installation","title":"Installation","text":"<pre><code>pip install openlibx402-client\n</code></pre>"},{"location":"packages/python/openlibx402-client/#features","title":"Features","text":"<ul> <li>Explicit Client: Manual control over payment flow</li> <li>Implicit Client: Automatic payment handling with configurable retries</li> <li>Support for all HTTP methods (GET, POST, PUT, DELETE)</li> <li>Safety limits with <code>max_payment_amount</code></li> <li>URL validation and SSRF protection</li> <li>Local development support with <code>allow_local</code></li> <li>Proper connection cleanup and security</li> </ul>"},{"location":"packages/python/openlibx402-client/#usage","title":"Usage","text":""},{"location":"packages/python/openlibx402-client/#explicit-client-manual-control","title":"Explicit Client (Manual Control)","text":"<pre><code>from openlibx402_client import X402Client\nfrom solders.keypair import Keypair\n\n# Load wallet\nkeypair = Keypair()\n\n# Create client\nclient = X402Client(wallet_keypair=keypair)\n\n# Make request\nresponse = await client.get(\"https://api.example.com/data\")\n\n# Check if payment required\nif client.payment_required(response):\n    payment_request = client.parse_payment_request(response)\n\n    # Create payment\n    authorization = await client.create_payment(payment_request)\n\n    # Retry with payment\n    response = await client.get(\n        \"https://api.example.com/data\",\n        payment=authorization\n    )\n\ndata = response.json()\n\n# Always cleanup\nawait client.close()\n</code></pre>"},{"location":"packages/python/openlibx402-client/#local-development","title":"Local Development","text":"<p>For local development with localhost URLs:</p> <pre><code># Enable allow_local for localhost/private IPs\nclient = X402Client(wallet_keypair=keypair, allow_local=True)\n\nresponse = await client.get(\"http://localhost:3000/api/data\")\n\nif client.payment_required(response):\n    payment_request = client.parse_payment_request(response)\n    authorization = await client.create_payment(payment_request)\n    response = await client.get(\n        \"http://localhost:3000/api/data\",\n        payment=authorization\n    )\n\nawait client.close()\n</code></pre>"},{"location":"packages/python/openlibx402-client/#implicit-client-auto-payment","title":"Implicit Client (Auto-Payment)","text":"<pre><code>from openlibx402_client import X402AutoClient\nfrom solders.keypair import Keypair\n\n# Create auto-client with safety limits\nclient = X402AutoClient(\n    wallet_keypair=keypair,\n    max_payment_amount=\"5.0\",  # Safety limit\n    max_retries=1\n)\n\n# Automatically handles 402 and pays\nresponse = await client.fetch(\"https://api.example.com/data\")\ndata = response.json()\n\n# Cleanup\nawait client.close()\n</code></pre>"},{"location":"packages/python/openlibx402-client/#disable-auto-retry","title":"Disable Auto-Retry","text":"<pre><code># Disable auto-retry for specific request\ntry:\n    response = await client.fetch(\n        \"https://api.example.com/data\",\n        auto_retry=False\n    )\nexcept PaymentRequiredError as e:\n    print(f\"Payment required: {e.payment_request.max_amount_required}\")\n</code></pre>"},{"location":"packages/python/openlibx402-client/#security-notes","title":"Security Notes","text":"<ul> <li>Always call <code>close()</code> when done to properly cleanup connections and sensitive data</li> <li>Private keys are held in memory - ensure proper disposal</li> <li>Only use URLs from trusted sources to prevent SSRF attacks</li> <li>Default RPC URL is devnet - use mainnet URL for production</li> <li>Set <code>allow_local=True</code> for local development (localhost URLs)</li> <li>NEVER use <code>allow_local=True</code> in production deployments</li> </ul>"},{"location":"packages/python/openlibx402-client/#api-reference","title":"API Reference","text":""},{"location":"packages/python/openlibx402-client/#x402client","title":"X402Client","text":"<ul> <li><code>get(url, payment=None, **kwargs)</code> - GET request</li> <li><code>post(url, payment=None, **kwargs)</code> - POST request</li> <li><code>put(url, payment=None, **kwargs)</code> - PUT request</li> <li><code>delete(url, payment=None, **kwargs)</code> - DELETE request</li> <li><code>request(method, url, payment=None, **kwargs)</code> - Generic HTTP request</li> <li><code>payment_required(response)</code> - Check if response requires payment</li> <li><code>parse_payment_request(response)</code> - Parse payment request from 402 response</li> <li><code>create_payment(request, amount=None)</code> - Create and broadcast payment</li> <li><code>close()</code> - Cleanup connections and sensitive data</li> </ul>"},{"location":"packages/python/openlibx402-client/#x402autoclient","title":"X402AutoClient","text":"<ul> <li><code>fetch(url, method=\"GET\", auto_retry=None, **kwargs)</code> - Request with auto-payment</li> <li><code>get(url, auto_retry=None, **kwargs)</code> - GET with auto-payment</li> <li><code>post(url, auto_retry=None, **kwargs)</code> - POST with auto-payment</li> <li><code>put(url, auto_retry=None, **kwargs)</code> - PUT with auto-payment</li> <li><code>delete(url, auto_retry=None, **kwargs)</code> - DELETE with auto-payment</li> <li><code>close()</code> - Cleanup connections</li> </ul>"},{"location":"packages/python/openlibx402-client/#license","title":"License","text":"<p>MIT</p>"},{"location":"packages/python/openlibx402-core/","title":"OpenLibx402 Core","text":"<p>Core implementation of the X402 payment protocol for autonomous AI agent payments.</p>"},{"location":"packages/python/openlibx402-core/#installation","title":"Installation","text":"<pre><code>pip install openlibx402-core\n</code></pre>"},{"location":"packages/python/openlibx402-core/#features","title":"Features","text":"<ul> <li>Payment request and authorization data structures</li> <li>Solana blockchain integration</li> <li>Comprehensive error handling</li> <li>Testing utilities with mock implementations</li> </ul>"},{"location":"packages/python/openlibx402-core/#usage","title":"Usage","text":"<pre><code>from openlibx402_core import PaymentRequest, PaymentAuthorization, SolanaPaymentProcessor\n\n# Create payment processor\nprocessor = SolanaPaymentProcessor(\"https://api.devnet.solana.com\")\n\n# Parse payment request from 402 response\nrequest = PaymentRequest.from_dict(response_data)\n\n# Create and send payment\ntransaction = await processor.create_payment_transaction(request, \"0.10\", keypair)\ntx_hash = await processor.sign_and_send_transaction(transaction, keypair)\n\n# Verify transaction\nverified = await processor.verify_transaction(\n    tx_hash,\n    request.payment_address,\n    \"0.10\",\n    request.asset_address\n)\n</code></pre>"},{"location":"packages/python/openlibx402-core/#testing","title":"Testing","text":"<pre><code>from openlibx402_core.testing import MockSolanaPaymentProcessor, create_mock_payment_request\n\n# Use mock processor in tests\nprocessor = MockSolanaPaymentProcessor()\nprocessor.balance = 100.0\n\nrequest = create_mock_payment_request(amount=\"0.10\")\n</code></pre>"},{"location":"packages/python/openlibx402-core/#license","title":"License","text":"<p>MIT</p>"},{"location":"packages/python/openlibx402-fastapi/","title":"OpenLibx402 FastAPI","text":"<p>FastAPI middleware and decorators for X402 payment protocol.</p>"},{"location":"packages/python/openlibx402-fastapi/#installation","title":"Installation","text":"<pre><code>pip install openlibx402-fastapi\n</code></pre>"},{"location":"packages/python/openlibx402-fastapi/#features","title":"Features","text":"<ul> <li>Simple decorator for adding payment requirements</li> <li>Dependency injection pattern for FastAPI</li> <li>Global configuration management</li> <li>Automatic payment verification</li> <li>402 response builders</li> </ul>"},{"location":"packages/python/openlibx402-fastapi/#usage","title":"Usage","text":""},{"location":"packages/python/openlibx402-fastapi/#decorator-approach","title":"Decorator Approach","text":"<pre><code>from fastapi import FastAPI\nfrom openlibx402_fastapi import payment_required\n\napp = FastAPI()\n\n@app.get(\"/premium-data\")\n@payment_required(\n    amount=\"0.10\",\n    payment_address=\"YOUR_WALLET_ADDRESS\",\n    token_mint=\"USDC_MINT_ADDRESS\",\n    description=\"Access to premium market data\"\n)\nasync def get_premium_data():\n    return {\"data\": \"Premium content\"}\n</code></pre>"},{"location":"packages/python/openlibx402-fastapi/#dependency-injection","title":"Dependency Injection","text":"<pre><code>from fastapi import FastAPI, Depends\nfrom openlibx402_fastapi import verify_payment_factory, PaymentAuthorization\n\napp = FastAPI()\n\n@app.get(\"/expensive-data\")\nasync def get_expensive_data(\n    payment: PaymentAuthorization = Depends(\n        verify_payment_factory(\n            amount=\"1.00\",\n            payment_address=\"YOUR_WALLET_ADDRESS\",\n            token_mint=\"USDC_MINT_ADDRESS\"\n        )\n    )\n):\n    return {\n        \"data\": \"Very expensive content\",\n        \"payment_id\": payment.payment_id\n    }\n</code></pre>"},{"location":"packages/python/openlibx402-fastapi/#global-configuration","title":"Global Configuration","text":"<pre><code>from openlibx402_fastapi import X402Config, init_x402\n\nconfig = X402Config(\n    payment_address=\"YOUR_WALLET_ADDRESS\",\n    token_mint=\"USDC_MINT_ADDRESS\",\n    network=\"solana-devnet\"\n)\ninit_x402(config)\n\n@app.get(\"/data\")\n@payment_required(amount=\"0.05\")  # Uses global config\nasync def get_data():\n    return {\"data\": \"content\"}\n</code></pre>"},{"location":"packages/python/openlibx402-fastapi/#license","title":"License","text":"<p>MIT</p>"},{"location":"packages/python/openlibx402-langchain/","title":"OpenLibx402 LangChain","text":"<p>LangChain integration for X402 payment protocol.</p>"},{"location":"packages/python/openlibx402-langchain/#installation","title":"Installation","text":"<pre><code>pip install openlibx402-langchain\n</code></pre>"},{"location":"packages/python/openlibx402-langchain/#features","title":"Features","text":"<ul> <li>X402PaymentTool for LangChain agents</li> <li>X402RequestsWrapper for automatic payment handling</li> <li>Convenience function for creating X402-enabled agents</li> </ul>"},{"location":"packages/python/openlibx402-langchain/#usage","title":"Usage","text":""},{"location":"packages/python/openlibx402-langchain/#using-x402paymenttool","title":"Using X402PaymentTool","text":"<pre><code>from langchain.chat_models import ChatOpenAI\nfrom langchain.agents import initialize_agent, AgentType\nfrom openlibx402_langchain import X402PaymentTool\nfrom solders.keypair import Keypair\n\nkeypair = Keypair()\n\npayment_tool = X402PaymentTool(\n    wallet_keypair=keypair,\n    max_payment=\"5.0\"\n)\n\nagent = initialize_agent(\n    tools=[payment_tool],\n    llm=ChatOpenAI(),\n    agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION\n)\n\nresponse = agent.run(\"Get premium data from https://api.example.com/data\")\n</code></pre>"},{"location":"packages/python/openlibx402-langchain/#using-x402requestswrapper","title":"Using X402RequestsWrapper","text":"<pre><code>from langchain.agents import load_tools\nfrom openlibx402_langchain import X402RequestsWrapper\n\nrequests_wrapper = X402RequestsWrapper(\n    wallet_keypair=keypair,\n    max_payment=\"1.0\"\n)\n\ntools = load_tools(\n    [\"requests_all\"],\n    llm=ChatOpenAI(),\n    requests_wrapper=requests_wrapper\n)\n\nagent = initialize_agent(tools=tools, llm=ChatOpenAI())\n</code></pre>"},{"location":"packages/python/openlibx402-langchain/#convenience-function","title":"Convenience Function","text":"<pre><code>from openlibx402_langchain import create_x402_agent\n\nagent = create_x402_agent(\n    wallet_keypair=keypair,\n    max_payment=\"5.0\"\n)\n\nresponse = agent.run(\"Get premium data from API\")\n</code></pre>"},{"location":"packages/python/openlibx402-langchain/#license","title":"License","text":"<p>MIT</p>"},{"location":"packages/python/openlibx402-langgraph/","title":"OpenLibx402 LangGraph","text":"<p>LangGraph integration for X402 payment protocol.</p>"},{"location":"packages/python/openlibx402-langgraph/#installation","title":"Installation","text":"<pre><code>pip install openlibx402-langgraph\n</code></pre>"},{"location":"packages/python/openlibx402-langgraph/#features","title":"Features","text":"<ul> <li>Payment nodes for LangGraph workflows</li> <li>Async and sync node implementations</li> <li>Conditional edge functions for routing</li> <li>State management utilities</li> <li>Simple workflow creator</li> </ul>"},{"location":"packages/python/openlibx402-langgraph/#usage","title":"Usage","text":""},{"location":"packages/python/openlibx402-langgraph/#basic-payment-node","title":"Basic Payment Node","text":"<pre><code>from langgraph.graph import StateGraph, END\nfrom openlibx402_langgraph import payment_node, check_payment_required\nfrom solders.keypair import Keypair\n\nclass AgentState(TypedDict):\n    api_url: str\n    api_response: str\n    payment_required: bool\n    payment_completed: bool\n    wallet_keypair: Keypair\n\nworkflow = StateGraph(AgentState)\n\nworkflow.add_node(\"fetch\", fetch_api_node)\nworkflow.add_node(\"pay\", payment_node)\nworkflow.add_node(\"process\", process_node)\n\nworkflow.add_conditional_edges(\n    \"fetch\",\n    check_payment_required,\n    {\n        \"payment_required\": \"pay\",\n        \"success\": \"process\",\n        \"error\": END\n    }\n)\n\nworkflow.add_edge(\"pay\", \"fetch\")\nworkflow.add_edge(\"process\", END)\n\napp = workflow.compile()\n</code></pre>"},{"location":"packages/python/openlibx402-langgraph/#combined-fetch-payment-node","title":"Combined Fetch + Payment Node","text":"<pre><code>from openlibx402_langgraph import fetch_with_payment_node\n\nworkflow.add_node(\"fetch\", fetch_with_payment_node)\nworkflow.set_entry_point(\"fetch\")\nworkflow.add_edge(\"fetch\", \"process\")\n</code></pre>"},{"location":"packages/python/openlibx402-langgraph/#simple-workflow-helper","title":"Simple Workflow Helper","text":"<pre><code>from openlibx402_langgraph import create_simple_payment_workflow\n\nworkflow = create_simple_payment_workflow(\n    wallet_keypair=keypair,\n    api_url=\"https://api.example.com/data\"\n)\n\nresult = workflow({})\nprint(result[\"api_response\"])\n</code></pre>"},{"location":"packages/python/openlibx402-langgraph/#license","title":"License","text":"<p>MIT</p>"},{"location":"packages/typescript/openlibx402-client/","title":"@openlibx402/client","text":"<p>TypeScript HTTP client for X402 payment protocol.</p>"},{"location":"packages/typescript/openlibx402-client/#installation","title":"Installation","text":"<pre><code>npm install @openlibx402/client\n</code></pre>"},{"location":"packages/typescript/openlibx402-client/#features","title":"Features","text":"<ul> <li>Explicit Client: Manual control over payment flow</li> <li>Implicit Client: Automatic payment handling with configurable retries</li> <li>Support for all HTTP methods (GET, POST, PUT, DELETE)</li> <li>Safety limits with <code>maxPaymentAmount</code></li> <li>URL validation and SSRF protection</li> <li>Local development support with <code>allowLocal</code></li> <li>Proper connection cleanup and security</li> </ul>"},{"location":"packages/typescript/openlibx402-client/#usage","title":"Usage","text":""},{"location":"packages/typescript/openlibx402-client/#explicit-client-manual-control","title":"Explicit Client (Manual Control)","text":"<pre><code>import { X402Client } from '@openlibx402/client';\nimport { Keypair } from '@solana/web3.js';\n\n// Load wallet\nconst keypair = new Keypair();\n\n// Create client\nconst client = new X402Client(keypair);\n\n// Make request\nlet response = await client.get(\"https://api.example.com/data\");\n\n// Check if payment required\nif (client.paymentRequired(response)) {\n  const paymentRequest = client.parsePaymentRequest(response);\n\n  // Create payment\n  const authorization = await client.createPayment(paymentRequest);\n\n  // Retry with payment\n  response = await client.get(\"https://api.example.com/data\", { payment: authorization });\n}\n\nconst data = response.data;\n\n// Always cleanup\nawait client.close();\n</code></pre>"},{"location":"packages/typescript/openlibx402-client/#local-development","title":"Local Development","text":"<p>For local development with localhost URLs:</p> <pre><code>// Enable allowLocal for localhost/private IPs\nconst client = new X402Client(keypair, undefined, undefined, true);\n\nlet response = await client.get(\"http://localhost:3000/api/data\");\n\nif (client.paymentRequired(response)) {\n  const paymentRequest = client.parsePaymentRequest(response);\n  const authorization = await client.createPayment(paymentRequest);\n  response = await client.get(\"http://localhost:3000/api/data\", { payment: authorization });\n}\n\nawait client.close();\n</code></pre>"},{"location":"packages/typescript/openlibx402-client/#implicit-client-auto-payment","title":"Implicit Client (Auto-Payment)","text":"<pre><code>import { X402AutoClient } from '@openlibx402/client';\nimport { Keypair } from '@solana/web3.js';\n\n// Create auto-client with safety limits\nconst client = new X402AutoClient(keypair, undefined, {\n  maxPaymentAmount: \"5.0\",  // Safety limit\n  maxRetries: 1\n});\n\n// Automatically handles 402 and pays\nconst response = await client.fetch(\"https://api.example.com/data\");\nconst data = response.data;\n\n// Cleanup\nawait client.close();\n</code></pre>"},{"location":"packages/typescript/openlibx402-client/#disable-auto-retry","title":"Disable Auto-Retry","text":"<pre><code>// Disable auto-retry for specific request\ntry {\n  const response = await client.fetch(\"https://api.example.com/data\", {\n    autoRetry: false\n  });\n} catch (error) {\n  if (error instanceof PaymentRequiredError) {\n    console.log(`Payment required: ${error.paymentRequest.maxAmountRequired}`);\n  }\n}\n</code></pre>"},{"location":"packages/typescript/openlibx402-client/#security-notes","title":"Security Notes","text":"<ul> <li>Always call <code>close()</code> when done to properly cleanup connections and sensitive data</li> <li>Private keys are held in memory - ensure proper disposal</li> <li>Only use URLs from trusted sources to prevent SSRF attacks</li> <li>Default RPC URL is devnet - use mainnet URL for production</li> <li>Set <code>allowLocal=true</code> for local development (localhost URLs)</li> <li>NEVER use <code>allowLocal=true</code> in production deployments</li> </ul>"},{"location":"packages/typescript/openlibx402-client/#api-reference","title":"API Reference","text":""},{"location":"packages/typescript/openlibx402-client/#x402client","title":"X402Client","text":"<ul> <li><code>get(url, options?)</code> - GET request</li> <li><code>post(url, data?, options?)</code> - POST request</li> <li><code>put(url, data?, options?)</code> - PUT request</li> <li><code>delete(url, options?)</code> - DELETE request</li> <li><code>request(method, url, options?)</code> - Generic HTTP request</li> <li><code>paymentRequired(response)</code> - Check if response requires payment</li> <li><code>parsePaymentRequest(response)</code> - Parse payment request from 402 response</li> <li><code>createPayment(request, amount?)</code> - Create and broadcast payment</li> <li><code>close()</code> - Cleanup connections and sensitive data</li> </ul>"},{"location":"packages/typescript/openlibx402-client/#x402autoclient","title":"X402AutoClient","text":"<ul> <li><code>fetch(url, options?)</code> - Request with auto-payment</li> <li><code>get(url, options?)</code> - GET with auto-payment</li> <li><code>post(url, data?, options?)</code> - POST with auto-payment</li> <li><code>put(url, data?, options?)</code> - PUT with auto-payment</li> <li><code>delete(url, options?)</code> - DELETE with auto-payment</li> <li><code>close()</code> - Cleanup connections</li> </ul>"},{"location":"packages/typescript/openlibx402-client/#license","title":"License","text":"<p>MIT</p>"},{"location":"packages/typescript/openlibx402-core/","title":"@openlibx402/core","text":"<p>Core TypeScript library for X402 payment protocol.</p>"},{"location":"packages/typescript/openlibx402-core/#installation","title":"Installation","text":"<pre><code>npm install @openlibx402/core\n</code></pre>"},{"location":"packages/typescript/openlibx402-core/#features","title":"Features","text":"<ul> <li>Payment request and authorization structures</li> <li>Solana blockchain integration</li> <li>HTTP 402 protocol support</li> <li>TypeScript types and interfaces</li> </ul>"},{"location":"packages/typescript/openlibx402-core/#usage","title":"Usage","text":"<pre><code>import { PaymentRequest, SolanaPaymentProcessor } from '@openlibx402/core';\nimport { Keypair } from '@solana/web3.js';\n\nconst processor = new SolanaPaymentProcessor('https://api.devnet.solana.com');\n\nconst request: PaymentRequest = {\n  paymentAddress: 'wallet_address',\n  amount: '0.10',\n  assetAddress: 'token_mint'\n};\n\nconst transaction = await processor.createPaymentTransaction(request, keypair);\nconst txHash = await processor.signAndSendTransaction(transaction, keypair);\n</code></pre>"},{"location":"packages/typescript/openlibx402-core/#license","title":"License","text":"<p>MIT</p>"},{"location":"packages/typescript/openlibx402-express/","title":"@openlibx402/express","text":"<p>Express.js middleware and decorators for X402 payment protocol.</p>"},{"location":"packages/typescript/openlibx402-express/#installation","title":"Installation","text":"<pre><code>npm install @openlibx402/express\n</code></pre>"},{"location":"packages/typescript/openlibx402-express/#features","title":"Features","text":"<ul> <li>Express middleware for payment requirements</li> <li>Automatic payment verification</li> <li>402 response handling</li> <li>TypeScript support</li> </ul>"},{"location":"packages/typescript/openlibx402-express/#usage","title":"Usage","text":"<pre><code>import express from 'express';\nimport { paymentRequired } from '@openlibx402/express';\n\nconst app = express();\n\napp.get('/premium-data', paymentRequired({\n  amount: '0.10',\n  paymentAddress: 'YOUR_WALLET_ADDRESS',\n  tokenMint: 'USDC_MINT_ADDRESS',\n  description: 'Access to premium data'\n}), (req, res) =&gt; {\n  res.json({ data: 'Premium content' });\n});\n</code></pre>"},{"location":"packages/typescript/openlibx402-express/#license","title":"License","text":"<p>MIT</p>"},{"location":"packages/typescript/openlibx402-langchain/","title":"@openlibx402/langchain","text":"<p>LangChain.js integration for X402 payment protocol.</p>"},{"location":"packages/typescript/openlibx402-langchain/#installation","title":"Installation","text":"<pre><code>npm install @openlibx402/langchain\n</code></pre>"},{"location":"packages/typescript/openlibx402-langchain/#features","title":"Features","text":"<ul> <li>LangChain tools for X402 payments</li> <li>AI agent payment handling</li> <li>Automatic payment workflows</li> <li>TypeScript support</li> </ul>"},{"location":"packages/typescript/openlibx402-langchain/#usage","title":"Usage","text":"<pre><code>import { X402PaymentTool } from '@openlibx402/langchain';\nimport { ChatOpenAI } from 'langchain/chat_models/openai';\nimport { initializeAgent } from 'langchain/agents';\n\nconst paymentTool = new X402PaymentTool({\n  wallet: keypair,\n  maxPayment: '5.0'\n});\n\nconst agent = await initializeAgent({\n  tools: [paymentTool],\n  llm: new ChatOpenAI()\n});\n\nconst response = await agent.call({ input: 'Get premium data from API' });\n</code></pre>"},{"location":"packages/typescript/openlibx402-langchain/#license","title":"License","text":"<p>MIT</p>"},{"location":"packages/typescript/openlibx402-langgraph/","title":"@openlibx402/langgraph","text":"<p>LangGraph.js integration for X402 payment protocol.</p>"},{"location":"packages/typescript/openlibx402-langgraph/#installation","title":"Installation","text":"<pre><code>npm install @openlibx402/langgraph\n</code></pre>"},{"location":"packages/typescript/openlibx402-langgraph/#features","title":"Features","text":"<ul> <li>LangGraph nodes for payments</li> <li>Workflow integration</li> <li>AI agent payment workflows</li> <li>TypeScript support</li> </ul>"},{"location":"packages/typescript/openlibx402-langgraph/#usage","title":"Usage","text":"<pre><code>import { paymentNode } from '@openlibx402/langgraph';\nimport { StateGraph } from '@langchain/langgraph';\n\nconst workflow = new StateGraph();\n\nworkflow.addNode('pay', paymentNode);\nworkflow.addNode('fetch', fetchNode);\n\nworkflow.addEdge('pay', 'fetch');\n\nconst app = workflow.compile();\n</code></pre>"},{"location":"packages/typescript/openlibx402-langgraph/#license","title":"License","text":"<p>MIT</p>"},{"location":"packages/typescript/openlibx402-nextjs/","title":"@openlibx402/nextjs","text":"<p>Next.js middleware and utilities for the X402 payment protocol. This package provides seamless integration of blockchain-based micropayments into your Next.js applications.</p>"},{"location":"packages/typescript/openlibx402-nextjs/#installation","title":"Installation","text":"<pre><code>npm install @openlibx402/nextjs @openlibx402/core @solana/web3.js\n</code></pre>"},{"location":"packages/typescript/openlibx402-nextjs/#features","title":"Features","text":"<ul> <li>App Router Support - Built for Next.js 13+ App Router</li> <li>Payment Verification - Automatic on-chain payment verification</li> <li>TypeScript - Full type safety</li> <li>Flexible Configuration - Global or per-route configuration</li> <li>Easy Integration - Simple higher-order function API</li> </ul>"},{"location":"packages/typescript/openlibx402-nextjs/#usage","title":"Usage","text":"<pre><code>import { X402Config, initX402, withPayment } from '@openlibx402/nextjs';\n\n// Initialize configuration\nconst config = new X402Config({\n  paymentAddress: process.env.PAYMENT_WALLET_ADDRESS!,\n  tokenMint: process.env.USDC_MINT_ADDRESS!,\n  network: 'solana-devnet',\n});\n\ninitX402(config);\n\n// Protect API routes\nexport const GET = withPayment(\n  {\n    amount: '0.10',\n    description: 'Access to premium data',\n  },\n  async (req, context) =&gt; {\n    return NextResponse.json({\n      data: 'Premium content',\n      payment_id: context.payment?.paymentId,\n    });\n  }\n);\n</code></pre>"},{"location":"packages/typescript/openlibx402-nextjs/#license","title":"License","text":"<p>MIT</p>"},{"location":"rust/","title":"Rust Implementation","text":"<p>Welcome to the OpenLibx402 Rust implementation documentation. This section covers all Rust packages, libraries, middleware, and examples for building X402-enabled APIs and clients with type-safe, high-performance code.</p>"},{"location":"rust/#overview","title":"Overview","text":"<p>The Rust implementation provides:</p> <ul> <li>Core Library - X402 protocol implementation with models, errors, and Solana payment processing</li> <li>Client Library - HTTP client with automatic and explicit payment handling</li> <li>Middleware - Integration with popular Rust web frameworks (Rocket, Actix Web)</li> <li>Examples - Complete working examples for server and client implementations</li> </ul>"},{"location":"rust/#quick-navigation","title":"Quick Navigation","text":""},{"location":"rust/#libraries","title":"\ud83d\udcda Libraries","text":"<ul> <li>Core Library - Payment models, errors, and Solana processor</li> <li>Client Library - X402 HTTP client with auto-payment support</li> </ul>"},{"location":"rust/#middleware","title":"\ud83d\udd17 Middleware","text":"<ul> <li>Rocket Middleware - Rocket web framework integration</li> <li>Actix Web Middleware - Actix Web framework integration</li> </ul>"},{"location":"rust/#examples","title":"\ud83d\ude80 Examples","text":"<ul> <li>Rocket Server - Complete server with multiple pricing tiers</li> <li>Actix Web Server - Actix Web server with dynamic pricing</li> </ul>"},{"location":"rust/#getting-started","title":"\ud83d\udcd6 Getting Started","text":"<ul> <li>Installation</li> <li>Quick Start Server</li> <li>Quick Start Client</li> </ul>"},{"location":"rust/#reference","title":"\ud83d\udd27 Reference","text":"<ul> <li>API Reference</li> <li>Configuration</li> <li>Error Handling</li> </ul>"},{"location":"rust/#key-features","title":"Key Features","text":"<p>\u2728 Type-Safe - Compile-time guarantees with Rust's type system \ud83e\udd16 Automatic Payments - Clients automatically handle payment flows \u26a1 High Performance - Zero-copy, async-first design with Tokio \ud83d\udcb0 Micropayments - Support payments as low as $0.001 \ud83d\udd10 Secure - Memory-safe, payment verification, nonce-based replay protection \ud83c\udf10 Framework Agnostic - Works with Rocket, Actix Web, and custom implementations</p>"},{"location":"rust/#crate-dependencies","title":"Crate Dependencies","text":"<pre><code>[dependencies]\n# Core protocol\nopenlibx402-core = \"0.1\"\n\n# HTTP client\nopenlibx402-client = \"0.1\"\n\n# Rocket middleware\nopenlibx402-rocket = \"0.1\"\n\n# Actix Web middleware\nopenlibx402-actix = \"0.1\"\n</code></pre>"},{"location":"rust/#installation","title":"Installation","text":"<pre><code># Core package (required)\ncargo add openlibx402-core\n\n# Client (for consuming paid APIs)\ncargo add openlibx402-client\n\n# Middleware for your framework\ncargo add openlibx402-rocket\n# or\ncargo add openlibx402-actix\n</code></pre>"},{"location":"rust/#the-x402-flow","title":"The X402 Flow","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  AI Agent   \u2502  \u25001\u2500\u2192   \u2502  API Server  \u2502         \u2502 Blockchain \u2502\n\u2502   (Client)  \u2502         \u2502   (Server)   \u2502         \u2502  (Solana)  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n     \u2502                        \u2502                        \u2502\n     \u2502  GET /data             \u2502                        \u2502\n     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2192\u2502                        \u2502\n     \u2502                        \u2502                        \u2502\n     \u2502  402 Payment Required  \u2502                        \u2502\n     \u2502  + Payment Details     \u2502                        \u2502\n     \u2502\u2190\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524                        \u2502\n     \u2502                        \u2502                        \u2502\n     \u2502  Create &amp; Broadcast    \u2502                        \u2502\n     \u2502  Payment Transaction   \u2502                        \u2502\n     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2192\u2502\n     \u2502                        \u2502                        \u2502\n     \u2502                        \u2502   Verify Transaction   \u2502\n     \u2502                        \u2502\u2190\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n     \u2502                        \u2502                        \u2502\n     \u2502  GET /data             \u2502                        \u2502\n     \u2502  + Payment Auth Header \u2502                        \u2502\n     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2192\u2502                        \u2502\n     \u2502                        \u2502                        \u2502\n     \u2502  200 OK + Data         \u2502                        \u2502\n     \u2502\u2190\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524                        \u2502\n</code></pre>"},{"location":"rust/#why-rust","title":"Why Rust?","text":"<p>Rust is an excellent choice for X402 implementations:</p> <ul> <li>Safety - Memory safety without garbage collection</li> <li>Performance - Zero-cost abstractions and minimal runtime</li> <li>Concurrency - Fearless concurrency with async/await</li> <li>Reliability - Catch bugs at compile time</li> <li>Ecosystem - Rich ecosystem of web frameworks and blockchain tools</li> </ul>"},{"location":"rust/#support","title":"Support","text":"<p>For issues, questions, or contributions: - GitHub Issues - GitHub Discussions - X402 Protocol - Rust Documentation</p>"},{"location":"rust/#next-steps","title":"Next Steps","text":"<p>Start with the Installation guide and choose your path:</p> <ul> <li>Building a Server? \u2192 Server Quick Start</li> <li>Building a Client? \u2192 Client Quick Start</li> <li>Need Details? \u2192 API Reference</li> </ul>"},{"location":"rust/examples/actix-server/","title":"Actix Web Server Example","text":"<p>Complete example of an X402-enabled API server using Actix Web with multiple pricing tiers.</p>"},{"location":"rust/examples/actix-server/#source-code","title":"Source Code","text":"<p>Location: <code>examples/rust/actix-server/</code></p>"},{"location":"rust/examples/actix-server/#overview","title":"Overview","text":"<p>This example demonstrates: - Free and paid endpoints - Multiple pricing tiers ($0.01, $0.10, $1.00) - Payment requirement configuration - Health check endpoint</p>"},{"location":"rust/examples/actix-server/#running-the-example","title":"Running the Example","text":"<pre><code>cd examples/rust/actix-server\ncargo run\n</code></pre> <p>Server starts on <code>http://localhost:8080</code></p>"},{"location":"rust/examples/actix-server/#endpoints","title":"Endpoints","text":"Endpoint Price Description <code>GET /</code> Free Welcome message <code>GET /basic</code> $0.01 Basic tier data <code>GET /premium</code> $0.10 Premium tier data <code>GET /enterprise</code> $1.00 Enterprise tier data <code>GET /health</code> Free Health check"},{"location":"rust/examples/actix-server/#testing","title":"Testing","text":""},{"location":"rust/examples/actix-server/#free-endpoint","title":"Free Endpoint","text":"<pre><code>curl http://localhost:8080/\n</code></pre> <p>Response: <pre><code>{\n  \"message\": \"Welcome to the X402 Actix Web example server!\"\n}\n</code></pre></p>"},{"location":"rust/examples/actix-server/#payment-required","title":"Payment Required","text":"<pre><code>curl -v http://localhost:8080/premium\n</code></pre> <p>Response (402 Payment Required): <pre><code>{\n  \"max_amount_required\": \"0.10\",\n  \"asset_type\": \"SPL\",\n  \"asset_address\": \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\",\n  \"payment_address\": \"7xKXtg2CW87d97TXJSDpbD5jBkheTqA83TZRuJosgAsU\",\n  \"network\": \"solana-devnet\",\n  \"expires_at\": \"2025-10-31T12:05:00Z\",\n  \"nonce\": \"abc-123-def\",\n  \"payment_id\": \"pay-456-ghi\",\n  \"resource\": \"/premium\",\n  \"description\": \"Access to premium tier data\"\n}\n</code></pre></p>"},{"location":"rust/examples/actix-server/#complete-code","title":"Complete Code","text":"<pre><code>use actix_web::{get, web, App, HttpResponse, HttpServer};\nuse openlibx402_actix::{\n    create_payment_request, payment_required_response, PaymentExtractor, PaymentRequirement,\n    X402Config, X402State,\n};\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Serialize, Deserialize)]\nstruct PremiumData {\n    message: String,\n    data: Vec&lt;String&gt;,\n    tier: String,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\nstruct BasicData {\n    message: String,\n}\n\n/// Free endpoint\n#[get(\"/\")]\nasync fn index() -&gt; HttpResponse {\n    HttpResponse::Ok().json(BasicData {\n        message: \"Welcome to the X402 Actix Web example server!\".to_string(),\n    })\n}\n\n/// Basic tier - $0.01\n#[get(\"/basic\")]\nasync fn basic_tier(\n    state: web::Data&lt;X402State&gt;,\n    auth: Option&lt;PaymentExtractor&gt;,\n) -&gt; HttpResponse {\n    match auth {\n        Some(auth) =&gt; {\n            HttpResponse::Ok().json(PremiumData {\n                message: \"Access granted to basic tier\".to_string(),\n                data: vec![\n                    \"Basic data point 1\".to_string(),\n                    \"Basic data point 2\".to_string(),\n                ],\n                tier: \"basic\".to_string(),\n            })\n        }\n        None =&gt; {\n            let requirement =\n                PaymentRequirement::new(\"0.01\").with_description(\"Access to basic tier data\");\n            let payment_request = create_payment_request(&amp;state.config, &amp;requirement, \"/basic\");\n            payment_required_response(payment_request)\n        }\n    }\n}\n\n/// Premium tier - $0.10\n#[get(\"/premium\")]\nasync fn premium_tier(\n    state: web::Data&lt;X402State&gt;,\n    auth: Option&lt;PaymentExtractor&gt;,\n) -&gt; HttpResponse {\n    match auth {\n        Some(auth) =&gt; {\n            HttpResponse::Ok().json(PremiumData {\n                message: \"Access granted to premium tier\".to_string(),\n                data: vec![\n                    \"Premium insight 1\".to_string(),\n                    \"Premium insight 2\".to_string(),\n                    \"Premium insight 3\".to_string(),\n                    \"Exclusive data point\".to_string(),\n                ],\n                tier: \"premium\".to_string(),\n            })\n        }\n        None =&gt; {\n            let requirement = PaymentRequirement::new(\"0.10\")\n                .with_description(\"Access to premium tier data\")\n                .with_expires_in(600);\n            let payment_request = create_payment_request(&amp;state.config, &amp;requirement, \"/premium\");\n            payment_required_response(payment_request)\n        }\n    }\n}\n\n/// Enterprise tier - $1.00\n#[get(\"/enterprise\")]\nasync fn enterprise_tier(\n    state: web::Data&lt;X402State&gt;,\n    auth: Option&lt;PaymentExtractor&gt;,\n) -&gt; HttpResponse {\n    match auth {\n        Some(auth) =&gt; {\n            HttpResponse::Ok().json(PremiumData {\n                message: \"Access granted to enterprise tier\".to_string(),\n                data: vec![\n                    \"Enterprise analytics 1\".to_string(),\n                    \"Enterprise analytics 2\".to_string(),\n                    \"Enterprise analytics 3\".to_string(),\n                    \"Enterprise analytics 4\".to_string(),\n                    \"Confidential market data\".to_string(),\n                    \"Advanced predictions\".to_string(),\n                ],\n                tier: \"enterprise\".to_string(),\n            })\n        }\n        None =&gt; {\n            let requirement = PaymentRequirement::new(\"1.00\")\n                .with_description(\"Access to enterprise tier data and analytics\");\n            let payment_request =\n                create_payment_request(&amp;state.config, &amp;requirement, \"/enterprise\");\n            payment_required_response(payment_request)\n        }\n    }\n}\n\n/// Health check\n#[get(\"/health\")]\nasync fn health() -&gt; &amp;'static str {\n    \"OK\"\n}\n\n#[actix_web::main]\nasync fn main() -&gt; std::io::Result&lt;()&gt; {\n    // Configure X402\n    let config = X402Config {\n        payment_address: \"7xKXtg2CW87d97TXJSDpbD5jBkheTqA83TZRuJosgAsU\".to_string(),\n        token_mint: \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\".to_string(),\n        network: \"solana-devnet\".to_string(),\n        rpc_url: None,\n        auto_verify: true,\n    };\n\n    let state = web::Data::new(X402State {\n        config: config.clone(),\n    });\n\n    println!(\"\\n\ud83c\udf10 Starting Actix Web X402 Example Server\");\n    println!(\"=========================================\");\n    println!(\"Payment Address: {}\", config.payment_address);\n    println!(\"Token Mint: {}\", config.token_mint);\n    println!(\"Network: {}\", config.network);\n    println!(\"\\nEndpoints:\");\n    println!(\"  - GET  /          : Free endpoint (no payment)\");\n    println!(\"  - GET  /basic     : Basic tier ($0.01)\");\n    println!(\"  - GET  /premium   : Premium tier ($0.10)\");\n    println!(\"  - GET  /enterprise: Enterprise tier ($1.00)\");\n    println!(\"  - GET  /health    : Health check\");\n    println!(\"\\nServer running at http://127.0.0.1:8080\\n\");\n\n    HttpServer::new(move || {\n        App::new()\n            .app_data(state.clone())\n            .service(index)\n            .service(basic_tier)\n            .service(premium_tier)\n            .service(enterprise_tier)\n            .service(health)\n    })\n    .bind((\"127.0.0.1\", 8080))?\n    .run()\n    .await\n}\n</code></pre>"},{"location":"rust/examples/actix-server/#configuration","title":"Configuration","text":"<p>Update the wallet addresses in the code:</p> <pre><code>let config = X402Config {\n    payment_address: \"YOUR_WALLET_ADDRESS\".to_string(),  // Replace with your wallet\n    token_mint: \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\".to_string(),  // USDC Devnet\n    network: \"solana-devnet\".to_string(),\n    rpc_url: None,\n    auto_verify: true,\n};\n</code></pre>"},{"location":"rust/examples/actix-server/#using-with-client","title":"Using with Client","text":"<p>Test with the auto client:</p> <pre><code>use openlibx402_client::{X402AutoClient, AutoClientOptions};\nuse solana_sdk::signature::Keypair;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let keypair = Keypair::new();\n    let options = AutoClientOptions {\n        max_payment_amount: \"5.0\".to_string(),\n        auto_retry: true,\n        max_retries: 3,\n    };\n\n    let client = X402AutoClient::new(keypair, None, Some(options));\n\n    // Test each tier\n    for endpoint in [\"basic\", \"premium\", \"enterprise\"] {\n        let url = format!(\"http://localhost:8080/{}\", endpoint);\n        match client.get(&amp;url).await {\n            Ok(response) =&gt; {\n                let body = response.text().await?;\n                println!(\"\u2713 {}: {}\", endpoint, body);\n            }\n            Err(e) =&gt; {\n                eprintln!(\"\u2717 {}: {}\", endpoint, e);\n            }\n        }\n    }\n\n    Ok(())\n}\n</code></pre>"},{"location":"rust/examples/actix-server/#key-features-demonstrated","title":"Key Features Demonstrated","text":"<ol> <li>Multiple Pricing Tiers - Different prices for different data levels</li> <li>Payment Descriptions - Human-readable descriptions in payment requests</li> <li>Custom Expirations - Premium tier has 10-minute expiration</li> <li>Optional Extractors - Using <code>Option&lt;PaymentExtractor&gt;</code> for flexible handling</li> <li>Health Check - Free endpoint for monitoring</li> <li>Async Handlers - All handlers are async for maximum performance</li> </ol>"},{"location":"rust/examples/actix-server/#performance-considerations","title":"Performance Considerations","text":"<p>Actix Web is known for excellent performance: - Async I/O with Tokio - Efficient request routing - Low overhead middleware - Connection pooling</p>"},{"location":"rust/examples/actix-server/#next-steps","title":"Next Steps","text":"<ul> <li>Modify pricing tiers</li> <li>Add custom business logic</li> <li>Integrate with database</li> <li>Add rate limiting</li> <li>Deploy to production</li> <li>Add middleware for logging/metrics</li> </ul>"},{"location":"rust/examples/actix-server/#see-also","title":"See Also","text":"<ul> <li>Actix Web Middleware Documentation</li> <li>Server Quick Start</li> <li>Rocket Server Example</li> </ul>"},{"location":"rust/examples/rocket-server/","title":"Rocket Server Example","text":"<p>Complete example of an X402-enabled API server using Rocket with multiple pricing tiers.</p>"},{"location":"rust/examples/rocket-server/#source-code","title":"Source Code","text":"<p>Location: <code>examples/rust/rocket-server/</code></p>"},{"location":"rust/examples/rocket-server/#overview","title":"Overview","text":"<p>This example demonstrates: - Free and paid endpoints - Multiple pricing tiers ($0.01, $0.10, $1.00) - Payment requirement configuration - Health check endpoint</p>"},{"location":"rust/examples/rocket-server/#running-the-example","title":"Running the Example","text":"<pre><code>cd examples/rust/rocket-server\ncargo run\n</code></pre> <p>Server starts on <code>http://localhost:8000</code></p>"},{"location":"rust/examples/rocket-server/#endpoints","title":"Endpoints","text":"Endpoint Price Description <code>GET /</code> Free Welcome message <code>GET /basic</code> $0.01 Basic tier data <code>GET /premium</code> $0.10 Premium tier data <code>GET /enterprise</code> $1.00 Enterprise tier data <code>GET /health</code> Free Health check"},{"location":"rust/examples/rocket-server/#testing","title":"Testing","text":""},{"location":"rust/examples/rocket-server/#free-endpoint","title":"Free Endpoint","text":"<pre><code>curl http://localhost:8000/\n</code></pre> <p>Response: <pre><code>{\n  \"message\": \"Welcome to the X402 Rocket example server!\"\n}\n</code></pre></p>"},{"location":"rust/examples/rocket-server/#payment-required","title":"Payment Required","text":"<pre><code>curl -v http://localhost:8000/premium\n</code></pre> <p>Response (402 Payment Required): <pre><code>{\n  \"max_amount_required\": \"0.10\",\n  \"asset_type\": \"SPL\",\n  \"asset_address\": \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\",\n  \"payment_address\": \"7xKXtg2CW87d97TXJSDpbD5jBkheTqA83TZRuJosgAsU\",\n  \"network\": \"solana-devnet\",\n  \"expires_at\": \"2025-10-31T12:05:00Z\",\n  \"nonce\": \"abc-123-def\",\n  \"payment_id\": \"pay-456-ghi\",\n  \"resource\": \"/premium\",\n  \"description\": \"Access to premium tier data\"\n}\n</code></pre></p>"},{"location":"rust/examples/rocket-server/#complete-code","title":"Complete Code","text":"<pre><code>use openlibx402_rocket::{\n    create_payment_request, PaymentGuard, PaymentRequirement,\n    PaymentRequiredResponse, X402Config,\n};\nuse rocket::{get, routes, serde::json::Json, State};\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Serialize, Deserialize)]\nstruct PremiumData {\n    message: String,\n    data: Vec&lt;String&gt;,\n    tier: String,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\nstruct BasicData {\n    message: String,\n}\n\n/// Free endpoint\n#[get(\"/\")]\nfn index() -&gt; Json&lt;BasicData&gt; {\n    Json(BasicData {\n        message: \"Welcome to the X402 Rocket example server!\".to_string(),\n    })\n}\n\n/// Basic tier - $0.01\n#[get(\"/basic\")]\nfn basic_tier(\n    config: &amp;State&lt;X402Config&gt;,\n    _auth: Option&lt;PaymentGuard&gt;,\n) -&gt; Result&lt;Json&lt;PremiumData&gt;, PaymentRequiredResponse&gt; {\n    match _auth {\n        Some(auth) =&gt; {\n            Ok(Json(PremiumData {\n                message: \"Access granted to basic tier\".to_string(),\n                data: vec![\n                    \"Basic data point 1\".to_string(),\n                    \"Basic data point 2\".to_string(),\n                ],\n                tier: \"basic\".to_string(),\n            }))\n        }\n        None =&gt; {\n            let requirement = PaymentRequirement::new(\"0.01\")\n                .with_description(\"Access to basic tier data\");\n            let payment_request = create_payment_request(config, &amp;requirement, \"/basic\");\n            Err(PaymentRequiredResponse { payment_request })\n        }\n    }\n}\n\n/// Premium tier - $0.10\n#[get(\"/premium\")]\nfn premium_tier(\n    config: &amp;State&lt;X402Config&gt;,\n    _auth: Option&lt;PaymentGuard&gt;,\n) -&gt; Result&lt;Json&lt;PremiumData&gt;, PaymentRequiredResponse&gt; {\n    match _auth {\n        Some(auth) =&gt; {\n            Ok(Json(PremiumData {\n                message: \"Access granted to premium tier\".to_string(),\n                data: vec![\n                    \"Premium insight 1\".to_string(),\n                    \"Premium insight 2\".to_string(),\n                    \"Premium insight 3\".to_string(),\n                    \"Exclusive data point\".to_string(),\n                ],\n                tier: \"premium\".to_string(),\n            }))\n        }\n        None =&gt; {\n            let requirement = PaymentRequirement::new(\"0.10\")\n                .with_description(\"Access to premium tier data\")\n                .with_expires_in(600);\n            let payment_request = create_payment_request(config, &amp;requirement, \"/premium\");\n            Err(PaymentRequiredResponse { payment_request })\n        }\n    }\n}\n\n/// Enterprise tier - $1.00\n#[get(\"/enterprise\")]\nfn enterprise_tier(\n    config: &amp;State&lt;X402Config&gt;,\n    _auth: Option&lt;PaymentGuard&gt;,\n) -&gt; Result&lt;Json&lt;PremiumData&gt;, PaymentRequiredResponse&gt; {\n    match _auth {\n        Some(auth) =&gt; {\n            Ok(Json(PremiumData {\n                message: \"Access granted to enterprise tier\".to_string(),\n                data: vec![\n                    \"Enterprise analytics 1\".to_string(),\n                    \"Enterprise analytics 2\".to_string(),\n                    \"Enterprise analytics 3\".to_string(),\n                    \"Enterprise analytics 4\".to_string(),\n                    \"Confidential market data\".to_string(),\n                    \"Advanced predictions\".to_string(),\n                ],\n                tier: \"enterprise\".to_string(),\n            }))\n        }\n        None =&gt; {\n            let requirement = PaymentRequirement::new(\"1.00\")\n                .with_description(\"Access to enterprise tier data and analytics\");\n            let payment_request = create_payment_request(config, &amp;requirement, \"/enterprise\");\n            Err(PaymentRequiredResponse { payment_request })\n        }\n    }\n}\n\n/// Health check\n#[get(\"/health\")]\nfn health() -&gt; &amp;'static str {\n    \"OK\"\n}\n\n#[rocket::main]\nasync fn main() -&gt; Result&lt;(), rocket::Error&gt; {\n    // Configure X402\n    let config = X402Config {\n        payment_address: \"7xKXtg2CW87d97TXJSDpbD5jBkheTqA83TZRuJosgAsU\".to_string(),\n        token_mint: \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\".to_string(),\n        network: \"solana-devnet\".to_string(),\n        rpc_url: None,\n        auto_verify: true,\n    };\n\n    println!(\"\\n\ud83d\ude80 Starting Rocket X402 Example Server\");\n    println!(\"=====================================\");\n    println!(\"Payment Address: {}\", config.payment_address);\n    println!(\"Token Mint: {}\", config.token_mint);\n    println!(\"Network: {}\", config.network);\n    println!(\"\\nEndpoints:\");\n    println!(\"  - GET  /          : Free endpoint (no payment)\");\n    println!(\"  - GET  /basic     : Basic tier ($0.01)\");\n    println!(\"  - GET  /premium   : Premium tier ($0.10)\");\n    println!(\"  - GET  /enterprise: Enterprise tier ($1.00)\");\n    println!(\"  - GET  /health    : Health check\\n\");\n\n    let _rocket = rocket::build()\n        .manage(config)\n        .mount(\"/\", routes![index, basic_tier, premium_tier, enterprise_tier, health])\n        .launch()\n        .await?;\n\n    Ok(())\n}\n</code></pre>"},{"location":"rust/examples/rocket-server/#configuration","title":"Configuration","text":"<p>Update the wallet addresses in the code:</p> <pre><code>let config = X402Config {\n    payment_address: \"YOUR_WALLET_ADDRESS\".to_string(),  // Replace with your wallet\n    token_mint: \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\".to_string(),  // USDC Devnet\n    network: \"solana-devnet\".to_string(),\n    rpc_url: None,\n    auto_verify: true,\n};\n</code></pre>"},{"location":"rust/examples/rocket-server/#using-with-client","title":"Using with Client","text":"<p>Test with the auto client:</p> <pre><code>use openlibx402_client::{X402AutoClient, AutoClientOptions};\nuse solana_sdk::signature::Keypair;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let keypair = Keypair::new();\n    let options = AutoClientOptions {\n        max_payment_amount: \"5.0\".to_string(),\n        auto_retry: true,\n        max_retries: 3,\n    };\n\n    let client = X402AutoClient::new(keypair, None, Some(options));\n\n    // Test each tier\n    for endpoint in [\"basic\", \"premium\", \"enterprise\"] {\n        let url = format!(\"http://localhost:8000/{}\", endpoint);\n        match client.get(&amp;url).await {\n            Ok(response) =&gt; {\n                let body = response.text().await?;\n                println!(\"\u2713 {}: {}\", endpoint, body);\n            }\n            Err(e) =&gt; {\n                eprintln!(\"\u2717 {}: {}\", endpoint, e);\n            }\n        }\n    }\n\n    Ok(())\n}\n</code></pre>"},{"location":"rust/examples/rocket-server/#key-features-demonstrated","title":"Key Features Demonstrated","text":"<ol> <li>Multiple Pricing Tiers - Different prices for different data levels</li> <li>Payment Descriptions - Human-readable descriptions in payment requests</li> <li>Custom Expirations - Premium tier has 10-minute expiration</li> <li>Optional Guards - Using <code>Option&lt;PaymentGuard&gt;</code> for flexible handling</li> <li>Health Check - Free endpoint for monitoring</li> </ol>"},{"location":"rust/examples/rocket-server/#next-steps","title":"Next Steps","text":"<ul> <li>Modify pricing tiers</li> <li>Add custom business logic</li> <li>Integrate with database</li> <li>Add rate limiting</li> <li>Deploy to production</li> </ul>"},{"location":"rust/examples/rocket-server/#see-also","title":"See Also","text":"<ul> <li>Rocket Middleware Documentation</li> <li>Server Quick Start</li> <li>Actix Web Server Example</li> </ul>"},{"location":"rust/getting-started/client-quickstart/","title":"Client Quick Start","text":"<p>Build your first X402 client in Rust to consume payment-protected APIs. This guide shows you how to use both automatic and explicit payment handling.</p>"},{"location":"rust/getting-started/client-quickstart/#choose-your-client-type","title":"Choose Your Client Type","text":"<ul> <li>Auto Client - Automatic payment handling (recommended)</li> <li>Explicit Client - Full control over payment flow</li> </ul>"},{"location":"rust/getting-started/client-quickstart/#auto-client","title":"Auto Client","text":"<p>The auto client automatically detects 402 responses, creates payments, and retries requests.</p>"},{"location":"rust/getting-started/client-quickstart/#step-1-create-project","title":"Step 1: Create Project","text":"<pre><code>cargo new my-x402-client\ncd my-x402-client\n</code></pre>"},{"location":"rust/getting-started/client-quickstart/#step-2-add-dependencies","title":"Step 2: Add Dependencies","text":"<pre><code>[dependencies]\nopenlibx402-core = \"0.1\"\nopenlibx402-client = \"0.1\"\ntokio = { version = \"1.35\", features = [\"full\"] }\nsolana-sdk = \"2.0\"\n</code></pre>"},{"location":"rust/getting-started/client-quickstart/#step-3-load-keypair","title":"Step 3: Load Keypair","text":"<pre><code>use solana_sdk::signature::{read_keypair_file, Keypair};\nuse std::error::Error;\n\nfn load_keypair() -&gt; Result&lt;Keypair, Box&lt;dyn Error&gt;&gt; {\n    // Load from file\n    let keypair = read_keypair_file(\n        std::env::var(\"SOLANA_KEYPAIR\")\n            .unwrap_or_else(|_| {\n                format!(\"{}/.config/solana/id.json\", std::env::var(\"HOME\").unwrap())\n            })\n    )?;\n    Ok(keypair)\n}\n</code></pre>"},{"location":"rust/getting-started/client-quickstart/#step-4-create-auto-client","title":"Step 4: Create Auto Client","text":"<pre><code>use openlibx402_client::{X402AutoClient, AutoClientOptions};\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Load your Solana keypair\n    let keypair = load_keypair()?;\n\n    // Configure auto client\n    let options = AutoClientOptions {\n        max_payment_amount: \"5.0\".to_string(),  // Max $5 per request\n        auto_retry: true,\n        max_retries: 3,\n    };\n\n    // Create client\n    let client = X402AutoClient::new(keypair, None, Some(options));\n\n    // Make request - payment handled automatically!\n    let response = client.get(\"http://localhost:8000/premium\").await?;\n    let body = response.text().await?;\n\n    println!(\"Response: {}\", body);\n\n    Ok(())\n}\n</code></pre>"},{"location":"rust/getting-started/client-quickstart/#step-5-run-client","title":"Step 5: Run Client","text":"<pre><code>cargo run\n</code></pre> <p>The client will automatically: 1. Make initial request 2. Detect 402 response 3. Create and send payment 4. Retry with payment authorization 5. Return the data</p>"},{"location":"rust/getting-started/client-quickstart/#explicit-client","title":"Explicit Client","text":"<p>The explicit client gives you full control over the payment flow.</p>"},{"location":"rust/getting-started/client-quickstart/#step-1-create-project_1","title":"Step 1: Create Project","text":"<p>Same as auto client.</p>"},{"location":"rust/getting-started/client-quickstart/#step-2-add-dependencies_1","title":"Step 2: Add Dependencies","text":"<p>Same as auto client.</p>"},{"location":"rust/getting-started/client-quickstart/#step-3-create-explicit-client","title":"Step 3: Create Explicit Client","text":"<pre><code>use openlibx402_client::X402Client;\nuse solana_sdk::signature::{read_keypair_file, Keypair};\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Load keypair\n    let keypair = read_keypair_file(\n        format!(\"{}/.config/solana/id.json\", std::env::var(\"HOME\")?)\n    )?;\n\n    // Create client\n    let client = X402Client::new(keypair, None);\n\n    // Make initial request\n    let response = client.get(\"http://localhost:8000/premium\").await?;\n\n    // Check if payment is required\n    if client.is_payment_required(&amp;response) {\n        println!(\"Payment required!\");\n\n        // Parse payment request\n        let payment_request = client.parse_payment_request(response).await?;\n\n        println!(\"Amount: {} USDC\", payment_request.max_amount_required);\n        println!(\"Description: {:?}\", payment_request.description);\n\n        // Create and send payment\n        let authorization = client.create_payment(&amp;payment_request).await?;\n\n        println!(\"Payment sent! Signature: {}\", authorization.signature);\n\n        // Retry with payment authorization\n        let response = client.get_with_auth(\n            \"http://localhost:8000/premium\",\n            &amp;authorization\n        ).await?;\n\n        let body = response.text().await?;\n        println!(\"Response: {}\", body);\n    } else {\n        // No payment required\n        let body = response.text().await?;\n        println!(\"Response: {}\", body);\n    }\n\n    Ok(())\n}\n</code></pre>"},{"location":"rust/getting-started/client-quickstart/#step-4-run-client","title":"Step 4: Run Client","text":"<pre><code>cargo run\n</code></pre>"},{"location":"rust/getting-started/client-quickstart/#post-requests","title":"POST Requests","text":"<p>Both clients support POST requests:</p>"},{"location":"rust/getting-started/client-quickstart/#auto-client_1","title":"Auto Client","text":"<pre><code>let body = serde_json::json!({\n    \"query\": \"premium data\"\n});\n\nlet response = client.post(\n    \"http://localhost:8000/query\",\n    Some(body.to_string())\n).await?;\n</code></pre>"},{"location":"rust/getting-started/client-quickstart/#explicit-client_1","title":"Explicit Client","text":"<pre><code>let body = serde_json::json!({\n    \"query\": \"premium data\"\n});\n\nlet response = client.post(\n    \"http://localhost:8000/query\",\n    Some(body.to_string())\n).await?;\n\nif client.is_payment_required(&amp;response) {\n    let payment_request = client.parse_payment_request(response).await?;\n    let authorization = client.create_payment(&amp;payment_request).await?;\n\n    let response = client.post_with_auth(\n        \"http://localhost:8000/query\",\n        Some(body.to_string()),\n        &amp;authorization\n    ).await?;\n\n    // Handle response\n}\n</code></pre>"},{"location":"rust/getting-started/client-quickstart/#error-handling","title":"Error Handling","text":"<p>Handle X402-specific errors:</p> <pre><code>use openlibx402_core::X402Error;\n\nmatch client.get(url).await {\n    Ok(response) =&gt; {\n        // Handle response\n    }\n    Err(e) =&gt; {\n        match e {\n            X402Error::PaymentRequired(msg) =&gt; {\n                eprintln!(\"Payment required: {}\", msg);\n            }\n            X402Error::InsufficientFunds(msg) =&gt; {\n                eprintln!(\"Insufficient funds: {}\", msg);\n            }\n            X402Error::PaymentExpired(msg) =&gt; {\n                eprintln!(\"Payment expired: {}\", msg);\n            }\n            X402Error::Network(msg) =&gt; {\n                eprintln!(\"Network error: {}\", msg);\n            }\n            _ =&gt; {\n                eprintln!(\"Error: {}\", e);\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"rust/getting-started/client-quickstart/#configuration","title":"Configuration","text":""},{"location":"rust/getting-started/client-quickstart/#auto-client-options","title":"Auto Client Options","text":"<pre><code>let options = AutoClientOptions {\n    max_payment_amount: \"10.0\".to_string(),  // Maximum amount to pay\n    auto_retry: true,                         // Automatically retry after payment\n    max_retries: 3,                           // Maximum retry attempts\n};\n</code></pre>"},{"location":"rust/getting-started/client-quickstart/#custom-rpc-url","title":"Custom RPC URL","text":"<pre><code>let client = X402AutoClient::new(\n    keypair,\n    Some(\"https://your-rpc-endpoint.com\"),\n    Some(options)\n);\n</code></pre>"},{"location":"rust/getting-started/client-quickstart/#best-practices","title":"Best Practices","text":""},{"location":"rust/getting-started/client-quickstart/#1-load-keypair-securely","title":"1. Load Keypair Securely","text":"<pre><code>use std::env;\n\nfn load_keypair() -&gt; Result&lt;Keypair, Box&lt;dyn Error&gt;&gt; {\n    let path = env::var(\"SOLANA_KEYPAIR\")\n        .or_else(|_| env::var(\"HOME\").map(|h| format!(\"{}/.config/solana/id.json\", h)))?;\n\n    read_keypair_file(path)\n        .map_err(|e| format!(\"Failed to load keypair: {}\", e).into())\n}\n</code></pre>"},{"location":"rust/getting-started/client-quickstart/#2-set-payment-limits","title":"2. Set Payment Limits","text":"<pre><code>let options = AutoClientOptions {\n    max_payment_amount: \"5.0\".to_string(),  // Protect against overpaying\n    auto_retry: true,\n    max_retries: 3,\n};\n</code></pre>"},{"location":"rust/getting-started/client-quickstart/#3-handle-all-error-cases","title":"3. Handle All Error Cases","text":"<pre><code>async fn fetch_premium_data(client: &amp;X402AutoClient) -&gt; Result&lt;String, Box&lt;dyn Error&gt;&gt; {\n    match client.get(\"http://localhost:8000/premium\").await {\n        Ok(response) =&gt; {\n            if response.status().is_success() {\n                Ok(response.text().await?)\n            } else {\n                Err(format!(\"HTTP error: {}\", response.status()).into())\n            }\n        }\n        Err(X402Error::InsufficientFunds(_)) =&gt; {\n            Err(\"Not enough USDC in wallet\".into())\n        }\n        Err(X402Error::PaymentExpired(_)) =&gt; {\n            // Retry with new payment request\n            client.get(\"http://localhost:8000/premium\").await?\n                .text().await.map_err(Into::into)\n        }\n        Err(e) =&gt; Err(e.into()),\n    }\n}\n</code></pre>"},{"location":"rust/getting-started/client-quickstart/#4-use-connection-pooling","title":"4. Use Connection Pooling","text":"<p>The client reuses HTTP connections automatically via reqwest.</p>"},{"location":"rust/getting-started/client-quickstart/#testing-without-payments","title":"Testing Without Payments","text":"<p>For testing, you can mock the payment processor:</p> <pre><code>#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[tokio::test]\n    async fn test_client() {\n        // Use test server without payment requirements\n        let client = X402AutoClient::new(\n            Keypair::new(),\n            None,\n            None\n        );\n\n        let response = client.get(\"http://localhost:8000/free-endpoint\").await.unwrap();\n        assert!(response.status().is_success());\n    }\n}\n</code></pre>"},{"location":"rust/getting-started/client-quickstart/#complete-example","title":"Complete Example","text":"<pre><code>use openlibx402_client::{X402AutoClient, AutoClientOptions};\nuse solana_sdk::signature::read_keypair_file;\nuse std::error::Error;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {\n    // Load keypair\n    let keypair = read_keypair_file(\n        format!(\"{}/.config/solana/devnet.json\", std::env::var(\"HOME\")?)\n    )?;\n\n    // Configure client\n    let options = AutoClientOptions {\n        max_payment_amount: \"5.0\".to_string(),\n        auto_retry: true,\n        max_retries: 3,\n    };\n\n    let client = X402AutoClient::new(keypair, None, Some(options));\n\n    // Make multiple requests\n    let endpoints = vec![\n        \"http://localhost:8000/basic\",\n        \"http://localhost:8000/premium\",\n        \"http://localhost:8000/enterprise\",\n    ];\n\n    for endpoint in endpoints {\n        match client.get(endpoint).await {\n            Ok(response) =&gt; {\n                let body = response.text().await?;\n                println!(\"\u2713 {}: {}\", endpoint, body);\n            }\n            Err(e) =&gt; {\n                eprintln!(\"\u2717 {}: {}\", endpoint, e);\n            }\n        }\n    }\n\n    Ok(())\n}\n</code></pre>"},{"location":"rust/getting-started/client-quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Client Library Reference - Detailed API documentation</li> <li>Error Handling - All error types and handling</li> <li>Configuration - Advanced configuration options</li> </ul>"},{"location":"rust/getting-started/client-quickstart/#troubleshooting","title":"Troubleshooting","text":""},{"location":"rust/getting-started/client-quickstart/#failed-to-load-keypair","title":"\"Failed to load keypair\"","text":"<p>Make sure your keypair file exists:</p> <pre><code>ls ~/.config/solana/id.json\n</code></pre> <p>Generate one if needed:</p> <pre><code>solana-keygen new --outfile ~/.config/solana/devnet.json\n</code></pre>"},{"location":"rust/getting-started/client-quickstart/#insufficient-funds","title":"\"Insufficient funds\"","text":"<p>Check your SOL balance for gas fees:</p> <pre><code>solana balance\n</code></pre> <p>Airdrop on devnet:</p> <pre><code>solana airdrop 2\n</code></pre>"},{"location":"rust/getting-started/client-quickstart/#payment-verification-failed","title":"\"Payment verification failed\"","text":"<p>Ensure you're using the correct network (devnet vs mainnet) and have USDC tokens.</p>"},{"location":"rust/getting-started/installation/","title":"Installation","text":"<p>This guide covers installing the OpenLibx402 Rust packages for your project.</p>"},{"location":"rust/getting-started/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Rust 1.70+ - Install Rust</li> <li>Cargo - Comes with Rust installation</li> <li>Solana Wallet - For testing and production payments</li> </ul>"},{"location":"rust/getting-started/installation/#quick-install","title":"Quick Install","text":""},{"location":"rust/getting-started/installation/#for-server-projects","title":"For Server Projects","text":"<pre><code># Add core library\ncargo add openlibx402-core\n\n# Add framework integration\ncargo add openlibx402-rocket\n# OR\ncargo add openlibx402-actix\n\n# Add required dependencies\ncargo add tokio --features full\ncargo add serde --features derive\n</code></pre>"},{"location":"rust/getting-started/installation/#for-client-projects","title":"For Client Projects","text":"<pre><code># Add core and client libraries\ncargo add openlibx402-core\ncargo add openlibx402-client\n\n# Add required dependencies\ncargo add tokio --features full\ncargo add solana-sdk\n</code></pre>"},{"location":"rust/getting-started/installation/#cargotoml-configuration","title":"Cargo.toml Configuration","text":""},{"location":"rust/getting-started/installation/#server-example-rocket","title":"Server Example (Rocket)","text":"<pre><code>[package]\nname = \"my-x402-server\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nopenlibx402-core = \"0.1\"\nopenlibx402-rocket = \"0.1\"\nrocket = { version = \"0.5\", features = [\"json\"] }\ntokio = { version = \"1.35\", features = [\"full\"] }\nserde = { version = \"1.0\", features = [\"derive\"] }\nserde_json = \"1.0\"\n</code></pre>"},{"location":"rust/getting-started/installation/#server-example-actix-web","title":"Server Example (Actix Web)","text":"<pre><code>[package]\nname = \"my-x402-server\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nopenlibx402-core = \"0.1\"\nopenlibx402-actix = \"0.1\"\nactix-web = \"4.4\"\nactix-rt = \"2.9\"\ntokio = { version = \"1.35\", features = [\"full\"] }\nserde = { version = \"1.0\", features = [\"derive\"] }\nserde_json = \"1.0\"\n</code></pre>"},{"location":"rust/getting-started/installation/#client-example","title":"Client Example","text":"<pre><code>[package]\nname = \"my-x402-client\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nopenlibx402-core = \"0.1\"\nopenlibx402-client = \"0.1\"\ntokio = { version = \"1.35\", features = [\"full\"] }\nsolana-sdk = \"2.0\"\nreqwest = \"0.12\"\n</code></pre>"},{"location":"rust/getting-started/installation/#from-source","title":"From Source","text":"<p>To build from source or contribute:</p> <pre><code># Clone repository\ngit clone https://github.com/openlibx402/openlibx402.git\ncd openlibx402/packages/rust\n\n# Build all packages\ncargo build --release\n\n# Run tests\ncargo test --workspace\n\n# Build documentation\ncargo doc --open\n</code></pre>"},{"location":"rust/getting-started/installation/#workspace-development","title":"Workspace Development","text":"<p>The Rust packages are organized as a Cargo workspace:</p> <pre><code>packages/rust/\n\u251c\u2500\u2500 Cargo.toml              # Workspace configuration\n\u251c\u2500\u2500 openlibx402-core/       # Core library\n\u251c\u2500\u2500 openlibx402-client/     # Client library\n\u251c\u2500\u2500 openlibx402-rocket/     # Rocket integration\n\u2514\u2500\u2500 openlibx402-actix/      # Actix Web integration\n</code></pre> <p>To work on multiple packages simultaneously:</p> <pre><code>cd packages/rust\n\n# Build everything\ncargo build\n\n# Test everything\ncargo test\n\n# Build specific package\ncargo build -p openlibx402-core\n\n# Test specific package\ncargo test -p openlibx402-client\n</code></pre>"},{"location":"rust/getting-started/installation/#setting-up-solana","title":"Setting Up Solana","text":""},{"location":"rust/getting-started/installation/#install-solana-cli","title":"Install Solana CLI","text":"<pre><code>sh -c \"$(curl -sSfL https://release.solana.com/stable/install)\"\n</code></pre>"},{"location":"rust/getting-started/installation/#generate-keypair","title":"Generate Keypair","text":"<p>For development and testing:</p> <pre><code># Generate new keypair\nsolana-keygen new --outfile ~/.config/solana/devnet.json\n\n# View public key\nsolana-keygen pubkey ~/.config/solana/devnet.json\n\n# Set network to devnet\nsolana config set --url https://api.devnet.solana.com\n\n# Airdrop SOL for gas fees\nsolana airdrop 2\n</code></pre>"},{"location":"rust/getting-started/installation/#get-test-usdc","title":"Get Test USDC","text":"<p>On devnet, you can mint test USDC or use a faucet.</p>"},{"location":"rust/getting-started/installation/#environment-variables","title":"Environment Variables","text":"<p>Set up your environment:</p> <pre><code># Add to ~/.bashrc or ~/.zshrc\nexport SOLANA_KEYPAIR=\"$HOME/.config/solana/devnet.json\"\nexport X402_PAYMENT_ADDRESS=\"YOUR_WALLET_ADDRESS\"\nexport X402_TOKEN_MINT=\"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\"  # USDC Devnet\nexport X402_NETWORK=\"solana-devnet\"\nexport X402_RPC_URL=\"https://api.devnet.solana.com\"\n</code></pre>"},{"location":"rust/getting-started/installation/#verify-installation","title":"Verify Installation","text":"<p>Create a simple test file:</p> <pre><code>// test_installation.rs\nuse openlibx402_core::{PaymentRequest, X402Error};\n\nfn main() -&gt; Result&lt;(), X402Error&gt; {\n    println!(\"OpenLibx402 Rust SDK installed successfully!\");\n    println!(\"Version: {}\", openlibx402_core::VERSION);\n    Ok(())\n}\n</code></pre> <p>Run it:</p> <pre><code>cargo run\n</code></pre>"},{"location":"rust/getting-started/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Server Quick Start - Build your first X402 server</li> <li>Client Quick Start - Build your first X402 client</li> <li>Core Library - Learn about core types and functions</li> </ul>"},{"location":"rust/getting-started/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"rust/getting-started/installation/#compilation-errors","title":"Compilation Errors","text":"<p>If you encounter compilation errors:</p> <pre><code># Update Rust\nrustup update\n\n# Clean build cache\ncargo clean\n\n# Rebuild\ncargo build\n</code></pre>"},{"location":"rust/getting-started/installation/#dependency-conflicts","title":"Dependency Conflicts","text":"<p>If you have dependency conflicts:</p> <pre><code># Update dependencies\ncargo update\n\n# Check for outdated dependencies\ncargo outdated\n</code></pre>"},{"location":"rust/getting-started/installation/#solana-sdk-issues","title":"Solana SDK Issues","text":"<p>If Solana SDK installation fails:</p> <pre><code># Use specific version\ncargo add solana-sdk@2.0\ncargo add solana-client@2.0\n</code></pre>"},{"location":"rust/getting-started/installation/#support","title":"Support","text":"<p>Need help? Check: - Rust Documentation - Cargo Book - GitHub Issues</p>"},{"location":"rust/getting-started/server-quickstart/","title":"Server Quick Start","text":"<p>Build your first X402-enabled API server in Rust. This guide shows you how to protect endpoints with payment requirements using either Rocket or Actix Web.</p>"},{"location":"rust/getting-started/server-quickstart/#choose-your-framework","title":"Choose Your Framework","text":"<ul> <li>Rocket - Elegant, type-safe web framework</li> <li>Actix Web - High-performance, actor-based framework</li> </ul>"},{"location":"rust/getting-started/server-quickstart/#rocket-server","title":"Rocket Server","text":""},{"location":"rust/getting-started/server-quickstart/#step-1-create-project","title":"Step 1: Create Project","text":"<pre><code>cargo new my-x402-server\ncd my-x402-server\n</code></pre>"},{"location":"rust/getting-started/server-quickstart/#step-2-add-dependencies","title":"Step 2: Add Dependencies","text":"<pre><code>[dependencies]\nopenlibx402-core = \"0.1\"\nopenlibx402-rocket = \"0.1\"\nrocket = { version = \"0.5\", features = [\"json\"] }\ntokio = { version = \"1.35\", features = [\"full\"] }\nserde = { version = \"1.0\", features = [\"derive\"] }\nserde_json = \"1.0\"\n</code></pre>"},{"location":"rust/getting-started/server-quickstart/#step-3-write-server-code","title":"Step 3: Write Server Code","text":"<pre><code>use openlibx402_rocket::{\n    create_payment_request, PaymentGuard, PaymentRequirement,\n    PaymentRequiredResponse, X402Config,\n};\nuse rocket::{get, routes, serde::json::Json, State};\nuse serde::Serialize;\n\n#[derive(Serialize)]\nstruct PremiumData {\n    message: String,\n    data: Vec&lt;String&gt;,\n}\n\n// Free endpoint - no payment required\n#[get(\"/\")]\nfn index() -&gt; &amp;'static str {\n    \"Welcome to my X402 API!\"\n}\n\n// Premium endpoint - requires $0.10 payment\n#[get(\"/premium\")]\nfn premium_data(\n    config: &amp;State&lt;X402Config&gt;,\n    auth: Option&lt;PaymentGuard&gt;,\n) -&gt; Result&lt;Json&lt;PremiumData&gt;, PaymentRequiredResponse&gt; {\n    match auth {\n        Some(_) =&gt; {\n            // Payment verified - return premium content\n            Ok(Json(PremiumData {\n                message: \"Premium content unlocked!\".to_string(),\n                data: vec![\n                    \"Secret data 1\".to_string(),\n                    \"Secret data 2\".to_string(),\n                ],\n            }))\n        }\n        None =&gt; {\n            // No payment - return 402 with payment request\n            let requirement = PaymentRequirement::new(\"0.10\")\n                .with_description(\"Access to premium data\");\n            let payment_request = create_payment_request(\n                config,\n                &amp;requirement,\n                \"/premium\"\n            );\n            Err(PaymentRequiredResponse { payment_request })\n        }\n    }\n}\n\n#[rocket::main]\nasync fn main() {\n    // Configure X402\n    let config = X402Config {\n        payment_address: \"YOUR_WALLET_ADDRESS\".to_string(),\n        token_mint: \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\".to_string(),\n        network: \"solana-devnet\".to_string(),\n        rpc_url: None,\n        auto_verify: true,\n    };\n\n    rocket::build()\n        .manage(config)\n        .mount(\"/\", routes![index, premium_data])\n        .launch()\n        .await\n        .unwrap();\n}\n</code></pre>"},{"location":"rust/getting-started/server-quickstart/#step-4-run-server","title":"Step 4: Run Server","text":"<pre><code>cargo run\n</code></pre> <p>Visit <code>http://localhost:8000/premium</code> - you'll get a 402 response with payment details!</p>"},{"location":"rust/getting-started/server-quickstart/#actix-web-server","title":"Actix Web Server","text":""},{"location":"rust/getting-started/server-quickstart/#step-1-create-project_1","title":"Step 1: Create Project","text":"<pre><code>cargo new my-x402-server\ncd my-x402-server\n</code></pre>"},{"location":"rust/getting-started/server-quickstart/#step-2-add-dependencies_1","title":"Step 2: Add Dependencies","text":"<pre><code>[dependencies]\nopenlibx402-core = \"0.1\"\nopenlibx402-actix = \"0.1\"\nactix-web = \"4.4\"\nactix-rt = \"2.9\"\ntokio = { version = \"1.35\", features = [\"full\"] }\nserde = { version = \"1.0\", features = [\"derive\"] }\nserde_json = \"1.0\"\n</code></pre>"},{"location":"rust/getting-started/server-quickstart/#step-3-write-server-code_1","title":"Step 3: Write Server Code","text":"<pre><code>use actix_web::{get, web, App, HttpResponse, HttpServer};\nuse openlibx402_actix::{\n    create_payment_request, payment_required_response,\n    PaymentExtractor, PaymentRequirement, X402Config, X402State,\n};\nuse serde::Serialize;\n\n#[derive(Serialize)]\nstruct PremiumData {\n    message: String,\n    data: Vec&lt;String&gt;,\n}\n\n// Free endpoint - no payment required\n#[get(\"/\")]\nasync fn index() -&gt; HttpResponse {\n    HttpResponse::Ok().body(\"Welcome to my X402 API!\")\n}\n\n// Premium endpoint - requires $0.10 payment\n#[get(\"/premium\")]\nasync fn premium_data(\n    state: web::Data&lt;X402State&gt;,\n    auth: Option&lt;PaymentExtractor&gt;,\n) -&gt; HttpResponse {\n    match auth {\n        Some(_) =&gt; {\n            // Payment verified - return premium content\n            HttpResponse::Ok().json(PremiumData {\n                message: \"Premium content unlocked!\".to_string(),\n                data: vec![\n                    \"Secret data 1\".to_string(),\n                    \"Secret data 2\".to_string(),\n                ],\n            })\n        }\n        None =&gt; {\n            // No payment - return 402 with payment request\n            let requirement = PaymentRequirement::new(\"0.10\")\n                .with_description(\"Access to premium data\");\n            let payment_request = create_payment_request(\n                &amp;state.config,\n                &amp;requirement,\n                \"/premium\"\n            );\n            payment_required_response(payment_request)\n        }\n    }\n}\n\n#[actix_web::main]\nasync fn main() -&gt; std::io::Result&lt;()&gt; {\n    // Configure X402\n    let config = X402Config {\n        payment_address: \"YOUR_WALLET_ADDRESS\".to_string(),\n        token_mint: \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\".to_string(),\n        network: \"solana-devnet\".to_string(),\n        rpc_url: None,\n        auto_verify: true,\n    };\n\n    let state = web::Data::new(X402State { config });\n\n    HttpServer::new(move || {\n        App::new()\n            .app_data(state.clone())\n            .service(index)\n            .service(premium_data)\n    })\n    .bind((\"127.0.0.1\", 8080))?\n    .run()\n    .await\n}\n</code></pre>"},{"location":"rust/getting-started/server-quickstart/#step-4-run-server_1","title":"Step 4: Run Server","text":"<pre><code>cargo run\n</code></pre> <p>Visit <code>http://localhost:8080/premium</code> - you'll get a 402 response with payment details!</p>"},{"location":"rust/getting-started/server-quickstart/#testing-your-server","title":"Testing Your Server","text":""},{"location":"rust/getting-started/server-quickstart/#using-curl","title":"Using curl","text":"<pre><code># Test free endpoint\ncurl http://localhost:8000/\n\n# Test premium endpoint (will return 402)\ncurl -v http://localhost:8000/premium\n</code></pre>"},{"location":"rust/getting-started/server-quickstart/#using-httpie","title":"Using httpie","text":"<pre><code># Install httpie\ncargo install httpie\n\n# Test premium endpoint\nhttp GET http://localhost:8000/premium\n</code></pre>"},{"location":"rust/getting-started/server-quickstart/#multiple-pricing-tiers","title":"Multiple Pricing Tiers","text":"<p>Add different pricing levels:</p> <pre><code>// Basic tier - $0.01\n#[get(\"/basic\")]\nfn basic_tier(\n    config: &amp;State&lt;X402Config&gt;,\n    auth: Option&lt;PaymentGuard&gt;,\n) -&gt; Result&lt;Json&lt;PremiumData&gt;, PaymentRequiredResponse&gt; {\n    match auth {\n        Some(_) =&gt; Ok(Json(PremiumData {\n            message: \"Basic tier\".to_string(),\n            data: vec![\"Basic data\".to_string()],\n        })),\n        None =&gt; {\n            let requirement = PaymentRequirement::new(\"0.01\");\n            let payment_request = create_payment_request(config, &amp;requirement, \"/basic\");\n            Err(PaymentRequiredResponse { payment_request })\n        }\n    }\n}\n\n// Premium tier - $0.10\n#[get(\"/premium\")]\nfn premium_tier(\n    config: &amp;State&lt;X402Config&gt;,\n    auth: Option&lt;PaymentGuard&gt;,\n) -&gt; Result&lt;Json&lt;PremiumData&gt;, PaymentRequiredResponse&gt; {\n    match auth {\n        Some(_) =&gt; Ok(Json(PremiumData {\n            message: \"Premium tier\".to_string(),\n            data: vec![\"Premium data 1\".to_string(), \"Premium data 2\".to_string()],\n        })),\n        None =&gt; {\n            let requirement = PaymentRequirement::new(\"0.10\");\n            let payment_request = create_payment_request(config, &amp;requirement, \"/premium\");\n            Err(PaymentRequiredResponse { payment_request })\n        }\n    }\n}\n\n// Enterprise tier - $1.00\n#[get(\"/enterprise\")]\nfn enterprise_tier(\n    config: &amp;State&lt;X402Config&gt;,\n    auth: Option&lt;PaymentGuard&gt;,\n) -&gt; Result&lt;Json&lt;PremiumData&gt;, PaymentRequiredResponse&gt; {\n    match auth {\n        Some(_) =&gt; Ok(Json(PremiumData {\n            message: \"Enterprise tier\".to_string(),\n            data: vec![\n                \"Enterprise data 1\".to_string(),\n                \"Enterprise data 2\".to_string(),\n                \"Enterprise data 3\".to_string(),\n            ],\n        })),\n        None =&gt; {\n            let requirement = PaymentRequirement::new(\"1.00\");\n            let payment_request = create_payment_request(config, &amp;requirement, \"/enterprise\");\n            Err(PaymentRequiredResponse { payment_request })\n        }\n    }\n}\n</code></pre>"},{"location":"rust/getting-started/server-quickstart/#configuration-options","title":"Configuration Options","text":"<p>Customize payment requirements:</p> <pre><code>let requirement = PaymentRequirement::new(\"0.10\")\n    .with_description(\"Access to premium API endpoint\")\n    .with_expires_in(600);  // 10 minutes\n</code></pre> <p>Configure X402:</p> <pre><code>let config = X402Config {\n    payment_address: \"YOUR_WALLET\".to_string(),\n    token_mint: \"USDC_MINT\".to_string(),\n    network: \"solana-devnet\".to_string(),\n    rpc_url: Some(\"https://your-rpc.com\".to_string()),  // Custom RPC\n    auto_verify: true,  // Verify payments on-chain\n};\n</code></pre>"},{"location":"rust/getting-started/server-quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Client Quick Start - Build a client to consume your API</li> <li>Rocket Middleware - Learn more about Rocket integration</li> <li>Actix Web Middleware - Learn more about Actix integration</li> <li>Configuration Reference - All configuration options</li> </ul>"},{"location":"rust/getting-started/server-quickstart/#complete-examples","title":"Complete Examples","text":"<p>See full working examples: - Rocket Server Example - Actix Web Server Example</p>"},{"location":"rust/libraries/client/","title":"Client Library","text":"<p>The <code>openlibx402-client</code> crate provides HTTP clients for consuming X402-protected APIs with automatic or explicit payment handling.</p>"},{"location":"rust/libraries/client/#installation","title":"Installation","text":"<pre><code>[dependencies]\nopenlibx402-client = \"0.1\"\nopenlibx402-core = \"0.1\"\ntokio = { version = \"1.35\", features = [\"full\"] }\nsolana-sdk = \"2.0\"\n</code></pre>"},{"location":"rust/libraries/client/#overview","title":"Overview","text":"<p>The client library provides two client types:</p> <ul> <li>X402AutoClient - Automatically detects and handles 402 responses</li> <li>X402Client - Explicit control over payment flow</li> </ul> <p>Both clients support: - GET and POST requests - Automatic payment creation - Configurable retry logic - Payment verification - Custom RPC endpoints</p>"},{"location":"rust/libraries/client/#x402autoclient","title":"X402AutoClient","text":"<p>The auto client automatically handles the complete payment flow.</p>"},{"location":"rust/libraries/client/#creating-an-auto-client","title":"Creating an Auto Client","text":"<pre><code>use openlibx402_client::{X402AutoClient, AutoClientOptions};\nuse solana_sdk::signature::Keypair;\n\n// With default options\nlet keypair = Keypair::new();\nlet client = X402AutoClient::new(keypair, None, None);\n\n// With custom options\nlet options = AutoClientOptions {\n    max_payment_amount: \"5.0\".to_string(),\n    auto_retry: true,\n    max_retries: 3,\n};\n\nlet client = X402AutoClient::new(\n    keypair,\n    Some(\"https://your-rpc.com\"),\n    Some(options)\n);\n</code></pre>"},{"location":"rust/libraries/client/#autoclientoptions","title":"AutoClientOptions","text":"<pre><code>pub struct AutoClientOptions {\n    /// Maximum amount willing to pay automatically (in USDC)\n    pub max_payment_amount: String,\n\n    /// Whether to automatically retry after payment\n    pub auto_retry: bool,\n\n    /// Maximum number of retry attempts\n    pub max_retries: u32,\n}\n</code></pre> <p>Default values: - <code>max_payment_amount</code>: \"10.0\" - <code>auto_retry</code>: true - <code>max_retries</code>: 3</p>"},{"location":"rust/libraries/client/#making-requests","title":"Making Requests","text":""},{"location":"rust/libraries/client/#get-request","title":"GET Request","text":"<pre><code>use openlibx402_client::X402AutoClient;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let client = X402AutoClient::new(keypair, None, None);\n\n    // Automatically handles 402 and payment\n    let response = client.get(\"https://api.example.com/premium-data\").await?;\n    let body = response.text().await?;\n\n    println!(\"Data: {}\", body);\n    Ok(())\n}\n</code></pre>"},{"location":"rust/libraries/client/#post-request","title":"POST Request","text":"<pre><code>let body = serde_json::json!({\n    \"query\": \"premium data\"\n});\n\nlet response = client.post(\n    \"https://api.example.com/query\",\n    Some(body.to_string())\n).await?;\n\nlet data = response.text().await?;\n</code></pre>"},{"location":"rust/libraries/client/#automatic-flow","title":"Automatic Flow","text":"<p>When you make a request, the auto client:</p> <ol> <li>Makes initial HTTP request</li> <li>If 402 received:</li> <li>Parses payment request</li> <li>Checks amount against <code>max_payment_amount</code></li> <li>Creates and broadcasts payment</li> <li>Retries request with payment authorization</li> <li>Returns successful response or error</li> </ol>"},{"location":"rust/libraries/client/#access-to-underlying-client","title":"Access to Underlying Client","text":"<pre><code>// Get the explicit client for manual operations\nlet explicit_client = auto_client.client();\n\n// Get current options\nlet options = auto_client.options();\nprintln!(\"Max payment: {}\", options.max_payment_amount);\n</code></pre>"},{"location":"rust/libraries/client/#x402client","title":"X402Client","text":"<p>The explicit client gives you full control over the payment flow.</p>"},{"location":"rust/libraries/client/#creating-an-explicit-client","title":"Creating an Explicit Client","text":"<pre><code>use openlibx402_client::X402Client;\nuse solana_sdk::signature::Keypair;\n\nlet keypair = Keypair::new();\n\n// With default RPC\nlet client = X402Client::new(keypair, None);\n\n// With custom RPC\nlet client = X402Client::new(\n    keypair,\n    Some(\"https://your-rpc.com\")\n);\n</code></pre>"},{"location":"rust/libraries/client/#making-requests_1","title":"Making Requests","text":""},{"location":"rust/libraries/client/#get-request_1","title":"GET Request","text":"<pre><code>#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let client = X402Client::new(keypair, None);\n\n    // Make initial request\n    let response = client.get(\"https://api.example.com/premium-data\").await?;\n\n    // Check if payment required\n    if client.is_payment_required(&amp;response) {\n        // Parse payment request\n        let payment_request = client.parse_payment_request(response).await?;\n\n        println!(\"Amount: {} USDC\", payment_request.max_amount_required);\n\n        // Create payment\n        let authorization = client.create_payment(&amp;payment_request).await?;\n\n        // Retry with payment\n        let response = client.get_with_auth(\n            \"https://api.example.com/premium-data\",\n            &amp;authorization\n        ).await?;\n\n        let body = response.text().await?;\n        println!(\"Data: {}\", body);\n    } else {\n        let body = response.text().await?;\n        println!(\"Data: {}\", body);\n    }\n\n    Ok(())\n}\n</code></pre>"},{"location":"rust/libraries/client/#post-request_1","title":"POST Request","text":"<pre><code>let body = serde_json::json!({\"query\": \"data\"});\n\n// Initial request\nlet response = client.post(\n    \"https://api.example.com/query\",\n    Some(body.to_string())\n).await?;\n\nif client.is_payment_required(&amp;response) {\n    let payment_request = client.parse_payment_request(response).await?;\n    let authorization = client.create_payment(&amp;payment_request).await?;\n\n    // Retry with payment\n    let response = client.post_with_auth(\n        \"https://api.example.com/query\",\n        Some(body.to_string()),\n        &amp;authorization\n    ).await?;\n}\n</code></pre>"},{"location":"rust/libraries/client/#client-methods","title":"Client Methods","text":"<pre><code>// Check if response is 402\nlet is_402 = client.is_payment_required(&amp;response);\n\n// Parse payment request from 402 response\nlet payment_request = client.parse_payment_request(response).await?;\n\n// Create and broadcast payment\nlet authorization = client.create_payment(&amp;payment_request).await?;\n\n// Verify payment (optional)\nlet verified = client.verify_payment(&amp;authorization, \"0.10\").await?;\n\n// Make requests with payment authorization\nlet response = client.get_with_auth(url, &amp;authorization).await?;\nlet response = client.post_with_auth(url, body, &amp;authorization).await?;\n</code></pre>"},{"location":"rust/libraries/client/#error-handling","title":"Error Handling","text":"<p>Both clients return <code>X402Result&lt;T&gt;</code> or standard <code>Result</code> types.</p>"},{"location":"rust/libraries/client/#handling-x402-errors","title":"Handling X402 Errors","text":"<pre><code>use openlibx402_core::X402Error;\n\nmatch client.get(url).await {\n    Ok(response) =&gt; {\n        // Handle response\n    }\n    Err(X402Error::PaymentRequired(msg)) =&gt; {\n        eprintln!(\"Payment required: {}\", msg);\n    }\n    Err(X402Error::InsufficientFunds(msg)) =&gt; {\n        eprintln!(\"Insufficient funds: {}\", msg);\n    }\n    Err(X402Error::PaymentExpired(msg)) =&gt; {\n        eprintln!(\"Payment expired: {}\", msg);\n    }\n    Err(X402Error::TransactionBroadcast(msg)) =&gt; {\n        eprintln!(\"Transaction failed: {}\", msg);\n    }\n    Err(X402Error::Network(msg)) =&gt; {\n        eprintln!(\"Network error: {}\", msg);\n    }\n    Err(e) =&gt; {\n        eprintln!(\"Error: {}\", e);\n    }\n}\n</code></pre>"},{"location":"rust/libraries/client/#handling-http-errors","title":"Handling HTTP Errors","text":"<pre><code>let response = client.get(url).await?;\n\nif !response.status().is_success() {\n    eprintln!(\"HTTP error: {}\", response.status());\n}\n</code></pre>"},{"location":"rust/libraries/client/#advanced-usage","title":"Advanced Usage","text":""},{"location":"rust/libraries/client/#custom-request-handling","title":"Custom Request Handling","text":"<pre><code>impl X402Client {\n    // Make custom HTTP requests\n    async fn request(\n        &amp;self,\n        method: &amp;str,\n        url: &amp;str,\n        body: Option&lt;String&gt;,\n        authorization: Option&lt;&amp;PaymentAuthorization&gt;,\n    ) -&gt; X402Result&lt;Response&gt;\n}\n</code></pre>"},{"location":"rust/libraries/client/#payment-verification","title":"Payment Verification","text":"<pre><code>// Verify payment was successful\nlet authorization = client.create_payment(&amp;payment_request).await?;\n\nlet verified = client.verify_payment(\n    &amp;authorization,\n    &amp;payment_request.max_amount_required\n).await?;\n\nif verified {\n    println!(\"Payment verified on-chain\");\n}\n</code></pre>"},{"location":"rust/libraries/client/#checking-payment-requirements","title":"Checking Payment Requirements","text":"<pre><code>use reqwest::StatusCode;\n\nlet response = client.get(url).await?;\n\nmatch response.status() {\n    StatusCode::OK =&gt; {\n        // No payment required\n        let data = response.text().await?;\n    }\n    StatusCode::PAYMENT_REQUIRED =&gt; {\n        // Payment required\n        let payment_request = PaymentRequest::from_json(\n            &amp;response.text().await?\n        )?;\n    }\n    status =&gt; {\n        // Other HTTP error\n        eprintln!(\"HTTP {}\", status);\n    }\n}\n</code></pre>"},{"location":"rust/libraries/client/#best-practices","title":"Best Practices","text":""},{"location":"rust/libraries/client/#1-use-auto-client-for-simple-cases","title":"1. Use Auto Client for Simple Cases","text":"<pre><code>// Recommended for most use cases\nlet client = X402AutoClient::new(keypair, None, None);\nlet response = client.get(url).await?;\n</code></pre>"},{"location":"rust/libraries/client/#2-set-payment-limits","title":"2. Set Payment Limits","text":"<pre><code>let options = AutoClientOptions {\n    max_payment_amount: \"5.0\".to_string(),  // Prevent overpaying\n    auto_retry: true,\n    max_retries: 3,\n};\n</code></pre>"},{"location":"rust/libraries/client/#3-handle-expired-payments","title":"3. Handle Expired Payments","text":"<pre><code>loop {\n    match client.get(url).await {\n        Ok(response) =&gt; break response,\n        Err(X402Error::PaymentExpired(_)) =&gt; {\n            // Payment expired, retry automatically\n            continue;\n        }\n        Err(e) =&gt; return Err(e),\n    }\n}\n</code></pre>"},{"location":"rust/libraries/client/#4-reuse-clients","title":"4. Reuse Clients","text":"<pre><code>// Create once, reuse for multiple requests\nlet client = X402AutoClient::new(keypair, None, None);\n\nfor url in urls {\n    let response = client.get(&amp;url).await?;\n    // Process response\n}\n</code></pre>"},{"location":"rust/libraries/client/#5-custom-rpc-for-performance","title":"5. Custom RPC for Performance","text":"<pre><code>// Use dedicated RPC endpoint for better performance\nlet client = X402AutoClient::new(\n    keypair,\n    Some(\"https://your-fast-rpc.com\"),\n    None\n);\n</code></pre>"},{"location":"rust/libraries/client/#complete-examples","title":"Complete Examples","text":""},{"location":"rust/libraries/client/#auto-client-with-error-handling","title":"Auto Client with Error Handling","text":"<pre><code>use openlibx402_client::{X402AutoClient, AutoClientOptions};\nuse openlibx402_core::X402Error;\nuse solana_sdk::signature::Keypair;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let keypair = Keypair::new();\n\n    let options = AutoClientOptions {\n        max_payment_amount: \"5.0\".to_string(),\n        auto_retry: true,\n        max_retries: 3,\n    };\n\n    let client = X402AutoClient::new(keypair, None, Some(options));\n\n    let urls = vec![\n        \"http://localhost:8000/basic\",\n        \"http://localhost:8000/premium\",\n        \"http://localhost:8000/enterprise\",\n    ];\n\n    for url in urls {\n        match client.get(url).await {\n            Ok(response) =&gt; {\n                let body = response.text().await?;\n                println!(\"\u2713 {}: {}\", url, body);\n            }\n            Err(X402Error::InsufficientFunds(msg)) =&gt; {\n                eprintln!(\"\u2717 {}: Insufficient funds - {}\", url, msg);\n            }\n            Err(X402Error::PaymentRequired(msg)) =&gt; {\n                eprintln!(\"\u2717 {}: Payment required exceeds limit - {}\", url, msg);\n            }\n            Err(e) =&gt; {\n                eprintln!(\"\u2717 {}: {}\", url, e);\n            }\n        }\n    }\n\n    Ok(())\n}\n</code></pre>"},{"location":"rust/libraries/client/#explicit-client-with-full-control","title":"Explicit Client with Full Control","text":"<pre><code>use openlibx402_client::X402Client;\nuse solana_sdk::signature::read_keypair_file;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let keypair = read_keypair_file(\"~/.config/solana/id.json\")?;\n    let client = X402Client::new(keypair, None);\n\n    let url = \"http://localhost:8000/premium\";\n\n    // Make request\n    let response = client.get(url).await?;\n\n    // Handle 402\n    if client.is_payment_required(&amp;response) {\n        let payment_request = client.parse_payment_request(response).await?;\n\n        // Show payment details to user\n        println!(\"Payment required:\");\n        println!(\"  Amount: {} USDC\", payment_request.max_amount_required);\n        println!(\"  Description: {:?}\", payment_request.description);\n        println!(\"  Expires: {}\", payment_request.expires_at);\n\n        // Confirm with user (in real app)\n        println!(\"Proceeding with payment...\");\n\n        // Create payment\n        let authorization = client.create_payment(&amp;payment_request).await?;\n        println!(\"Payment sent: {}\", authorization.signature);\n\n        // Retry request\n        let response = client.get_with_auth(url, &amp;authorization).await?;\n        let body = response.text().await?;\n        println!(\"Received: {}\", body);\n    } else {\n        let body = response.text().await?;\n        println!(\"Received: {}\", body);\n    }\n\n    Ok(())\n}\n</code></pre>"},{"location":"rust/libraries/client/#see-also","title":"See Also","text":"<ul> <li>Core Library - Payment models and processor</li> <li>Client Quick Start - Quick start guide</li> <li>Error Reference - Error handling details</li> </ul>"},{"location":"rust/libraries/core/","title":"Core Library","text":"<p>The <code>openlibx402-core</code> crate provides the fundamental types, error handling, and Solana payment processing for the X402 protocol.</p>"},{"location":"rust/libraries/core/#installation","title":"Installation","text":"<pre><code>[dependencies]\nopenlibx402-core = \"0.1\"\n</code></pre>"},{"location":"rust/libraries/core/#overview","title":"Overview","text":"<p>The core library includes:</p> <ul> <li>Payment Models - <code>PaymentRequest</code> and <code>PaymentAuthorization</code></li> <li>Error Types - Comprehensive error handling with <code>X402Error</code></li> <li>Payment Processor - <code>SolanaPaymentProcessor</code> for blockchain operations</li> <li>Utilities - Serialization, base64 encoding, expiration checking</li> </ul>"},{"location":"rust/libraries/core/#payment-models","title":"Payment Models","text":""},{"location":"rust/libraries/core/#paymentrequest","title":"PaymentRequest","text":"<p>Represents a payment requirement from a server.</p> <pre><code>use openlibx402_core::PaymentRequest;\nuse chrono::{Utc, Duration};\n\nlet payment_request = PaymentRequest::new(\n    \"0.10\".to_string(),                                              // amount\n    \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\".to_string(),   // token mint\n    \"7xKXtg2CW87d97TXJSDpbD5jBkheTqA83TZRuJosgAsU\".to_string(),   // payment address\n    \"solana-devnet\".to_string(),                                    // network\n    Utc::now() + Duration::seconds(300),                            // expires_at\n    \"nonce123\".to_string(),                                         // nonce\n    \"payment123\".to_string(),                                       // payment_id\n    \"/api/premium-data\".to_string(),                                // resource\n).with_description(\"Access to premium data\".to_string());\n</code></pre>"},{"location":"rust/libraries/core/#fields","title":"Fields","text":"<ul> <li><code>max_amount_required</code> - Amount in USDC (e.g., \"0.10\")</li> <li><code>asset_type</code> - Asset type (\"SPL\" for Solana tokens)</li> <li><code>asset_address</code> - Token mint address (USDC address)</li> <li><code>payment_address</code> - Recipient wallet address</li> <li><code>network</code> - Network identifier (\"solana-devnet\", \"solana-mainnet\")</li> <li><code>expires_at</code> - Expiration timestamp (ISO 8601)</li> <li><code>nonce</code> - Unique nonce for replay protection</li> <li><code>payment_id</code> - Unique payment identifier</li> <li><code>resource</code> - API endpoint being accessed</li> <li><code>description</code> - Optional human-readable description</li> </ul>"},{"location":"rust/libraries/core/#methods","title":"Methods","text":"<pre><code>// Check if expired\nif payment_request.is_expired() {\n    println!(\"Payment request expired\");\n}\n\n// Serialize to JSON\nlet json = payment_request.to_json()?;\n\n// Deserialize from JSON\nlet request = PaymentRequest::from_json(&amp;json)?;\n\n// Encode as base64\nlet encoded = payment_request.to_base64()?;\n\n// Decode from base64\nlet request = PaymentRequest::from_base64(&amp;encoded)?;\n</code></pre>"},{"location":"rust/libraries/core/#paymentauthorization","title":"PaymentAuthorization","text":"<p>Represents proof of payment sent with retry requests.</p> <pre><code>use openlibx402_core::PaymentAuthorization;\n\nlet authorization = PaymentAuthorization::new(\n    \"payment123\".to_string(),                                       // payment_id\n    \"0.10\".to_string(),                                             // actual_amount\n    \"7xKXtg2CW87d97TXJSDpbD5jBkheTqA83TZRuJosgAsU\".to_string(),   // payment_address\n    \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\".to_string(),   // asset_address\n    \"solana-devnet\".to_string(),                                    // network\n    \"5VERv8NMv...\".to_string(),                                     // signature\n    \"7xKXtg2CW8...\".to_string(),                                    // public_key\n);\n</code></pre>"},{"location":"rust/libraries/core/#fields_1","title":"Fields","text":"<ul> <li><code>payment_id</code> - Links to the original payment request</li> <li><code>actual_amount</code> - Amount paid in USDC</li> <li><code>payment_address</code> - Recipient wallet address</li> <li><code>asset_address</code> - Token mint address</li> <li><code>network</code> - Network identifier</li> <li><code>timestamp</code> - When payment was authorized</li> <li><code>signature</code> - Solana transaction signature</li> <li><code>public_key</code> - Payer's public key</li> <li><code>transaction_hash</code> - On-chain transaction hash (optional)</li> </ul>"},{"location":"rust/libraries/core/#methods_1","title":"Methods","text":"<pre><code>// Serialize to JSON\nlet json = authorization.to_json()?;\n\n// Deserialize from JSON\nlet auth = PaymentAuthorization::from_json(&amp;json)?;\n\n// Encode for HTTP header\nlet header_value = authorization.to_header_value()?;\n\n// Decode from HTTP header\nlet auth = PaymentAuthorization::from_header_value(&amp;header_value)?;\n</code></pre>"},{"location":"rust/libraries/core/#error-types","title":"Error Types","text":"<p>The <code>X402Error</code> enum covers all error cases:</p> <pre><code>use openlibx402_core::X402Error;\n\npub enum X402Error {\n    PaymentRequired(String),\n    PaymentExpired(String),\n    InsufficientFunds(String),\n    PaymentVerification(String),\n    TransactionBroadcast(String),\n    InvalidPaymentRequest(String),\n    InvalidPaymentAuthorization(String),\n    Configuration(String),\n    Network(String),\n    Blockchain(String),\n    Serialization(String),\n}\n</code></pre>"},{"location":"rust/libraries/core/#error-codes","title":"Error Codes","text":"<p>Each error has a unique code:</p> <pre><code>let error = X402Error::PaymentRequired(\"Payment needed\".to_string());\nprintln!(\"Code: {}\", error.code());  // \"PAYMENT_REQUIRED\"\nprintln!(\"Message: {}\", error.message());\n</code></pre>"},{"location":"rust/libraries/core/#error-handling","title":"Error Handling","text":"<pre><code>use openlibx402_core::{X402Error, X402Result};\n\nfn process_payment() -&gt; X402Result&lt;String&gt; {\n    // ... operation that might fail\n\n    match result {\n        Ok(data) =&gt; Ok(data),\n        Err(X402Error::PaymentExpired(msg)) =&gt; {\n            eprintln!(\"Payment expired: {}\", msg);\n            Err(X402Error::PaymentExpired(msg))\n        }\n        Err(X402Error::InsufficientFunds(msg)) =&gt; {\n            eprintln!(\"Insufficient funds: {}\", msg);\n            Err(X402Error::InsufficientFunds(msg))\n        }\n        Err(e) =&gt; Err(e),\n    }\n}\n</code></pre>"},{"location":"rust/libraries/core/#automatic-conversions","title":"Automatic Conversions","text":"<p>The library provides automatic error conversions:</p> <pre><code>// Automatic conversion from serde_json::Error\nlet json_result: Result&lt;PaymentRequest, _&gt; = serde_json::from_str(data);\nlet x402_result: X402Result&lt;PaymentRequest&gt; = json_result.map_err(Into::into);\n\n// Automatic conversion from Solana errors\nlet solana_result = rpc_client.get_latest_blockhash();\nlet x402_result: X402Result&lt;_&gt; = solana_result.map_err(Into::into);\n</code></pre>"},{"location":"rust/libraries/core/#solana-payment-processor","title":"Solana Payment Processor","text":"<p>The <code>SolanaPaymentProcessor</code> handles blockchain operations.</p>"},{"location":"rust/libraries/core/#creating-a-processor","title":"Creating a Processor","text":"<pre><code>use openlibx402_core::SolanaPaymentProcessor;\n\n// Use default RPC URL\nlet processor = SolanaPaymentProcessor::new(\n    \"https://api.devnet.solana.com\",\n    None  // Use default commitment\n);\n\n// Use custom RPC and commitment\nuse solana_sdk::commitment_config::CommitmentConfig;\n\nlet processor = SolanaPaymentProcessor::new(\n    \"https://your-rpc.com\",\n    Some(CommitmentConfig::confirmed())\n);\n</code></pre>"},{"location":"rust/libraries/core/#creating-payments","title":"Creating Payments","text":"<pre><code>use solana_sdk::signature::Keypair;\n\nlet keypair = Keypair::new();\nlet payment_request = /* ... */;\n\n// Create and broadcast payment\nlet authorization = processor.create_payment(\n    &amp;payment_request,\n    &amp;keypair\n).await?;\n\nprintln!(\"Payment sent! Signature: {}\", authorization.signature);\n</code></pre> <p>The processor automatically: - Checks if payment expired - Validates addresses - Checks sender balance - Creates recipient ATA if needed - Builds and signs transaction - Broadcasts to Solana - Returns payment authorization</p>"},{"location":"rust/libraries/core/#verifying-payments","title":"Verifying Payments","text":"<pre><code>// Verify payment on-chain\nlet verified = processor.verify_payment(\n    &amp;authorization,\n    \"0.10\"  // expected amount\n).await?;\n\nif verified {\n    println!(\"Payment verified!\");\n}\n</code></pre>"},{"location":"rust/libraries/core/#checking-balances","title":"Checking Balances","text":"<pre><code>use solana_sdk::pubkey::Pubkey;\nuse std::str::FromStr;\n\nlet token_account = Pubkey::from_str(\"...\")?;\nlet balance = processor.get_token_balance(&amp;token_account).await?;\n\nprintln!(\"Balance: {} lamports\", balance);\n</code></pre>"},{"location":"rust/libraries/core/#default-rpc-urls","title":"Default RPC URLs","text":"<pre><code>// Get default RPC for network\nlet url = SolanaPaymentProcessor::default_rpc_url(\"solana-devnet\");\n// Returns: \"https://api.devnet.solana.com\"\n\nlet url = SolanaPaymentProcessor::default_rpc_url(\"solana-mainnet\");\n// Returns: \"https://api.mainnet-beta.solana.com\"\n</code></pre>"},{"location":"rust/libraries/core/#constants","title":"Constants","text":""},{"location":"rust/libraries/core/#library-version","title":"Library Version","text":"<pre><code>use openlibx402_core::VERSION;\n\nprintln!(\"openlibx402-core version: {}\", VERSION);\n</code></pre>"},{"location":"rust/libraries/core/#type-aliases","title":"Type Aliases","text":"<pre><code>// Result type for X402 operations\npub type X402Result&lt;T&gt; = Result&lt;T, X402Error&gt;;\n</code></pre>"},{"location":"rust/libraries/core/#features","title":"Features","text":"<p>The core library supports:</p> <ul> <li>Async-first - All I/O operations are async</li> <li>Type-safe - Compile-time guarantees</li> <li>Zero-copy - Efficient serialization where possible</li> <li>Comprehensive errors - Detailed error messages</li> <li>Automatic conversions - From common error types</li> <li>Solana integration - Full Solana SDK support</li> </ul>"},{"location":"rust/libraries/core/#examples","title":"Examples","text":""},{"location":"rust/libraries/core/#complete-payment-flow","title":"Complete Payment Flow","text":"<pre><code>use openlibx402_core::{\n    PaymentRequest, SolanaPaymentProcessor, X402Result\n};\nuse solana_sdk::signature::Keypair;\n\n#[tokio::main]\nasync fn main() -&gt; X402Result&lt;()&gt; {\n    // Parse payment request from server\n    let payment_request = PaymentRequest::from_json(r#\"\n        {\n            \"max_amount_required\": \"0.10\",\n            \"asset_type\": \"SPL\",\n            \"asset_address\": \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\",\n            \"payment_address\": \"7xKXtg2CW87d97TXJSDpbD5jBkheTqA83TZRuJosgAsU\",\n            \"network\": \"solana-devnet\",\n            \"expires_at\": \"2025-10-31T12:00:00Z\",\n            \"nonce\": \"abc123\",\n            \"payment_id\": \"pay_123\",\n            \"resource\": \"/api/premium-data\"\n        }\n    \"#)?;\n\n    // Create payment processor\n    let processor = SolanaPaymentProcessor::new(\n        \"https://api.devnet.solana.com\",\n        None\n    );\n\n    // Load keypair\n    let keypair = Keypair::new();  // Use your actual keypair\n\n    // Create and send payment\n    let authorization = processor.create_payment(\n        &amp;payment_request,\n        &amp;keypair\n    ).await?;\n\n    // Encode for HTTP header\n    let header_value = authorization.to_header_value()?;\n    println!(\"X-Payment-Authorization: {}\", header_value);\n\n    Ok(())\n}\n</code></pre>"},{"location":"rust/libraries/core/#see-also","title":"See Also","text":"<ul> <li>Client Library - HTTP client built on core</li> <li>Error Reference - Detailed error documentation</li> <li>API Reference - Complete API documentation</li> </ul>"},{"location":"rust/middleware/actix/","title":"Actix Web Middleware","text":"<p>The <code>openlibx402-actix</code> crate provides integration with the Actix Web framework for protecting endpoints with X402 payment requirements.</p>"},{"location":"rust/middleware/actix/#installation","title":"Installation","text":"<pre><code>[dependencies]\nopenlibx402-core = \"0.1\"\nopenlibx402-actix = \"0.1\"\nactix-web = \"4.4\"\nactix-rt = \"2.9\"\n</code></pre>"},{"location":"rust/middleware/actix/#overview","title":"Overview","text":"<p>Actix Web integration provides: - <code>PaymentExtractor</code> - Extractor for payment enforcement - <code>X402Config</code> and <code>X402State</code> - Server configuration - <code>PaymentRequirement</code> - Payment configuration per endpoint - Helper functions for creating payment requests and responses</p>"},{"location":"rust/middleware/actix/#quick-start","title":"Quick Start","text":"<pre><code>use actix_web::{get, web, App, HttpResponse, HttpServer};\nuse openlibx402_actix::{\n    create_payment_request, payment_required_response,\n    PaymentExtractor, PaymentRequirement, X402Config, X402State,\n};\nuse serde::Serialize;\n\n#[derive(Serialize)]\nstruct Data {\n    message: String,\n}\n\n#[get(\"/premium\")]\nasync fn premium(\n    state: web::Data&lt;X402State&gt;,\n    auth: Option&lt;PaymentExtractor&gt;,\n) -&gt; HttpResponse {\n    match auth {\n        Some(_) =&gt; HttpResponse::Ok().json(Data {\n            message: \"Premium content\".to_string(),\n        }),\n        None =&gt; {\n            let requirement = PaymentRequirement::new(\"0.10\");\n            let payment_request = create_payment_request(&amp;state.config, &amp;requirement, \"/premium\");\n            payment_required_response(payment_request)\n        }\n    }\n}\n\n#[actix_web::main]\nasync fn main() -&gt; std::io::Result&lt;()&gt; {\n    let config = X402Config {\n        payment_address: \"YOUR_WALLET\".to_string(),\n        token_mint: \"USDC_MINT\".to_string(),\n        network: \"solana-devnet\".to_string(),\n        rpc_url: None,\n        auto_verify: true,\n    };\n\n    let state = web::Data::new(X402State { config });\n\n    HttpServer::new(move || {\n        App::new()\n            .app_data(state.clone())\n            .service(premium)\n    })\n    .bind((\"127.0.0.1\", 8080))?\n    .run()\n    .await\n}\n</code></pre>"},{"location":"rust/middleware/actix/#x402config","title":"X402Config","text":"<p>Global configuration for X402 payments.</p> <pre><code>pub struct X402Config {\n    /// Wallet address to receive payments\n    pub payment_address: String,\n\n    /// SPL token mint address (USDC)\n    pub token_mint: String,\n\n    /// Solana network\n    pub network: String,\n\n    /// Optional custom RPC URL\n    pub rpc_url: Option&lt;String&gt;,\n\n    /// Whether to verify payments on-chain\n    pub auto_verify: bool,\n}\n</code></pre>"},{"location":"rust/middleware/actix/#x402state","title":"X402State","text":"<p>Application state containing configuration.</p> <pre><code>pub struct X402State {\n    pub config: X402Config,\n}\n</code></pre>"},{"location":"rust/middleware/actix/#setup","title":"Setup","text":"<pre><code>let config = X402Config {\n    payment_address: \"7xKXtg2CW87d97TXJSDpbD5jBkheTqA83TZRuJosgAsU\".to_string(),\n    token_mint: \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\".to_string(),\n    network: \"solana-devnet\".to_string(),\n    rpc_url: None,\n    auto_verify: true,\n};\n\nlet state = web::Data::new(X402State { config });\n\nHttpServer::new(move || {\n    App::new()\n        .app_data(state.clone())\n        // ...\n})\n</code></pre>"},{"location":"rust/middleware/actix/#paymentextractor","title":"PaymentExtractor","text":"<p>Extractor that enforces payment requirements.</p>"},{"location":"rust/middleware/actix/#usage","title":"Usage","text":"<pre><code>#[get(\"/protected\")]\nasync fn protected(auth: PaymentExtractor) -&gt; HttpResponse {\n    HttpResponse::Ok().json(serde_json::json!({\n        \"payment_id\": auth.authorization.payment_id\n    }))\n}\n</code></pre>"},{"location":"rust/middleware/actix/#optional-extractor","title":"Optional Extractor","text":"<p>Use <code>Option&lt;PaymentExtractor&gt;</code> to manually handle 402 responses:</p> <pre><code>#[get(\"/protected\")]\nasync fn protected(\n    state: web::Data&lt;X402State&gt;,\n    auth: Option&lt;PaymentExtractor&gt;,\n) -&gt; HttpResponse {\n    match auth {\n        Some(auth) =&gt; {\n            // Payment verified\n            HttpResponse::Ok().json(serde_json::json!({\n                \"data\": \"premium content\"\n            }))\n        }\n        None =&gt; {\n            // Return 402 with payment request\n            let requirement = PaymentRequirement::new(\"0.10\");\n            let payment_request = create_payment_request(&amp;state.config, &amp;requirement, \"/protected\");\n            payment_required_response(payment_request)\n        }\n    }\n}\n</code></pre>"},{"location":"rust/middleware/actix/#paymentrequirement","title":"PaymentRequirement","text":"<p>Configuration for payment requirements.</p> <pre><code>pub struct PaymentRequirement {\n    /// Amount required in USDC\n    pub amount: String,\n\n    /// Optional description\n    pub description: Option&lt;String&gt;,\n\n    /// Expiration time in seconds (default: 300)\n    pub expires_in: i64,\n}\n</code></pre>"},{"location":"rust/middleware/actix/#creating-requirements","title":"Creating Requirements","text":"<pre><code>// Simple requirement\nlet requirement = PaymentRequirement::new(\"0.10\");\n\n// With description\nlet requirement = PaymentRequirement::new(\"0.10\")\n    .with_description(\"Access to premium data\");\n\n// With custom expiration\nlet requirement = PaymentRequirement::new(\"0.10\")\n    .with_description(\"Premium API access\")\n    .with_expires_in(600);  // 10 minutes\n</code></pre>"},{"location":"rust/middleware/actix/#helper-functions","title":"Helper Functions","text":""},{"location":"rust/middleware/actix/#create_payment_request","title":"create_payment_request","text":"<p>Creates a payment request for an endpoint:</p> <pre><code>pub fn create_payment_request(\n    config: &amp;X402Config,\n    requirement: &amp;PaymentRequirement,\n    resource: &amp;str,\n) -&gt; PaymentRequest\n</code></pre>"},{"location":"rust/middleware/actix/#payment_required_response","title":"payment_required_response","text":"<p>Creates a 402 HTTP response with payment request:</p> <pre><code>pub fn payment_required_response(\n    payment_request: PaymentRequest\n) -&gt; HttpResponse\n</code></pre> <p>Example:</p> <pre><code>let requirement = PaymentRequirement::new(\"0.10\");\nlet payment_request = create_payment_request(&amp;config, &amp;requirement, \"/api/data\");\nlet response = payment_required_response(payment_request);\n</code></pre>"},{"location":"rust/middleware/actix/#paymenterror","title":"PaymentError","text":"<p>Error type for payment operations:</p> <pre><code>pub enum PaymentError {\n    Required,\n    InvalidHeader,\n    InvalidAuthorization(String),\n}\n</code></pre> <p>Automatically converts to appropriate HTTP responses: - <code>Required</code> \u2192 402 Payment Required - <code>InvalidHeader</code> \u2192 400 Bad Request - <code>InvalidAuthorization</code> \u2192 400 Bad Request</p>"},{"location":"rust/middleware/actix/#complete-examples","title":"Complete Examples","text":""},{"location":"rust/middleware/actix/#multiple-pricing-tiers","title":"Multiple Pricing Tiers","text":"<pre><code>use actix_web::{get, web, App, HttpResponse, HttpServer};\nuse openlibx402_actix::*;\nuse serde::Serialize;\n\n#[derive(Serialize)]\nstruct TierData {\n    tier: String,\n    data: Vec&lt;String&gt;,\n}\n\n#[get(\"/basic\")]\nasync fn basic(\n    state: web::Data&lt;X402State&gt;,\n    auth: Option&lt;PaymentExtractor&gt;,\n) -&gt; HttpResponse {\n    match auth {\n        Some(_) =&gt; HttpResponse::Ok().json(TierData {\n            tier: \"basic\".to_string(),\n            data: vec![\"Basic data\".to_string()],\n        }),\n        None =&gt; {\n            let req = PaymentRequirement::new(\"0.01\")\n                .with_description(\"Basic tier access\");\n            payment_required_response(create_payment_request(&amp;state.config, &amp;req, \"/basic\"))\n        }\n    }\n}\n\n#[get(\"/premium\")]\nasync fn premium(\n    state: web::Data&lt;X402State&gt;,\n    auth: Option&lt;PaymentExtractor&gt;,\n) -&gt; HttpResponse {\n    match auth {\n        Some(_) =&gt; HttpResponse::Ok().json(TierData {\n            tier: \"premium\".to_string(),\n            data: vec![\"Premium 1\".to_string(), \"Premium 2\".to_string()],\n        }),\n        None =&gt; {\n            let req = PaymentRequirement::new(\"0.10\")\n                .with_description(\"Premium tier access\")\n                .with_expires_in(600);\n            payment_required_response(create_payment_request(&amp;state.config, &amp;req, \"/premium\"))\n        }\n    }\n}\n\n#[get(\"/enterprise\")]\nasync fn enterprise(\n    state: web::Data&lt;X402State&gt;,\n    auth: Option&lt;PaymentExtractor&gt;,\n) -&gt; HttpResponse {\n    match auth {\n        Some(_) =&gt; HttpResponse::Ok().json(TierData {\n            tier: \"enterprise\".to_string(),\n            data: vec![\"Enterprise 1\".to_string(), \"Enterprise 2\".to_string(), \"Enterprise 3\".to_string()],\n        }),\n        None =&gt; {\n            let req = PaymentRequirement::new(\"1.00\")\n                .with_description(\"Enterprise tier access\");\n            payment_required_response(create_payment_request(&amp;state.config, &amp;req, \"/enterprise\"))\n        }\n    }\n}\n\n#[actix_web::main]\nasync fn main() -&gt; std::io::Result&lt;()&gt; {\n    let config = X402Config {\n        payment_address: \"YOUR_WALLET\".to_string(),\n        token_mint: \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\".to_string(),\n        network: \"solana-devnet\".to_string(),\n        rpc_url: None,\n        auto_verify: true,\n    };\n\n    let state = web::Data::new(X402State { config });\n\n    HttpServer::new(move || {\n        App::new()\n            .app_data(state.clone())\n            .service(basic)\n            .service(premium)\n            .service(enterprise)\n    })\n    .bind((\"127.0.0.1\", 8080))?\n    .run()\n    .await\n}\n</code></pre>"},{"location":"rust/middleware/actix/#accessing-payment-details","title":"Accessing Payment Details","text":"<pre><code>#[get(\"/paid-endpoint\")]\nasync fn paid_endpoint(auth: PaymentExtractor) -&gt; HttpResponse {\n    HttpResponse::Ok().json(serde_json::json!({\n        \"payment_id\": auth.authorization.payment_id,\n        \"amount_paid\": auth.authorization.actual_amount,\n        \"payer\": auth.authorization.public_key,\n        \"transaction\": auth.authorization.signature,\n    }))\n}\n</code></pre>"},{"location":"rust/middleware/actix/#mixed-free-and-paid-endpoints","title":"Mixed Free and Paid Endpoints","text":"<pre><code>#[get(\"/free\")]\nasync fn free_endpoint() -&gt; HttpResponse {\n    HttpResponse::Ok().body(\"This is free content\")\n}\n\n#[get(\"/paid\")]\nasync fn paid_endpoint(\n    state: web::Data&lt;X402State&gt;,\n    auth: Option&lt;PaymentExtractor&gt;,\n) -&gt; HttpResponse {\n    match auth {\n        Some(_) =&gt; HttpResponse::Ok().body(\"This is paid content\"),\n        None =&gt; {\n            let req = PaymentRequirement::new(\"0.10\");\n            payment_required_response(create_payment_request(&amp;state.config, &amp;req, \"/paid\"))\n        }\n    }\n}\n</code></pre>"},{"location":"rust/middleware/actix/#best-practices","title":"Best Practices","text":""},{"location":"rust/middleware/actix/#1-use-app-data-for-configuration","title":"1. Use App Data for Configuration","text":"<pre><code>let state = web::Data::new(X402State { config });\n\nHttpServer::new(move || {\n    App::new()\n        .app_data(state.clone())  // Available in all routes\n        .service(...)\n})\n</code></pre>"},{"location":"rust/middleware/actix/#2-set-reasonable-expirations","title":"2. Set Reasonable Expirations","text":"<pre><code>// Short-lived: 1 minute\nlet req = PaymentRequirement::new(\"0.01\").with_expires_in(60);\n\n// Standard: 5 minutes\nlet req = PaymentRequirement::new(\"0.10\").with_expires_in(300);\n\n// Long-lived: 1 hour\nlet req = PaymentRequirement::new(\"1.00\").with_expires_in(3600);\n</code></pre>"},{"location":"rust/middleware/actix/#3-add-descriptions","title":"3. Add Descriptions","text":"<pre><code>let req = PaymentRequirement::new(\"0.10\")\n    .with_description(\"Access to real-time market data\");\n</code></pre>"},{"location":"rust/middleware/actix/#4-enable-auto-verify-for-production","title":"4. Enable Auto-Verify for Production","text":"<pre><code>let config = X402Config {\n    // ...\n    auto_verify: true,  // Verify payments on-chain\n};\n</code></pre>"},{"location":"rust/middleware/actix/#see-also","title":"See Also","text":"<ul> <li>Actix Web Example - Complete example</li> <li>Server Quick Start - Getting started guide</li> <li>Configuration Reference - All options</li> </ul>"},{"location":"rust/middleware/rocket/","title":"Rocket Middleware","text":"<p>The <code>openlibx402-rocket</code> crate provides integration with the Rocket web framework for protecting endpoints with X402 payment requirements.</p>"},{"location":"rust/middleware/rocket/#installation","title":"Installation","text":"<pre><code>[dependencies]\nopenlibx402-core = \"0.1\"\nopenlibx402-rocket = \"0.1\"\nrocket = { version = \"0.5\", features = [\"json\"] }\n</code></pre>"},{"location":"rust/middleware/rocket/#overview","title":"Overview","text":"<p>Rocket integration provides: - <code>PaymentGuard</code> - Request guard for payment enforcement - <code>X402Config</code> - Server configuration - <code>PaymentRequirement</code> - Payment configuration per endpoint - Helper functions for creating payment requests</p>"},{"location":"rust/middleware/rocket/#quick-start","title":"Quick Start","text":"<pre><code>use openlibx402_rocket::{\n    create_payment_request, PaymentGuard, PaymentRequirement,\n    PaymentRequiredResponse, X402Config,\n};\nuse rocket::{get, routes, serde::json::Json, State};\nuse serde::Serialize;\n\n#[derive(Serialize)]\nstruct Data {\n    message: String,\n}\n\n#[get(\"/premium\")]\nfn premium(\n    config: &amp;State&lt;X402Config&gt;,\n    auth: Option&lt;PaymentGuard&gt;,\n) -&gt; Result&lt;Json&lt;Data&gt;, PaymentRequiredResponse&gt; {\n    match auth {\n        Some(_) =&gt; Ok(Json(Data {\n            message: \"Premium content\".to_string(),\n        })),\n        None =&gt; {\n            let requirement = PaymentRequirement::new(\"0.10\");\n            let payment_request = create_payment_request(config, &amp;requirement, \"/premium\");\n            Err(PaymentRequiredResponse { payment_request })\n        }\n    }\n}\n\n#[rocket::main]\nasync fn main() {\n    let config = X402Config {\n        payment_address: \"YOUR_WALLET\".to_string(),\n        token_mint: \"USDC_MINT\".to_string(),\n        network: \"solana-devnet\".to_string(),\n        rpc_url: None,\n        auto_verify: true,\n    };\n\n    rocket::build()\n        .manage(config)\n        .mount(\"/\", routes![premium])\n        .launch()\n        .await\n        .unwrap();\n}\n</code></pre>"},{"location":"rust/middleware/rocket/#x402config","title":"X402Config","text":"<p>Global configuration for X402 payments.</p> <pre><code>pub struct X402Config {\n    /// Wallet address to receive payments\n    pub payment_address: String,\n\n    /// SPL token mint address (USDC)\n    pub token_mint: String,\n\n    /// Solana network\n    pub network: String,\n\n    /// Optional custom RPC URL\n    pub rpc_url: Option&lt;String&gt;,\n\n    /// Whether to verify payments on-chain\n    pub auto_verify: bool,\n}\n</code></pre>"},{"location":"rust/middleware/rocket/#example-configuration","title":"Example Configuration","text":"<pre><code>let config = X402Config {\n    payment_address: \"7xKXtg2CW87d97TXJSDpbD5jBkheTqA83TZRuJosgAsU\".to_string(),\n    token_mint: \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\".to_string(),\n    network: \"solana-devnet\".to_string(),\n    rpc_url: Some(\"https://your-rpc.com\".to_string()),\n    auto_verify: true,\n};\n</code></pre>"},{"location":"rust/middleware/rocket/#paymentguard","title":"PaymentGuard","text":"<p>Request guard that enforces payment requirements.</p>"},{"location":"rust/middleware/rocket/#usage","title":"Usage","text":"<pre><code>#[get(\"/protected\")]\nfn protected(auth: PaymentGuard) -&gt; String {\n    format!(\"Payment ID: {}\", auth.authorization.payment_id)\n}\n</code></pre>"},{"location":"rust/middleware/rocket/#optional-guard","title":"Optional Guard","text":"<p>Use <code>Option&lt;PaymentGuard&gt;</code> to manually handle 402 responses:</p> <pre><code>#[get(\"/protected\")]\nfn protected(\n    config: &amp;State&lt;X402Config&gt;,\n    auth: Option&lt;PaymentGuard&gt;,\n) -&gt; Result&lt;Json&lt;Data&gt;, PaymentRequiredResponse&gt; {\n    match auth {\n        Some(auth) =&gt; {\n            // Payment verified\n            Ok(Json(Data { /* ... */ }))\n        }\n        None =&gt; {\n            // Return 402 with payment request\n            let requirement = PaymentRequirement::new(\"0.10\");\n            let payment_request = create_payment_request(config, &amp;requirement, \"/protected\");\n            Err(PaymentRequiredResponse { payment_request })\n        }\n    }\n}\n</code></pre>"},{"location":"rust/middleware/rocket/#paymentrequirement","title":"PaymentRequirement","text":"<p>Configuration for payment requirements.</p> <pre><code>pub struct PaymentRequirement {\n    /// Amount required in USDC\n    pub amount: String,\n\n    /// Optional description\n    pub description: Option&lt;String&gt;,\n\n    /// Expiration time in seconds (default: 300)\n    pub expires_in: i64,\n}\n</code></pre>"},{"location":"rust/middleware/rocket/#creating-requirements","title":"Creating Requirements","text":"<pre><code>// Simple requirement\nlet requirement = PaymentRequirement::new(\"0.10\");\n\n// With description\nlet requirement = PaymentRequirement::new(\"0.10\")\n    .with_description(\"Access to premium data\");\n\n// With custom expiration\nlet requirement = PaymentRequirement::new(\"0.10\")\n    .with_description(\"Premium API access\")\n    .with_expires_in(600);  // 10 minutes\n</code></pre>"},{"location":"rust/middleware/rocket/#helper-functions","title":"Helper Functions","text":""},{"location":"rust/middleware/rocket/#create_payment_request","title":"create_payment_request","text":"<p>Creates a payment request for an endpoint:</p> <pre><code>pub fn create_payment_request(\n    config: &amp;X402Config,\n    requirement: &amp;PaymentRequirement,\n    resource: &amp;str,\n) -&gt; PaymentRequest\n</code></pre> <p>Example:</p> <pre><code>let requirement = PaymentRequirement::new(\"0.10\");\nlet payment_request = create_payment_request(\n    config,\n    &amp;requirement,\n    \"/api/premium-data\"\n);\n</code></pre>"},{"location":"rust/middleware/rocket/#paymentrequiredresponse","title":"PaymentRequiredResponse","text":"<p>Response type that returns 402 status with payment request:</p> <pre><code>pub struct PaymentRequiredResponse {\n    pub payment_request: PaymentRequest,\n}\n</code></pre> <p>Automatically sets status to 402 and serializes payment request as JSON.</p>"},{"location":"rust/middleware/rocket/#complete-examples","title":"Complete Examples","text":""},{"location":"rust/middleware/rocket/#multiple-pricing-tiers","title":"Multiple Pricing Tiers","text":"<pre><code>use openlibx402_rocket::*;\nuse rocket::{get, routes, serde::json::Json, State};\nuse serde::Serialize;\n\n#[derive(Serialize)]\nstruct TierData {\n    tier: String,\n    data: Vec&lt;String&gt;,\n}\n\n#[get(\"/basic\")]\nfn basic(\n    config: &amp;State&lt;X402Config&gt;,\n    auth: Option&lt;PaymentGuard&gt;,\n) -&gt; Result&lt;Json&lt;TierData&gt;, PaymentRequiredResponse&gt; {\n    match auth {\n        Some(_) =&gt; Ok(Json(TierData {\n            tier: \"basic\".to_string(),\n            data: vec![\"Basic data\".to_string()],\n        })),\n        None =&gt; {\n            let req = PaymentRequirement::new(\"0.01\")\n                .with_description(\"Basic tier access\");\n            Err(PaymentRequiredResponse {\n                payment_request: create_payment_request(config, &amp;req, \"/basic\")\n            })\n        }\n    }\n}\n\n#[get(\"/premium\")]\nfn premium(\n    config: &amp;State&lt;X402Config&gt;,\n    auth: Option&lt;PaymentGuard&gt;,\n) -&gt; Result&lt;Json&lt;TierData&gt;, PaymentRequiredResponse&gt; {\n    match auth {\n        Some(_) =&gt; Ok(Json(TierData {\n            tier: \"premium\".to_string(),\n            data: vec![\"Premium data 1\".to_string(), \"Premium data 2\".to_string()],\n        })),\n        None =&gt; {\n            let req = PaymentRequirement::new(\"0.10\")\n                .with_description(\"Premium tier access\")\n                .with_expires_in(600);\n            Err(PaymentRequiredResponse {\n                payment_request: create_payment_request(config, &amp;req, \"/premium\")\n            })\n        }\n    }\n}\n\n#[get(\"/enterprise\")]\nfn enterprise(\n    config: &amp;State&lt;X402Config&gt;,\n    auth: Option&lt;PaymentGuard&gt;,\n) -&gt; Result&lt;Json&lt;TierData&gt;, PaymentRequiredResponse&gt; {\n    match auth {\n        Some(_) =&gt; Ok(Json(TierData {\n            tier: \"enterprise\".to_string(),\n            data: vec![\n                \"Enterprise data 1\".to_string(),\n                \"Enterprise data 2\".to_string(),\n                \"Enterprise data 3\".to_string(),\n            ],\n        })),\n        None =&gt; {\n            let req = PaymentRequirement::new(\"1.00\")\n                .with_description(\"Enterprise tier access\");\n            Err(PaymentRequiredResponse {\n                payment_request: create_payment_request(config, &amp;req, \"/enterprise\")\n            })\n        }\n    }\n}\n\n#[rocket::main]\nasync fn main() {\n    let config = X402Config {\n        payment_address: \"YOUR_WALLET\".to_string(),\n        token_mint: \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\".to_string(),\n        network: \"solana-devnet\".to_string(),\n        rpc_url: None,\n        auto_verify: true,\n    };\n\n    rocket::build()\n        .manage(config)\n        .mount(\"/\", routes![basic, premium, enterprise])\n        .launch()\n        .await\n        .unwrap();\n}\n</code></pre>"},{"location":"rust/middleware/rocket/#accessing-payment-details","title":"Accessing Payment Details","text":"<pre><code>#[get(\"/paid-endpoint\")]\nfn paid_endpoint(auth: PaymentGuard) -&gt; Json&lt;serde_json::Value&gt; {\n    Json(serde_json::json!({\n        \"payment_id\": auth.authorization.payment_id,\n        \"amount_paid\": auth.authorization.actual_amount,\n        \"payer\": auth.authorization.public_key,\n        \"transaction\": auth.authorization.signature,\n    }))\n}\n</code></pre>"},{"location":"rust/middleware/rocket/#mixed-free-and-paid-endpoints","title":"Mixed Free and Paid Endpoints","text":"<pre><code>// Free endpoint\n#[get(\"/free\")]\nfn free_endpoint() -&gt; &amp;'static str {\n    \"This is free content\"\n}\n\n// Paid endpoint\n#[get(\"/paid\")]\nfn paid_endpoint(\n    config: &amp;State&lt;X402Config&gt;,\n    auth: Option&lt;PaymentGuard&gt;,\n) -&gt; Result&lt;&amp;'static str, PaymentRequiredResponse&gt; {\n    match auth {\n        Some(_) =&gt; Ok(\"This is paid content\"),\n        None =&gt; {\n            let req = PaymentRequirement::new(\"0.10\");\n            Err(PaymentRequiredResponse {\n                payment_request: create_payment_request(config, &amp;req, \"/paid\")\n            })\n        }\n    }\n}\n</code></pre>"},{"location":"rust/middleware/rocket/#best-practices","title":"Best Practices","text":""},{"location":"rust/middleware/rocket/#1-use-global-config-state","title":"1. Use Global Config State","text":"<pre><code>rocket::build()\n    .manage(config)  // Available in all routes via State&lt;X402Config&gt;\n    .mount(\"/\", routes![...])\n</code></pre>"},{"location":"rust/middleware/rocket/#2-set-reasonable-expirations","title":"2. Set Reasonable Expirations","text":"<pre><code>// Short-lived data\nlet req = PaymentRequirement::new(\"0.01\").with_expires_in(60);  // 1 minute\n\n// Standard\nlet req = PaymentRequirement::new(\"0.10\").with_expires_in(300);  // 5 minutes\n\n// Long-lived\nlet req = PaymentRequirement::new(\"1.00\").with_expires_in(3600);  // 1 hour\n</code></pre>"},{"location":"rust/middleware/rocket/#3-add-descriptions","title":"3. Add Descriptions","text":"<pre><code>let req = PaymentRequirement::new(\"0.10\")\n    .with_description(\"Access to real-time market data\");\n</code></pre>"},{"location":"rust/middleware/rocket/#4-enable-auto-verify-for-production","title":"4. Enable Auto-Verify for Production","text":"<pre><code>let config = X402Config {\n    // ...\n    auto_verify: true,  // Verify payments on-chain\n};\n</code></pre>"},{"location":"rust/middleware/rocket/#see-also","title":"See Also","text":"<ul> <li>Rocket Example - Complete example</li> <li>Server Quick Start - Getting started guide</li> <li>Configuration Reference - All options</li> </ul>"},{"location":"rust/reference/api-reference/","title":"API Reference","text":"<p>Complete API reference for all Rust packages.</p>"},{"location":"rust/reference/api-reference/#openlibx402-core","title":"openlibx402-core","text":""},{"location":"rust/reference/api-reference/#paymentrequest","title":"PaymentRequest","text":"<pre><code>pub struct PaymentRequest {\n    pub max_amount_required: String,\n    pub asset_type: String,\n    pub asset_address: String,\n    pub payment_address: String,\n    pub network: String,\n    pub expires_at: DateTime&lt;Utc&gt;,\n    pub nonce: String,\n    pub payment_id: String,\n    pub resource: String,\n    pub description: Option&lt;String&gt;,\n}\n</code></pre>"},{"location":"rust/reference/api-reference/#methods","title":"Methods","text":"<pre><code>impl PaymentRequest {\n    pub fn new(\n        max_amount_required: String,\n        asset_address: String,\n        payment_address: String,\n        network: String,\n        expires_at: DateTime&lt;Utc&gt;,\n        nonce: String,\n        payment_id: String,\n        resource: String,\n    ) -&gt; Self\n\n    pub fn with_description(self, description: String) -&gt; Self\n    pub fn is_expired(&amp;self) -&gt; bool\n    pub fn from_json(json: &amp;str) -&gt; X402Result&lt;Self&gt;\n    pub fn to_json(&amp;self) -&gt; X402Result&lt;String&gt;\n    pub fn to_base64(&amp;self) -&gt; X402Result&lt;String&gt;\n    pub fn from_base64(encoded: &amp;str) -&gt; X402Result&lt;Self&gt;\n}\n</code></pre>"},{"location":"rust/reference/api-reference/#paymentauthorization","title":"PaymentAuthorization","text":"<pre><code>pub struct PaymentAuthorization {\n    pub payment_id: String,\n    pub actual_amount: String,\n    pub payment_address: String,\n    pub asset_address: String,\n    pub network: String,\n    pub timestamp: DateTime&lt;Utc&gt;,\n    pub signature: String,\n    pub public_key: String,\n    pub transaction_hash: Option&lt;String&gt;,\n}\n</code></pre>"},{"location":"rust/reference/api-reference/#methods_1","title":"Methods","text":"<pre><code>impl PaymentAuthorization {\n    pub fn new(\n        payment_id: String,\n        actual_amount: String,\n        payment_address: String,\n        asset_address: String,\n        network: String,\n        signature: String,\n        public_key: String,\n    ) -&gt; Self\n\n    pub fn from_json(json: &amp;str) -&gt; X402Result&lt;Self&gt;\n    pub fn to_json(&amp;self) -&gt; X402Result&lt;String&gt;\n    pub fn to_header_value(&amp;self) -&gt; X402Result&lt;String&gt;\n    pub fn from_header_value(encoded: &amp;str) -&gt; X402Result&lt;Self&gt;\n}\n</code></pre>"},{"location":"rust/reference/api-reference/#solanapaymentprocessor","title":"SolanaPaymentProcessor","text":"<pre><code>pub struct SolanaPaymentProcessor {\n    // fields are private\n}\n</code></pre>"},{"location":"rust/reference/api-reference/#methods_2","title":"Methods","text":"<pre><code>impl SolanaPaymentProcessor {\n    pub fn new(rpc_url: &amp;str, commitment: Option&lt;CommitmentConfig&gt;) -&gt; Self\n\n    pub fn default_rpc_url(network: &amp;str) -&gt; &amp;'static str\n\n    pub async fn create_payment(\n        &amp;self,\n        request: &amp;PaymentRequest,\n        payer: &amp;Keypair,\n    ) -&gt; X402Result&lt;PaymentAuthorization&gt;\n\n    pub async fn verify_payment(\n        &amp;self,\n        authorization: &amp;PaymentAuthorization,\n        expected_amount: &amp;str,\n    ) -&gt; X402Result&lt;bool&gt;\n\n    pub async fn get_token_balance(&amp;self, token_account: &amp;Pubkey) -&gt; X402Result&lt;u64&gt;\n}\n</code></pre>"},{"location":"rust/reference/api-reference/#x402error","title":"X402Error","text":"<pre><code>pub enum X402Error {\n    PaymentRequired(String),\n    PaymentExpired(String),\n    InsufficientFunds(String),\n    PaymentVerification(String),\n    TransactionBroadcast(String),\n    InvalidPaymentRequest(String),\n    InvalidPaymentAuthorization(String),\n    Configuration(String),\n    Network(String),\n    Blockchain(String),\n    Serialization(String),\n}\n</code></pre>"},{"location":"rust/reference/api-reference/#methods_3","title":"Methods","text":"<pre><code>impl X402Error {\n    pub fn code(&amp;self) -&gt; &amp;'static str\n    pub fn message(&amp;self) -&gt; String\n}\n</code></pre>"},{"location":"rust/reference/api-reference/#type-aliases","title":"Type Aliases","text":"<pre><code>pub type X402Result&lt;T&gt; = Result&lt;T, X402Error&gt;;\n</code></pre>"},{"location":"rust/reference/api-reference/#constants","title":"Constants","text":"<pre><code>pub const VERSION: &amp;str = env!(\"CARGO_PKG_VERSION\");\n</code></pre>"},{"location":"rust/reference/api-reference/#openlibx402-client","title":"openlibx402-client","text":""},{"location":"rust/reference/api-reference/#x402client","title":"X402Client","text":"<pre><code>pub struct X402Client {\n    // fields are private\n}\n</code></pre>"},{"location":"rust/reference/api-reference/#methods_4","title":"Methods","text":"<pre><code>impl X402Client {\n    pub fn new(keypair: Keypair, rpc_url: Option&lt;&amp;str&gt;) -&gt; Self\n\n    pub async fn get(&amp;self, url: &amp;str) -&gt; X402Result&lt;Response&gt;\n\n    pub async fn get_with_auth(\n        &amp;self,\n        url: &amp;str,\n        authorization: &amp;PaymentAuthorization,\n    ) -&gt; X402Result&lt;Response&gt;\n\n    pub async fn post(&amp;self, url: &amp;str, body: Option&lt;String&gt;) -&gt; X402Result&lt;Response&gt;\n\n    pub async fn post_with_auth(\n        &amp;self,\n        url: &amp;str,\n        body: Option&lt;String&gt;,\n        authorization: &amp;PaymentAuthorization,\n    ) -&gt; X402Result&lt;Response&gt;\n\n    pub fn is_payment_required(&amp;self, response: &amp;Response) -&gt; bool\n\n    pub async fn parse_payment_request(&amp;self, response: Response) -&gt; X402Result&lt;PaymentRequest&gt;\n\n    pub async fn create_payment(\n        &amp;self,\n        request: &amp;PaymentRequest,\n    ) -&gt; X402Result&lt;PaymentAuthorization&gt;\n\n    pub async fn verify_payment(\n        &amp;self,\n        authorization: &amp;PaymentAuthorization,\n        expected_amount: &amp;str,\n    ) -&gt; X402Result&lt;bool&gt;\n}\n</code></pre>"},{"location":"rust/reference/api-reference/#x402autoclient","title":"X402AutoClient","text":"<pre><code>pub struct X402AutoClient {\n    // fields are private\n}\n</code></pre>"},{"location":"rust/reference/api-reference/#methods_5","title":"Methods","text":"<pre><code>impl X402AutoClient {\n    pub fn new(\n        keypair: Keypair,\n        rpc_url: Option&lt;&amp;str&gt;,\n        options: Option&lt;AutoClientOptions&gt;,\n    ) -&gt; Self\n\n    pub async fn get(&amp;self, url: &amp;str) -&gt; X402Result&lt;Response&gt;\n\n    pub async fn post(&amp;self, url: &amp;str, body: Option&lt;String&gt;) -&gt; X402Result&lt;Response&gt;\n\n    pub fn client(&amp;self) -&gt; &amp;X402Client\n\n    pub fn options(&amp;self) -&gt; &amp;AutoClientOptions\n}\n</code></pre>"},{"location":"rust/reference/api-reference/#autoclientoptions","title":"AutoClientOptions","text":"<pre><code>#[derive(Debug, Clone)]\npub struct AutoClientOptions {\n    pub max_payment_amount: String,\n    pub auto_retry: bool,\n    pub max_retries: u32,\n}\n</code></pre>"},{"location":"rust/reference/api-reference/#methods_6","title":"Methods","text":"<pre><code>impl Default for AutoClientOptions {\n    fn default() -&gt; Self {\n        Self {\n            max_payment_amount: \"10.0\".to_string(),\n            auto_retry: true,\n            max_retries: 3,\n        }\n    }\n}\n</code></pre>"},{"location":"rust/reference/api-reference/#openlibx402-rocket","title":"openlibx402-rocket","text":""},{"location":"rust/reference/api-reference/#x402config","title":"X402Config","text":"<pre><code>#[derive(Debug, Clone)]\npub struct X402Config {\n    pub payment_address: String,\n    pub token_mint: String,\n    pub network: String,\n    pub rpc_url: Option&lt;String&gt;,\n    pub auto_verify: bool,\n}\n</code></pre>"},{"location":"rust/reference/api-reference/#paymentrequirement","title":"PaymentRequirement","text":"<pre><code>#[derive(Debug, Clone)]\npub struct PaymentRequirement {\n    pub amount: String,\n    pub description: Option&lt;String&gt;,\n    pub expires_in: i64,\n}\n</code></pre>"},{"location":"rust/reference/api-reference/#methods_7","title":"Methods","text":"<pre><code>impl PaymentRequirement {\n    pub fn new(amount: &amp;str) -&gt; Self\n    pub fn with_description(self, description: &amp;str) -&gt; Self\n    pub fn with_expires_in(self, seconds: i64) -&gt; Self\n}\n</code></pre>"},{"location":"rust/reference/api-reference/#paymentguard","title":"PaymentGuard","text":"<pre><code>pub struct PaymentGuard {\n    pub authorization: PaymentAuthorization,\n}\n</code></pre> <p>Implements <code>FromRequest</code> for automatic extraction from HTTP requests.</p>"},{"location":"rust/reference/api-reference/#paymentrequiredresponse","title":"PaymentRequiredResponse","text":"<pre><code>pub struct PaymentRequiredResponse {\n    pub payment_request: PaymentRequest,\n}\n</code></pre> <p>Implements <code>Responder</code> to return 402 status with JSON body.</p>"},{"location":"rust/reference/api-reference/#functions","title":"Functions","text":"<pre><code>pub fn create_payment_request(\n    config: &amp;X402Config,\n    requirement: &amp;PaymentRequirement,\n    resource: &amp;str,\n) -&gt; PaymentRequest\n</code></pre>"},{"location":"rust/reference/api-reference/#openlibx402-actix","title":"openlibx402-actix","text":""},{"location":"rust/reference/api-reference/#x402config_1","title":"X402Config","text":"<pre><code>#[derive(Debug, Clone)]\npub struct X402Config {\n    pub payment_address: String,\n    pub token_mint: String,\n    pub network: String,\n    pub rpc_url: Option&lt;String&gt;,\n    pub auto_verify: bool,\n}\n</code></pre>"},{"location":"rust/reference/api-reference/#x402state","title":"X402State","text":"<pre><code>#[derive(Debug, Clone)]\npub struct X402State {\n    pub config: X402Config,\n}\n</code></pre>"},{"location":"rust/reference/api-reference/#paymentrequirement_1","title":"PaymentRequirement","text":"<pre><code>#[derive(Debug, Clone)]\npub struct PaymentRequirement {\n    pub amount: String,\n    pub description: Option&lt;String&gt;,\n    pub expires_in: i64,\n}\n</code></pre>"},{"location":"rust/reference/api-reference/#methods_8","title":"Methods","text":"<pre><code>impl PaymentRequirement {\n    pub fn new(amount: &amp;str) -&gt; Self\n    pub fn with_description(self, description: &amp;str) -&gt; Self\n    pub fn with_expires_in(self, seconds: i64) -&gt; Self\n}\n</code></pre>"},{"location":"rust/reference/api-reference/#paymentextractor","title":"PaymentExtractor","text":"<pre><code>pub struct PaymentExtractor {\n    pub authorization: PaymentAuthorization,\n}\n</code></pre> <p>Implements <code>FromRequest</code> for automatic extraction from HTTP requests.</p>"},{"location":"rust/reference/api-reference/#paymenterror","title":"PaymentError","text":"<pre><code>pub enum PaymentError {\n    Required,\n    InvalidHeader,\n    InvalidAuthorization(String),\n}\n</code></pre> <p>Implements <code>ResponseError</code> for automatic HTTP error responses.</p>"},{"location":"rust/reference/api-reference/#functions_1","title":"Functions","text":"<pre><code>pub fn create_payment_request(\n    config: &amp;X402Config,\n    requirement: &amp;PaymentRequirement,\n    resource: &amp;str,\n) -&gt; PaymentRequest\n\npub fn payment_required_response(payment_request: PaymentRequest) -&gt; HttpResponse\n</code></pre>"},{"location":"rust/reference/api-reference/#usage-examples","title":"Usage Examples","text":""},{"location":"rust/reference/api-reference/#core","title":"Core","text":"<pre><code>use openlibx402_core::{PaymentRequest, PaymentAuthorization, SolanaPaymentProcessor};\n\n// Create payment processor\nlet processor = SolanaPaymentProcessor::new(\"https://api.devnet.solana.com\", None);\n\n// Create payment\nlet authorization = processor.create_payment(&amp;payment_request, &amp;keypair).await?;\n\n// Verify payment\nlet verified = processor.verify_payment(&amp;authorization, \"0.10\").await?;\n</code></pre>"},{"location":"rust/reference/api-reference/#client","title":"Client","text":"<pre><code>use openlibx402_client::{X402AutoClient, AutoClientOptions};\n\nlet options = AutoClientOptions {\n    max_payment_amount: \"5.0\".to_string(),\n    auto_retry: true,\n    max_retries: 3,\n};\n\nlet client = X402AutoClient::new(keypair, None, Some(options));\nlet response = client.get(\"http://localhost:8000/premium\").await?;\n</code></pre>"},{"location":"rust/reference/api-reference/#rocket","title":"Rocket","text":"<pre><code>use openlibx402_rocket::{PaymentGuard, X402Config};\n\n#[get(\"/premium\")]\nfn premium(auth: PaymentGuard) -&gt; String {\n    format!(\"Payment ID: {}\", auth.authorization.payment_id)\n}\n</code></pre>"},{"location":"rust/reference/api-reference/#actix-web","title":"Actix Web","text":"<pre><code>use openlibx402_actix::{PaymentExtractor, X402State};\n\n#[get(\"/premium\")]\nasync fn premium(auth: PaymentExtractor) -&gt; HttpResponse {\n    HttpResponse::Ok().json(serde_json::json!({\n        \"payment_id\": auth.authorization.payment_id\n    }))\n}\n</code></pre>"},{"location":"rust/reference/api-reference/#see-also","title":"See Also","text":"<ul> <li>Configuration Reference</li> <li>Error Handling</li> <li>Core Library</li> <li>Client Library</li> </ul>"},{"location":"rust/reference/configuration/","title":"Configuration Reference","text":"<p>Complete configuration reference for all Rust packages.</p>"},{"location":"rust/reference/configuration/#server-configuration","title":"Server Configuration","text":""},{"location":"rust/reference/configuration/#x402config","title":"X402Config","text":"<p>Global configuration for X402 payments in server applications.</p> <pre><code>pub struct X402Config {\n    /// Wallet address to receive payments\n    pub payment_address: String,\n\n    /// SPL token mint address (USDC)\n    pub token_mint: String,\n\n    /// Solana network identifier\n    pub network: String,\n\n    /// Optional custom RPC URL\n    pub rpc_url: Option&lt;String&gt;,\n\n    /// Whether to verify payments on-chain\n    pub auto_verify: bool,\n}\n</code></pre>"},{"location":"rust/reference/configuration/#configuration-options","title":"Configuration Options","text":""},{"location":"rust/reference/configuration/#payment_address-required","title":"payment_address (Required)","text":"<p>Your Solana wallet address that will receive payments.</p> <pre><code>payment_address: \"7xKXtg2CW87d97TXJSDpbD5jBkheTqA83TZRuJosgAsU\".to_string()\n</code></pre> <p>How to get: <pre><code># View your wallet address\nsolana-keygen pubkey ~/.config/solana/id.json\n</code></pre></p>"},{"location":"rust/reference/configuration/#token_mint-required","title":"token_mint (Required)","text":"<p>The SPL token mint address for the token you want to receive.</p> <pre><code>// USDC on Devnet\ntoken_mint: \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\".to_string()\n\n// USDC on Mainnet\ntoken_mint: \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\".to_string()\n</code></pre>"},{"location":"rust/reference/configuration/#network-required","title":"network (Required)","text":"<p>The Solana network to use.</p> <pre><code>// For development and testing\nnetwork: \"solana-devnet\".to_string()\n\n// For production\nnetwork: \"solana-mainnet\".to_string()\n\n// For testing\nnetwork: \"solana-testnet\".to_string()\n</code></pre>"},{"location":"rust/reference/configuration/#rpc_url-optional","title":"rpc_url (Optional)","text":"<p>Custom RPC endpoint. If not specified, uses default for the network.</p> <pre><code>// Use default\nrpc_url: None\n\n// Use custom RPC\nrpc_url: Some(\"https://your-rpc-endpoint.com\".to_string())\n</code></pre> <p>Default RPC URLs: - Devnet: <code>https://api.devnet.solana.com</code> - Mainnet: <code>https://api.mainnet-beta.solana.com</code> - Testnet: <code>https://api.testnet.solana.com</code></p>"},{"location":"rust/reference/configuration/#auto_verify-required","title":"auto_verify (Required)","text":"<p>Whether to automatically verify payments on-chain.</p> <pre><code>// Verify all payments (recommended for production)\nauto_verify: true\n\n// Skip verification (faster, less secure)\nauto_verify: false\n</code></pre> <p>Recommendation: Enable for production, can disable for development.</p>"},{"location":"rust/reference/configuration/#example-configurations","title":"Example Configurations","text":""},{"location":"rust/reference/configuration/#development","title":"Development","text":"<pre><code>let config = X402Config {\n    payment_address: env::var(\"PAYMENT_ADDRESS\")?,\n    token_mint: \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\".to_string(),\n    network: \"solana-devnet\".to_string(),\n    rpc_url: None,\n    auto_verify: false,  // Faster for development\n};\n</code></pre>"},{"location":"rust/reference/configuration/#production","title":"Production","text":"<pre><code>let config = X402Config {\n    payment_address: env::var(\"PAYMENT_ADDRESS\")?,\n    token_mint: \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\".to_string(),\n    network: \"solana-mainnet\".to_string(),\n    rpc_url: Some(env::var(\"SOLANA_RPC_URL\")?),  // Use dedicated RPC\n    auto_verify: true,  // Verify all payments\n};\n</code></pre>"},{"location":"rust/reference/configuration/#high-performance","title":"High Performance","text":"<pre><code>let config = X402Config {\n    payment_address: env::var(\"PAYMENT_ADDRESS\")?,\n    token_mint: \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\".to_string(),\n    network: \"solana-mainnet\".to_string(),\n    rpc_url: Some(\"https://your-fast-rpc.com\".to_string()),\n    auto_verify: true,\n};\n</code></pre>"},{"location":"rust/reference/configuration/#payment-requirements","title":"Payment Requirements","text":""},{"location":"rust/reference/configuration/#paymentrequirement","title":"PaymentRequirement","text":"<p>Configuration for individual endpoint payment requirements.</p> <pre><code>pub struct PaymentRequirement {\n    /// Amount required in USDC\n    pub amount: String,\n\n    /// Optional human-readable description\n    pub description: Option&lt;String&gt;,\n\n    /// Expiration time in seconds (default: 300)\n    pub expires_in: i64,\n}\n</code></pre>"},{"location":"rust/reference/configuration/#configuration-options_1","title":"Configuration Options","text":""},{"location":"rust/reference/configuration/#amount-required","title":"amount (Required)","text":"<p>Payment amount in USDC.</p> <pre><code>// Micropayment\nlet req = PaymentRequirement::new(\"0.001\");\n\n// Standard\nlet req = PaymentRequirement::new(\"0.10\");\n\n// Premium\nlet req = PaymentRequirement::new(\"1.00\");\n</code></pre>"},{"location":"rust/reference/configuration/#description-optional","title":"description (Optional)","text":"<p>Human-readable description shown to users.</p> <pre><code>let req = PaymentRequirement::new(\"0.10\")\n    .with_description(\"Access to premium market data\");\n</code></pre>"},{"location":"rust/reference/configuration/#expires_in-optional","title":"expires_in (Optional)","text":"<p>Payment validity duration in seconds.</p> <pre><code>// Short-lived: 1 minute\nlet req = PaymentRequirement::new(\"0.01\")\n    .with_expires_in(60);\n\n// Standard: 5 minutes (default)\nlet req = PaymentRequirement::new(\"0.10\")\n    .with_expires_in(300);\n\n// Long-lived: 1 hour\nlet req = PaymentRequirement::new(\"1.00\")\n    .with_expires_in(3600);\n</code></pre> <p>Recommendation: Use shorter expirations for lower amounts, longer for higher amounts.</p>"},{"location":"rust/reference/configuration/#example-requirements","title":"Example Requirements","text":""},{"location":"rust/reference/configuration/#basic-tier","title":"Basic Tier","text":"<pre><code>PaymentRequirement::new(\"0.01\")\n    .with_description(\"Basic tier access\")\n    .with_expires_in(300)\n</code></pre>"},{"location":"rust/reference/configuration/#premium-tier","title":"Premium Tier","text":"<pre><code>PaymentRequirement::new(\"0.10\")\n    .with_description(\"Premium tier with advanced features\")\n    .with_expires_in(600)\n</code></pre>"},{"location":"rust/reference/configuration/#enterprise-tier","title":"Enterprise Tier","text":"<pre><code>PaymentRequirement::new(\"5.00\")\n    .with_description(\"Enterprise tier with full API access\")\n    .with_expires_in(3600)\n</code></pre>"},{"location":"rust/reference/configuration/#client-configuration","title":"Client Configuration","text":""},{"location":"rust/reference/configuration/#autoclientoptions","title":"AutoClientOptions","text":"<p>Configuration for automatic payment handling.</p> <pre><code>pub struct AutoClientOptions {\n    /// Maximum amount willing to pay automatically (in USDC)\n    pub max_payment_amount: String,\n\n    /// Whether to automatically retry after payment\n    pub auto_retry: bool,\n\n    /// Maximum number of retry attempts\n    pub max_retries: u32,\n}\n</code></pre>"},{"location":"rust/reference/configuration/#configuration-options_2","title":"Configuration Options","text":""},{"location":"rust/reference/configuration/#max_payment_amount-optional","title":"max_payment_amount (Optional)","text":"<p>Maximum amount the client will automatically pay.</p> <pre><code>// Conservative\nlet options = AutoClientOptions {\n    max_payment_amount: \"1.0\".to_string(),\n    ..Default::default()\n};\n\n// Moderate\nlet options = AutoClientOptions {\n    max_payment_amount: \"10.0\".to_string(),  // Default\n    ..Default::default()\n};\n\n// Generous\nlet options = AutoClientOptions {\n    max_payment_amount: \"100.0\".to_string(),\n    ..Default::default()\n};\n</code></pre>"},{"location":"rust/reference/configuration/#auto_retry-optional","title":"auto_retry (Optional)","text":"<p>Whether to automatically retry after payment.</p> <pre><code>// Auto-retry (default)\nlet options = AutoClientOptions {\n    auto_retry: true,\n    ..Default::default()\n};\n\n// Manual retry\nlet options = AutoClientOptions {\n    auto_retry: false,\n    ..Default::default()\n};\n</code></pre>"},{"location":"rust/reference/configuration/#max_retries-optional","title":"max_retries (Optional)","text":"<p>Maximum retry attempts after payment.</p> <pre><code>// Few retries\nlet options = AutoClientOptions {\n    max_retries: 1,\n    ..Default::default()\n};\n\n// Standard\nlet options = AutoClientOptions {\n    max_retries: 3,  // Default\n    ..Default::default()\n};\n\n// Many retries\nlet options = AutoClientOptions {\n    max_retries: 10,\n    ..Default::default()\n};\n</code></pre>"},{"location":"rust/reference/configuration/#example-configurations_1","title":"Example Configurations","text":""},{"location":"rust/reference/configuration/#conservative","title":"Conservative","text":"<pre><code>let options = AutoClientOptions {\n    max_payment_amount: \"1.0\".to_string(),\n    auto_retry: true,\n    max_retries: 1,\n};\n</code></pre>"},{"location":"rust/reference/configuration/#balanced-default","title":"Balanced (Default)","text":"<pre><code>let options = AutoClientOptions {\n    max_payment_amount: \"10.0\".to_string(),\n    auto_retry: true,\n    max_retries: 3,\n};\n</code></pre>"},{"location":"rust/reference/configuration/#aggressive","title":"Aggressive","text":"<pre><code>let options = AutoClientOptions {\n    max_payment_amount: \"100.0\".to_string(),\n    auto_retry: true,\n    max_retries: 5,\n};\n</code></pre>"},{"location":"rust/reference/configuration/#environment-variables","title":"Environment Variables","text":"<p>Recommended environment variables for configuration.</p>"},{"location":"rust/reference/configuration/#server","title":"Server","text":"<pre><code># Required\nexport X402_PAYMENT_ADDRESS=\"7xKXtg2CW87d97TXJSDpbD5jBkheTqA83TZRuJosgAsU\"\nexport X402_TOKEN_MINT=\"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\"\nexport X402_NETWORK=\"solana-devnet\"\n\n# Optional\nexport X402_RPC_URL=\"https://your-rpc.com\"\nexport X402_AUTO_VERIFY=\"true\"\n</code></pre>"},{"location":"rust/reference/configuration/#client","title":"Client","text":"<pre><code># Required\nexport SOLANA_KEYPAIR=\"$HOME/.config/solana/id.json\"\n\n# Optional\nexport X402_MAX_PAYMENT=\"10.0\"\nexport X402_MAX_RETRIES=\"3\"\nexport SOLANA_RPC_URL=\"https://api.devnet.solana.com\"\n</code></pre>"},{"location":"rust/reference/configuration/#loading-from-environment","title":"Loading from Environment","text":"<pre><code>use std::env;\n\n// Server\nlet config = X402Config {\n    payment_address: env::var(\"X402_PAYMENT_ADDRESS\")?,\n    token_mint: env::var(\"X402_TOKEN_MINT\")?,\n    network: env::var(\"X402_NETWORK\")?,\n    rpc_url: env::var(\"X402_RPC_URL\").ok(),\n    auto_verify: env::var(\"X402_AUTO_VERIFY\").unwrap_or(\"true\".to_string()) == \"true\",\n};\n\n// Client\nlet keypair = read_keypair_file(env::var(\"SOLANA_KEYPAIR\")?)?;\nlet options = AutoClientOptions {\n    max_payment_amount: env::var(\"X402_MAX_PAYMENT\").unwrap_or(\"10.0\".to_string()),\n    auto_retry: true,\n    max_retries: env::var(\"X402_MAX_RETRIES\")\n        .unwrap_or(\"3\".to_string())\n        .parse()\n        .unwrap_or(3),\n};\n</code></pre>"},{"location":"rust/reference/configuration/#best-practices","title":"Best Practices","text":""},{"location":"rust/reference/configuration/#1-use-environment-variables-in-production","title":"1. Use Environment Variables in Production","text":"<pre><code>let config = X402Config {\n    payment_address: env::var(\"X402_PAYMENT_ADDRESS\")\n        .expect(\"X402_PAYMENT_ADDRESS must be set\"),\n    // ...\n};\n</code></pre>"},{"location":"rust/reference/configuration/#2-enable-verification-in-production","title":"2. Enable Verification in Production","text":"<pre><code>auto_verify: env::var(\"ENV\")\n    .map(|e| e == \"production\")\n    .unwrap_or(false)\n</code></pre>"},{"location":"rust/reference/configuration/#3-use-dedicated-rpc-endpoints","title":"3. Use Dedicated RPC Endpoints","text":"<pre><code>rpc_url: Some(env::var(\"SOLANA_RPC_URL\")?)\n</code></pre>"},{"location":"rust/reference/configuration/#4-set-reasonable-payment-limits","title":"4. Set Reasonable Payment Limits","text":"<pre><code>max_payment_amount: \"10.0\".to_string()  // Not too high, not too low\n</code></pre>"},{"location":"rust/reference/configuration/#5-log-configuration-safely","title":"5. Log Configuration (Safely)","text":"<pre><code>println!(\"X402 Config:\");\nprintln!(\"  Network: {}\", config.network);\nprintln!(\"  Auto-verify: {}\", config.auto_verify);\n// Don't log sensitive data like private keys\n</code></pre>"},{"location":"rust/reference/configuration/#see-also","title":"See Also","text":"<ul> <li>API Reference</li> <li>Error Handling</li> <li>Server Quick Start</li> <li>Client Quick Start</li> </ul>"},{"location":"rust/reference/errors/","title":"Error Handling","text":"<p>Comprehensive guide to error handling in OpenLibx402 Rust SDK.</p>"},{"location":"rust/reference/errors/#x402error-enum","title":"X402Error Enum","text":"<p>All X402 operations return <code>X402Result&lt;T&gt;</code> which is an alias for <code>Result&lt;T, X402Error&gt;</code>.</p> <pre><code>pub enum X402Error {\n    PaymentRequired(String),\n    PaymentExpired(String),\n    InsufficientFunds(String),\n    PaymentVerification(String),\n    TransactionBroadcast(String),\n    InvalidPaymentRequest(String),\n    InvalidPaymentAuthorization(String),\n    Configuration(String),\n    Network(String),\n    Blockchain(String),\n    Serialization(String),\n}\n</code></pre>"},{"location":"rust/reference/errors/#error-types","title":"Error Types","text":""},{"location":"rust/reference/errors/#paymentrequired","title":"PaymentRequired","text":"<p>Payment is required to access the resource.</p> <p>When it occurs: - Client makes request without payment authorization - Server returns 402 status code - Auto client exceeds max payment amount</p> <p>Example: <pre><code>match client.get(url).await {\n    Err(X402Error::PaymentRequired(msg)) =&gt; {\n        eprintln!(\"Payment required: {}\", msg);\n        // Handle by creating payment\n    }\n    // ...\n}\n</code></pre></p> <p>Error code: <code>PAYMENT_REQUIRED</code></p>"},{"location":"rust/reference/errors/#paymentexpired","title":"PaymentExpired","text":"<p>The payment request or authorization has expired.</p> <p>When it occurs: - Payment request timestamp has passed - Attempting to use expired payment authorization - Server rejects expired payment</p> <p>Example: <pre><code>match processor.create_payment(&amp;request, &amp;keypair).await {\n    Err(X402Error::PaymentExpired(msg)) =&gt; {\n        eprintln!(\"Payment expired: {}\", msg);\n        // Request new payment details from server\n    }\n    // ...\n}\n</code></pre></p> <p>Error code: <code>PAYMENT_EXPIRED</code></p>"},{"location":"rust/reference/errors/#insufficientfunds","title":"InsufficientFunds","text":"<p>Wallet doesn't have enough funds for the payment.</p> <p>When it occurs: - Token balance is less than required amount - Not enough SOL for transaction fees</p> <p>Example: <pre><code>match processor.create_payment(&amp;request, &amp;keypair).await {\n    Err(X402Error::InsufficientFunds(msg)) =&gt; {\n        eprintln!(\"Insufficient funds: {}\", msg);\n        // Show user balance and required amount\n        // Prompt to add funds\n    }\n    // ...\n}\n</code></pre></p> <p>Error code: <code>INSUFFICIENT_FUNDS</code></p>"},{"location":"rust/reference/errors/#paymentverification","title":"PaymentVerification","text":"<p>Payment verification failed.</p> <p>When it occurs: - Transaction not found on-chain - Amount doesn't match expected - Transaction failed - Invalid transaction signature</p> <p>Example: <pre><code>match processor.verify_payment(&amp;auth, \"0.10\").await {\n    Err(X402Error::PaymentVerification(msg)) =&gt; {\n        eprintln!(\"Verification failed: {}\", msg);\n        // Payment may not be confirmed yet\n        // Or transaction details don't match\n    }\n    // ...\n}\n</code></pre></p> <p>Error code: <code>PAYMENT_VERIFICATION_FAILED</code></p>"},{"location":"rust/reference/errors/#transactionbroadcast","title":"TransactionBroadcast","text":"<p>Failed to broadcast transaction to the blockchain.</p> <p>When it occurs: - Network connectivity issues - RPC endpoint unavailable - Invalid transaction - Nonce errors</p> <p>Example: <pre><code>match processor.create_payment(&amp;request, &amp;keypair).await {\n    Err(X402Error::TransactionBroadcast(msg)) =&gt; {\n        eprintln!(\"Broadcast failed: {}\", msg);\n        // Retry with exponential backoff\n        // Or try different RPC endpoint\n    }\n    // ...\n}\n</code></pre></p> <p>Error code: <code>TRANSACTION_BROADCAST_FAILED</code></p>"},{"location":"rust/reference/errors/#invalidpaymentrequest","title":"InvalidPaymentRequest","text":"<p>Payment request is malformed or invalid.</p> <p>When it occurs: - JSON parsing fails - Required fields missing - Invalid addresses - Invalid amounts</p> <p>Example: <pre><code>match PaymentRequest::from_json(json) {\n    Err(X402Error::InvalidPaymentRequest(msg)) =&gt; {\n        eprintln!(\"Invalid payment request: {}\", msg);\n        // Server sent bad data\n    }\n    // ...\n}\n</code></pre></p> <p>Error code: <code>INVALID_PAYMENT_REQUEST</code></p>"},{"location":"rust/reference/errors/#invalidpaymentauthorization","title":"InvalidPaymentAuthorization","text":"<p>Payment authorization is malformed or invalid.</p> <p>When it occurs: - Header parsing fails - Base64 decoding fails - Required fields missing - Invalid format</p> <p>Example: <pre><code>match PaymentAuthorization::from_header_value(header) {\n    Err(X402Error::InvalidPaymentAuthorization(msg)) =&gt; {\n        eprintln!(\"Invalid authorization: {}\", msg);\n        // Client sent bad authorization\n    }\n    // ...\n}\n</code></pre></p> <p>Error code: <code>INVALID_PAYMENT_AUTHORIZATION</code></p>"},{"location":"rust/reference/errors/#configuration","title":"Configuration","text":"<p>Configuration error.</p> <p>When it occurs: - Invalid wallet addresses - Invalid network names - Missing required configuration - Invalid RPC URLs</p> <p>Example: <pre><code>let config = X402Config {\n    payment_address: \"invalid\".to_string(),  // Invalid address\n    // ...\n};\n// Error will occur when used\n</code></pre></p> <p>Error code: <code>CONFIGURATION_ERROR</code></p>"},{"location":"rust/reference/errors/#network","title":"Network","text":"<p>Network or HTTP error.</p> <p>When it occurs: - HTTP request fails - Connection timeout - DNS resolution fails - Server unreachable</p> <p>Example: <pre><code>match client.get(url).await {\n    Err(X402Error::Network(msg)) =&gt; {\n        eprintln!(\"Network error: {}\", msg);\n        // Retry with backoff\n    }\n    // ...\n}\n</code></pre></p> <p>Error code: <code>NETWORK_ERROR</code></p>"},{"location":"rust/reference/errors/#blockchain","title":"Blockchain","text":"<p>Solana blockchain error.</p> <p>When it occurs: - RPC errors - Account not found - Program errors - Transaction simulation fails</p> <p>Example: <pre><code>match processor.create_payment(&amp;request, &amp;keypair).await {\n    Err(X402Error::Blockchain(msg)) =&gt; {\n        eprintln!(\"Blockchain error: {}\", msg);\n        // May be transient, retry\n    }\n    // ...\n}\n</code></pre></p> <p>Error code: <code>BLOCKCHAIN_ERROR</code></p>"},{"location":"rust/reference/errors/#serialization","title":"Serialization","text":"<p>JSON serialization/deserialization error.</p> <p>When it occurs: - JSON parsing fails - Base64 encoding/decoding fails - Invalid UTF-8</p> <p>Example: <pre><code>match payment_request.to_json() {\n    Err(X402Error::Serialization(msg)) =&gt; {\n        eprintln!(\"Serialization error: {}\", msg);\n        // Data structure issue\n    }\n    // ...\n}\n</code></pre></p> <p>Error code: <code>SERIALIZATION_ERROR</code></p>"},{"location":"rust/reference/errors/#error-handling-patterns","title":"Error Handling Patterns","text":""},{"location":"rust/reference/errors/#basic-error-handling","title":"Basic Error Handling","text":"<pre><code>use openlibx402_core::X402Error;\n\nmatch client.get(url).await {\n    Ok(response) =&gt; {\n        // Handle success\n    }\n    Err(e) =&gt; {\n        eprintln!(\"Error: {}\", e);\n    }\n}\n</code></pre>"},{"location":"rust/reference/errors/#match-specific-errors","title":"Match Specific Errors","text":"<pre><code>match client.get(url).await {\n    Ok(response) =&gt; {\n        // Handle success\n    }\n    Err(X402Error::PaymentRequired(msg)) =&gt; {\n        // Handle payment required\n    }\n    Err(X402Error::InsufficientFunds(msg)) =&gt; {\n        // Handle insufficient funds\n    }\n    Err(X402Error::Network(msg)) =&gt; {\n        // Handle network error\n    }\n    Err(e) =&gt; {\n        // Handle other errors\n        eprintln!(\"Error: {}\", e);\n    }\n}\n</code></pre>"},{"location":"rust/reference/errors/#retry-logic","title":"Retry Logic","text":"<pre><code>use tokio::time::{sleep, Duration};\n\nasync fn retry_with_backoff&lt;F, T&gt;(\n    mut f: F,\n    max_retries: u32,\n) -&gt; Result&lt;T, X402Error&gt;\nwhere\n    F: FnMut() -&gt; std::pin::Pin&lt;Box&lt;dyn std::future::Future&lt;Output = Result&lt;T, X402Error&gt;&gt;&gt;&gt;,\n{\n    let mut retries = 0;\n    let mut delay = Duration::from_millis(100);\n\n    loop {\n        match f().await {\n            Ok(result) =&gt; return Ok(result),\n            Err(e) =&gt; {\n                retries += 1;\n                if retries &gt;= max_retries {\n                    return Err(e);\n                }\n\n                match e {\n                    X402Error::Network(_) | X402Error::TransactionBroadcast(_) =&gt; {\n                        // Retry network and broadcast errors\n                        sleep(delay).await;\n                        delay *= 2; // Exponential backoff\n                    }\n                    _ =&gt; return Err(e), // Don't retry other errors\n                }\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"rust/reference/errors/#error-recovery","title":"Error Recovery","text":"<pre><code>async fn fetch_with_recovery(client: &amp;X402AutoClient, url: &amp;str) -&gt; Result&lt;String, Box&lt;dyn std::error::Error&gt;&gt; {\n    match client.get(url).await {\n        Ok(response) =&gt; Ok(response.text().await?),\n        Err(X402Error::PaymentExpired(_)) =&gt; {\n            // Payment expired, retry automatically\n            client.get(url).await?.text().await.map_err(Into::into)\n        }\n        Err(X402Error::InsufficientFunds(msg)) =&gt; {\n            Err(format!(\"Please add funds to your wallet: {}\", msg).into())\n        }\n        Err(X402Error::Network(_)) =&gt; {\n            // Retry once for network errors\n            sleep(Duration::from_secs(1)).await;\n            client.get(url).await?.text().await.map_err(Into::into)\n        }\n        Err(e) =&gt; Err(e.into()),\n    }\n}\n</code></pre>"},{"location":"rust/reference/errors/#logging-errors","title":"Logging Errors","text":"<pre><code>use log::{error, warn, info};\n\nmatch client.get(url).await {\n    Ok(response) =&gt; {\n        info!(\"Request successful\");\n    }\n    Err(X402Error::PaymentRequired(msg)) =&gt; {\n        info!(\"Payment required: {}\", msg);\n    }\n    Err(X402Error::PaymentExpired(msg)) =&gt; {\n        warn!(\"Payment expired: {}\", msg);\n    }\n    Err(X402Error::InsufficientFunds(msg)) =&gt; {\n        error!(\"Insufficient funds: {}\", msg);\n    }\n    Err(e) =&gt; {\n        error!(\"Unexpected error: {}\", e);\n    }\n}\n</code></pre>"},{"location":"rust/reference/errors/#custom-error-types","title":"Custom Error Types","text":"<pre><code>use thiserror::Error;\n\n#[derive(Error, Debug)]\npub enum AppError {\n    #[error(\"X402 error: {0}\")]\n    X402(#[from] X402Error),\n\n    #[error(\"Database error: {0}\")]\n    Database(String),\n\n    #[error(\"Application error: {0}\")]\n    Application(String),\n}\n\nasync fn app_logic() -&gt; Result&lt;(), AppError&gt; {\n    let response = client.get(url).await?;  // Auto-converts X402Error\n    // ... other logic\n    Ok(())\n}\n</code></pre>"},{"location":"rust/reference/errors/#error-methods","title":"Error Methods","text":""},{"location":"rust/reference/errors/#code","title":"code()","text":"<p>Get the error code as a string.</p> <pre><code>let error = X402Error::PaymentRequired(\"Payment needed\".to_string());\nprintln!(\"Code: {}\", error.code());  // \"PAYMENT_REQUIRED\"\n</code></pre>"},{"location":"rust/reference/errors/#message","title":"message()","text":"<p>Get the error message.</p> <pre><code>let error = X402Error::InsufficientFunds(\"Not enough USDC\".to_string());\nprintln!(\"Message: {}\", error.message());  // \"Insufficient funds: Not enough USDC\"\n</code></pre>"},{"location":"rust/reference/errors/#best-practices","title":"Best Practices","text":""},{"location":"rust/reference/errors/#1-always-handle-payment-required","title":"1. Always Handle Payment Required","text":"<pre><code>match client.get(url).await {\n    Ok(response) =&gt; { /* ... */ }\n    Err(X402Error::PaymentRequired(_)) =&gt; {\n        // Expected error, handle gracefully\n    }\n    Err(e) =&gt; {\n        // Unexpected error, log and handle\n        eprintln!(\"Unexpected error: {}\", e);\n    }\n}\n</code></pre>"},{"location":"rust/reference/errors/#2-provide-user-friendly-messages","title":"2. Provide User-Friendly Messages","text":"<pre><code>match error {\n    X402Error::InsufficientFunds(_) =&gt; {\n        \"You don't have enough USDC in your wallet. Please add funds.\"\n    }\n    X402Error::PaymentExpired(_) =&gt; {\n        \"Payment request expired. Refreshing...\"\n    }\n    X402Error::Network(_) =&gt; {\n        \"Network connection issue. Retrying...\"\n    }\n    _ =&gt; \"An error occurred. Please try again.\"\n}\n</code></pre>"},{"location":"rust/reference/errors/#3-log-errors-appropriately","title":"3. Log Errors Appropriately","text":"<pre><code>// Info level for expected errors\ninfo!(\"Payment required: {}\", msg);\n\n// Warn level for recoverable errors\nwarn!(\"Payment expired, retrying\");\n\n// Error level for unexpected errors\nerror!(\"Transaction broadcast failed: {}\", msg);\n</code></pre>"},{"location":"rust/reference/errors/#4-retry-transient-errors","title":"4. Retry Transient Errors","text":"<pre><code>match error {\n    X402Error::Network(_) |\n    X402Error::TransactionBroadcast(_) |\n    X402Error::Blockchain(_) =&gt; {\n        // These are often transient, retry\n        retry_operation().await?\n    }\n    _ =&gt; return Err(error),\n}\n</code></pre>"},{"location":"rust/reference/errors/#5-dont-retry-user-errors","title":"5. Don't Retry User Errors","text":"<pre><code>match error {\n    X402Error::InsufficientFunds(_) |\n    X402Error::InvalidPaymentRequest(_) |\n    X402Error::Configuration(_) =&gt; {\n        // User action required, don't retry\n        return Err(error);\n    }\n    _ =&gt; { /* ... */ }\n}\n</code></pre>"},{"location":"rust/reference/errors/#testing-with-errors","title":"Testing with Errors","text":"<pre><code>#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[tokio::test]\n    async fn test_insufficient_funds() {\n        // Test handling of insufficient funds\n        let keypair = Keypair::new();  // Empty wallet\n        let client = X402Client::new(keypair, None);\n\n        match client.create_payment(&amp;payment_request).await {\n            Err(X402Error::InsufficientFunds(_)) =&gt; {\n                // Expected error\n            }\n            _ =&gt; panic!(\"Expected InsufficientFunds error\"),\n        }\n    }\n\n    #[tokio::test]\n    async fn test_expired_payment() {\n        let expired_request = PaymentRequest {\n            expires_at: Utc::now() - Duration::seconds(10),\n            // ...\n        };\n\n        let processor = SolanaPaymentProcessor::new(rpc_url, None);\n        match processor.create_payment(&amp;expired_request, &amp;keypair).await {\n            Err(X402Error::PaymentExpired(_)) =&gt; {\n                // Expected error\n            }\n            _ =&gt; panic!(\"Expected PaymentExpired error\"),\n        }\n    }\n}\n</code></pre>"},{"location":"rust/reference/errors/#see-also","title":"See Also","text":"<ul> <li>API Reference</li> <li>Configuration</li> <li>Core Library</li> <li>Client Library</li> </ul>"}]}